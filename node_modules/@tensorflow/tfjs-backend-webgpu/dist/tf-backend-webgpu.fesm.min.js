/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
import*as e from"@tensorflow/tfjs-core";import{env as t,backend_util as n,util as r,KernelBackend as s,DataStorage as a,engine as i,buffer as o,registerBackend as u,Fill as l,Reshape as h,broadcast_util as d,_FusedMatMul as p,Identity as c,Complex as f,upcastType as m,tidy as g,reshape as b,broadcastTo as x,slice_util as w,TensorBuffer as y,Abs as I,Acos as S,Acosh as k,Add as v,AddN as C,Transpose as $,sumOutType as R,All as A,Any as T,ArgMax as P,ArgMin as N,Asin as z,Asinh as E,Atan as F,Atan2 as B,Atanh as _,Max as O,Mean as L,AvgPool as U,AvgPoolGrad as D,BatchMatMul as W,Slice as M,BatchToSpaceND as V,Bincount as G,NotEqual as H,Real as X,Cast as K,Ceil as q,ClipByValue as j,Imag as Y,Concat as Q,Conv2D as Z,Conv2DBackpropFilter as J,Conv2DBackpropInput as ee,Cos as te,Cosh as ne,CropAndResize as re,Cumprod as se,Cumsum as ae,DenseBincount as ie,DepthToSpace as oe,DepthwiseConv2dNative as ue,Diag as le,Dilation2D as he,Multiply as de,Sum as pe,Einsum as ce,Elu as fe,Equal as me,Erf as ge,Exp as be,ExpandDims as xe,Expm1 as we,FFT as ye,FlipLeftRight as Ie,Floor as Se,FloorDiv as ke,FromPixels as ve,FusedBatchNorm as Ce,FusedConv2D as $e,FusedDepthwiseConv2D as Re,GatherNd as Ae,GatherV2 as Te,Greater as Pe,GreaterEqual as Ne,IFFT as ze,IsFinite as Ee,IsInf as Fe,IsNan as Be,LeakyRelu as _e,Less as Oe,LessEqual as Le,LinSpace as Ue,Log as De,Log1p as We,LogicalAnd as Me,LogicalNot as Ve,LogicalOr as Ge,LRN as He,Maximum as Xe,MaxPool as Ke,Min as qe,Minimum as je,MirrorPad as Ye,Mod as Qe,Neg as Ze,NonMaxSuppressionV3 as Je,kernel_impls as et,NonMaxSuppressionV5 as tt,OneHot as nt,ZerosLike as rt,OnesLike as st,Pack as at,PadV2 as it,Pow as ot,Prelu as ut,Prod as lt,Range as ht,RealDiv as dt,Reciprocal as pt,Relu as ct,Relu6 as ft,ResizeBilinear as mt,ResizeNearestNeighbor as gt,Reverse as bt,RotateWithOffset as xt,Round as wt,Rsqrt as yt,ScatterNd as It,SearchSorted as St,Select as kt,Selu as vt,Sigmoid as Ct,Sign as $t,Sin as Rt,Sinh as At,Sub as Tt,Softmax as Pt,Softplus as Nt,SpaceToBatchND as zt,Tile as Et,SparseToDense as Ft,SplitV as Bt,Sqrt as _t,Square as Ot,SquaredDifference as Lt,Step as Ut,StridedSlice as Dt,StringNGrams as Wt,Tan as Mt,Tanh as Vt,TopK as Gt,Transform as Ht,Unpack as Xt,registerKernel as Kt}from"@tensorflow/tfjs-core";const qt=t();qt.registerFlag("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE",(()=>15)),qt.registerFlag("WEBGPU_CPU_FORWARD",(()=>!0)),qt.registerFlag("WEBGPU_MATMUL_PROGRAM_TYPE",(()=>-1)),qt.registerFlag("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE",(()=>!1)),qt.registerFlag("WEBGPU_USE_LOW_POWER_GPU",(()=>!1)),qt.registerFlag("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD",(()=>1e3)),qt.registerFlag("WEBGPU_USE_PROFILE_TOOL",(()=>!1)),qt.registerFlag("WEBGPU_IMPORT_EXTERNAL_TEXTURE",(()=>!0)),qt.registerFlag("WEBGPU_USE_NAIVE_CONV2D_DEBUG",(()=>!1)),qt.registerFlag("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL",(()=>0)),qt.registerFlag("WEBGPU_CONV_SEPARATE_IM2COL_SHADER",(()=>!1));class jt{constructor(e){e&&(this.vendor=e.vendor,this.architecture=e.architecture,this.intelGPUGeneration=this.getIntelGPUGeneration())}getIntelGPUGeneration(){if(this.isIntel()){if(this.architecture.startsWith("gen"))return Number(this.architecture.match(/\d+/));if(this.architecture.startsWith("xe"))return 12}return 0}isIntel(){return"intel"===this.vendor}}class Yt{constructor(e){this.device=e,this.numUsedBuffers=0,this.numFreeBuffers=0,this.freeBuffers=new Map,this.usedBuffers=new Map,this.numBytesUsed=0,this.numBytesAllocated=0}acquireUploadBuffer(e,t){return this.acquireBuffer(e,t,!0)}acquireBuffer(e,t,n=!1){const r=Qt(e,t);if(this.freeBuffers.has(r)||this.freeBuffers.set(r,[]),this.usedBuffers.has(r)||this.usedBuffers.set(r,[]),this.numBytesUsed+=e,this.numUsedBuffers++,this.freeBuffers.get(r).length>0){this.numFreeBuffers--;const e=this.freeBuffers.get(r).shift();return this.usedBuffers.get(r).push(e),e}this.numBytesAllocated+=e;const s=this.device.createBuffer({size:e,usage:t,mappedAtCreation:n});return this.usedBuffers.get(r).push(s),s}releaseBuffer(e,t,n){if(0===this.freeBuffers.size)return;const r=Qt(t,n);this.freeBuffers.has(r)||this.freeBuffers.set(r,[]),this.freeBuffers.get(r).push(e),this.numFreeBuffers++,this.numUsedBuffers--;const s=this.usedBuffers.get(r),a=s.indexOf(e);if(a<0)throw new Error("Cannot release a buffer that was never provided by this buffer manager");s.splice(a,1),this.numBytesUsed-=t}releaseUploadBuffer(e,t,n){e.mapAsync(GPUMapMode.WRITE).then((()=>{this.releaseBuffer(e,t,n)}),(e=>{}))}getNumUsedBuffers(){return this.numUsedBuffers}getNumFreeBuffers(){return this.numFreeBuffers}dispose(){this.freeBuffers.forEach(((e,t)=>{e.forEach((e=>{e.destroy()}))})),this.usedBuffers.forEach(((e,t)=>{e.forEach((e=>{e.destroy()}))})),this.freeBuffers=new Map,this.usedBuffers=new Map,this.numUsedBuffers=0,this.numFreeBuffers=0,this.numBytesUsed=0,this.numBytesAllocated=0}}function Qt(e,t){return`${e}_${t}`}class Zt{constructor(e){this.device=e,this.numUsedTextures=0,this.numFreeTextures=0,this.freeTextures=new Map,this.usedTextures=new Map,this.numBytesUsed=0,this.numBytesAllocated=0}acquireTexture(e,t,n,r){const s=e*t*en(n),a=Jt(e,t,n,r);if(this.freeTextures.has(a)||this.freeTextures.set(a,[]),this.usedTextures.has(a)||this.usedTextures.set(a,[]),this.numBytesUsed+=s,this.numUsedTextures++,this.freeTextures.get(a).length>0){this.numFreeTextures--;const e=this.freeTextures.get(a).shift();return this.usedTextures.get(a).push(e),e}this.numBytesAllocated+=s;const i=this.device.createTexture({size:[e,t],format:n,usage:r});return this.usedTextures.get(a).push(i),i}releaseTexture(e,t,n,r,s){if(0===this.freeTextures.size)return;const a=Jt(t,n,r,s);this.freeTextures.has(a)||this.freeTextures.set(a,[]),this.freeTextures.get(a).push(e),this.numFreeTextures++,this.numUsedTextures--;const i=this.usedTextures.get(a),o=i.indexOf(e);if(o<0)throw new Error("Cannot release a texture that was never provided by this texture manager");i.splice(o,1);const u=t*n*en(r);this.numBytesUsed-=u}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){this.freeTextures.forEach(((e,t)=>{e.forEach((e=>{e.destroy()}))})),this.usedTextures.forEach(((e,t)=>{e.forEach((e=>{e.destroy()}))})),this.freeTextures=new Map,this.usedTextures=new Map,this.numUsedTextures=0,this.numFreeTextures=0,this.numBytesUsed=0,this.numBytesAllocated=0}}function Jt(e,t,n,r){return`${e}_${t}_${n}_${r}`}function en(e){if("rgba8unorm"===e)return 16;throw new Error(`${e} is not supported!`)}function tn(e,t){if(Math.max(...e)>3)throw new Error("Cannot symbolically compute strides for rank > 4 tensor.");const n=e.length,r=e.map((e=>`${t}[${e}]`)),s=new Array(n-1);s[n-2]=r[n-1];for(let e=n-3;e>=0;--e)s[e]=`(${s[e+1]} * ${r[e+1]})`;return s}const nn=(e,t,n)=>"int32"===n?`atomicAdd(${e}, bitcast<i32>(${t}));`:`\n          {\n            var oldValue = 0;\n            loop {\n              let newValueF32 = bitcast<f32>(oldValue) + (${t});\n              let newValue = bitcast<i32>(newValueF32);\n              let res = atomicCompareExchangeWeak(${e}, oldValue, newValue);\n              if res.exchanged {\n                break;\n              }\n              oldValue = res.old_value;\n            }\n          }`,rn=(e,t,s,a)=>{const i=function(e,t,s){const a=[],i=s.workgroupSize[0]*s.workgroupSize[1]*s.workgroupSize[2];if(a.push(`\n\n      var<private> localId: vec3<u32>;\n      var<private> localIndex: u32;\n      var<private> globalId: vec3<u32>;\n      var<private> numWorkgroups: vec3<u32>;\n      var<private> workgroupId: vec3<u32>;\n\n      // Only used when the y/z dimension of workgroup size is 1.\n      fn getGlobalIndex() -> i32 {\n        ${cn(s)?"  return i32(globalId.x);":`  return i32((workgroupId.z * numWorkgroups.x * numWorkgroups.y +\n                workgroupId.y * numWorkgroups.x + workgroupId.x) * ${i}u +\n                localIndex);\n        `}\n      }\n    `),s.isFromPixels){a.push(`\n        struct Uniform {\n          size            : i32,\n          numChannels     : i32,\n          outShapeStrides : vec2<i32>,\n        };\n\n        @group(0) @binding(0) var<storage, read_write> result: array<${fn(t.dtype,s.isVec4)}>;\n        @group(0) @binding(2) var<uniform> uniforms: Uniform;\n      `);const e=mn(s);return[ln,a.join("\n"),dn(t.shape),s.getUserCode(),un(e,s)].join("\n")}let o="struct Uniforms { NAN : f32, INFINITY : f32, ";s.variableNames.forEach(((t,n)=>{const r=sn(e[n].shape.length);o+=`${t.charAt(0).toLowerCase()+t.slice(1)}Shape : ${r}, `}));const u=sn(t.shape.length);o+=`outShape : ${u}, `;const l=sn(t.shape.length-1);o+=`\n         outShapeStrides: ${l}, `,s.size&&(o+="size : i32, ");s.uniforms&&(o+=s.uniforms);o+="};",o=function(e){const t=/(\w+)\s*:\s*vec(5|6)/g;e=e.replace(t,(e=>"@align(16) "+e));const n=/vec(5|6)\s*,\s*(\w+)/g;return e=e.replace(n,((e,t,n)=>`vec${t}, @align(16) ${n}`))}(o),a.push(o),s.atomic?a.push("\n      @group(0) @binding(0) var<storage, read_write> result: array<atomic<i32>>;\n    "):a.push(`\n      @group(0) @binding(0) var<storage, read_write> result: array<${fn(t.dtype,s.isVec4)}>;\n    `);s.variableNames.forEach(((t,n)=>{a.push(`\n      @group(0) @binding(${1+n}) var<storage, read> ${t}: array<${s.variableTypes?s.variableTypes[n]:fn(e[n].dtype,s.isVec4)}>;\n        `)})),""!==o&&a.push(`\n      @group(0) @binding(${1+s.variableNames.length}) var<uniform> uniforms: Uniforms;\n      `);const h=function(e,t){const{x:n,y:r=[],z:s=[]}=t,a=e.length,i=n.length+r.length+s.length;if(i!==a)return"";if(n.length===a){return`fn getOutputCoords() -> ${sn(a)}{\n    let globalIndex = getGlobalIndex();\n    return getCoordsFromIndex(globalIndex);\n  }\n  `}let o="";const u=[n,r,s];for(let e=0;e<u.length;e++){const t=u[e];if(0!==t.length)if(1===t.length)o+=`let d${t[0]} = i32(globalId[${e}]);`;else{const n=tn(t,"uniforms.outShape");o+=`var index${e} = i32(globalId[${e}]);`;for(let r=0;r<n.length;r++)o+=`let d${t[r]} = index${e} / ${n[r]};`,r===n.length-1?o+=`let d${t[r+1]} = index${e} - d${t[r]} * ${n[r]};`:o+=`index${e} = index${e} - d${t[r]} * ${n[r]};`}}const l=[];for(let e=0;e<i;e++)l.push(`d${e}`);const h=sn(i);let d=`fn getOutputCoords() -> ${h} {\n  ${o}\n`;0===l.length?d+=`return ${h}(0); }`:d+=`return ${h}(${l.join(",")}); }`;return d}(t.shape,s.dispatchLayout),d=[ln,a.join("\n")+hn,dn(t.shape),h,pn(t.shape.length)];s.atomic||d.push(function(e,t,n){const r=e.length,s=fn(t,n);let a;a=n?`fn setOutputAtIndex(flatIndex : i32, value : vec4<f32>) {\n      result[flatIndex] = ${s}(value);\n    }\n    fn setOutputAtIndexI32(flatIndex : i32, value : vec4<i32>) {\n      result[flatIndex] = ${s}(value);\n    }`:`fn setOutputAtIndex(flatIndex : i32, value : f32) {\n      result[flatIndex] = ${s}(value);\n    }\n    fn setOutputAtIndexI32(flatIndex : i32, value : i32) {\n      result[flatIndex] = ${s}(value);\n    }`;if(r>=2){const e=["d0","d1","d2","d3","d4","d5"].slice(0,r),t=sn(r);a+=n?`\n      fn setOutputAtCoords(${e.map((e=>`${e} : i32`)).join(", ")}, value : vec4<f32>) {\n        let flatIndex = getOutputIndexFromCoords(${t}(${e.join(", ")}));\n        setOutputAtIndex(flatIndex / 4, value);\n      }\n      fn setOutputAtCoordsI32(${e.map((e=>`${e} : i32`)).join(", ")}, value : vec4<i32>) {\n        let flatIndex = getOutputIndexFromCoords(${t}(${e.join(", ")}));\n        setOutputAtIndexI32(flatIndex / 4, value);\n      }\n    `:`\n      fn setOutputAtCoords(${e.map((e=>`${e} : i32`)).join(", ")}, value : f32) {\n        let flatIndex = getOutputIndexFromCoords(${t}(${e.join(", ")}));\n        setOutputAtIndex(flatIndex, value);\n      }\n      fn setOutputAtCoordsI32(${e.map((e=>`${e} : i32`)).join(", ")}, value : i32) {\n        let flatIndex = getOutputIndexFromCoords(${t}(${e.join(", ")}));\n        setOutputAtIndexI32(flatIndex, value);\n      }\n    `}return a}(t.shape,t.dtype,s.isVec4));const p=e.map(((e,a)=>function(e,t,s,a){let i=function(e,t){const n=e.name,r=e.shape.length,s=sn(r),a="get"+n.charAt(0).toUpperCase()+n.slice(1),i=["d0","d1","d2","d3","d4","d5"].slice(0,r),o=i.map((e=>`${e} : i32`)).join(", ");if(r<1)return t?`\n        fn ${a}() -> vec4<f32> {\n          return vec4<f32>(${n}[0]);\n        }\n      `:`\n      fn ${a}() ->f32 {\n        return f32(${n}[0]);\n      }\n    `;const u=`uniforms.${n.charAt(0).toLowerCase()+n.slice(1)}Shape`;let l=`${r}D`;0===r&&(l="1D");if(t)return`\n      fn ${a}(${o}) -> vec4<f32> {\n        return vec4<f32>(${n}[getIndexFromCoords${l}(${s}(${i.join(",")}),\n          ${u}) / 4]);\n      }\n      `;return`\n    fn ${a}(${o}) -> f32 {\n      return f32(${n}[getIndexFromCoords${l}(${s}(${i.join(",")}),\n        ${u})]);\n    }\n   `}(e,s);e.shape.length<=t.length&&(i+=function(e,t,s,a){const i=e.name,o=i.charAt(0).toUpperCase()+i.slice(1),u="get"+o+"ByOutput",l=e.shape.length,h=t.length,d=sn(h);if(r.arraysEqual(e.shape,t)&&a)return s?`\n      fn ${u}Index(globalIndex : i32) -> vec4<f32> {\n        return vec4<f32>(${i}[globalIndex]);\n      }\n\n      fn ${u}Coords(coords : ${d}) -> vec4<f32> {\n        return vec4<f32>(${i}[${h>1?"getOutputIndexFromCoords(coords)":"coords"} / 4]);\n      }\n      `:`\n    fn ${u}Index(globalIndex : i32) -> f32 {\n      return f32(${i}[globalIndex]);\n    }\n\n    fn ${u}Coords(coords : ${d}) -> f32 {\n      return f32(${i}[${h>1?"getOutputIndexFromCoords(coords)":"coords"}]);\n    }\n    `;const p=n.getBroadcastDims(e.shape,t),c=h-l;let f="";if(0===l)return s?`\n    fn ${u}Index(globalIndex : i32) -> vec4<f32> {\n      return get${o}();\n    }\n\n    fn ${u}Coords(coords : ${d}) -> vec4<f32> {\n      return get${o}();\n    }\n  `:`\n    fn ${u}Index(globalIndex : i32) -> f32{\n      return get${o}();\n    }\n\n    fn ${u}Coords(coords : ${d}) -> f32{\n      return get${o}();\n    }\n  `;f=h<2&&p.length>=1?"coords = 0;":p.map((e=>`coords.${an(e+c)} = 0;`)).join("\n");let m="";if(h<2&&l>0)m="coords";else if(h>1){const t=sn(l),n=e.shape.map(((e,t)=>`coords.${an(t+c)}`)).join(", ");m=`${t}(${n})`}else m="coords";const g=`uniforms.${i.charAt(0).toLowerCase()+i.slice(1)}Shape`,b=`${l}D`;if(s)return`\n    fn ${u}Index(globalIndex : i32) -> vec4<f32> {\n      var coords = getCoordsFromIndex(globalIndex);\n      ${f}\n      return ${i}[getIndexFromCoords${b}(${m}, ${g}) / 4];\n    }\n\n    fn ${u}Coords(coordsIn : ${d}) -> vec4<f32> {\n      var coords = coordsIn;\n      ${f}\n      return ${i}[getIndexFromCoords${b}(${m}, ${g}) / 4];\n    }\n  `;return`\n  fn ${u}Index(globalIndex : i32) -> f32 {\n    var coords = getCoordsFromIndex(globalIndex);\n    ${f}\n    return f32(${i}[getIndexFromCoords${b}(${m}, ${g})]);\n  }\n\n  fn ${u}Coords(coordsIn : ${d}) -> f32 {\n    var coords = coordsIn;\n    ${f}\n    return f32(${i}[getIndexFromCoords${b}(${m}, ${g})]);\n  }\n`}(e,t,s,a));return i}(e,t.shape,s.variableTypes?"vec4<f32>"===s.variableTypes[a]:s.isVec4,s.dispatchLayout.x.length===t.shape.length))).join("\n");d.push(p),d.push(s.getUserCode());const c=mn(s);d.push(un(c,s));return d.join("\n")}(s,{dtype:a.dtype,shape:a.shape},t),o=e.createShaderModule({code:i,label:t.constructor.name});return e.createComputePipeline({compute:{module:o,entryPoint:"_start"},label:t.constructor.name,layout:"auto"})};function sn(e){if(e<=1)return"i32";if(2===e)return"vec2<i32>";if(3===e)return"vec3<i32>";if(4===e)return"vec4<i32>";if(5===e)return"vec5";if(6===e)return"vec6";throw Error(`GPU for rank ${e} is not yet supported`)}function an(e){if(0===e)return"x";if(1===e)return"y";if(2===e)return"z";if(3===e)return"w";if(4===e)return"u";if(5===e)return"v";throw Error(`Index ${e} is not yet supported`)}function on(...e){let t;switch(e.length){case 0:t="\n        fn main()\n      ";break;case 1:t=`\n        fn main(${e[0]} : i32)\n      `;break;default:throw Error("Unreachable")}return t}function un(e,t){let n;return n=`\n     ${function(e){return`\n  @compute @workgroup_size(${e.workgroupSize[0]}, ${e.workgroupSize[1]}, ${e.workgroupSize[2]})\n`}(t)}\n      fn _start(@builtin(local_invocation_id) LocalId : vec3<u32>,\n                @builtin(global_invocation_id) GlobalId : vec3<u32>,\n                @builtin(local_invocation_index) LocalIndex: u32,\n                @builtin(workgroup_id) WorkgroupId : vec3<u32>,\n                @builtin(num_workgroups) NumWorkgroups : vec3<u32>) {\n        localId = LocalId;\n        localIndex = LocalIndex;\n        globalId = GlobalId;\n        numWorkgroups = NumWorkgroups;\n        workgroupId = WorkgroupId;\n        ${e?"main(getGlobalIndex());":"main();"};\n      }\n    `,n}const ln="\n  struct vec5 {x: i32, y: i32, z: i32, w: i32, u: i32};\n  struct vec6 {x: i32, y: i32, z: i32, w: i32, u: i32, v: i32};\n\n  // Checks whether coordinates lie within the bounds of the shape.\n  fn coordsInBounds2D(coord : vec2<i32>, shape : vec2<i32>) -> bool {\n    return all(coord >= vec2<i32>(0)) && all(coord < shape);\n  }\n  fn coordsInBounds3D(coord : vec3<i32>, shape : vec3<i32>) -> bool {\n    return all(coord >= vec3<i32>(0)) && all(coord < shape);\n  }\n  fn coordsInBounds4D(coord : vec4<i32>, shape : vec4<i32>) -> bool {\n    return all(coord >= vec4<i32>(0)) && all(coord < shape);\n  }\n\n  fn getIndexFromCoords1D(coord : i32, shape : i32) -> i32 {\n    return coord;\n  }\n  fn getIndexFromCoords2D(coords : vec2<i32>, shape : vec2<i32>) -> i32 {\n    return dot(coords, vec2<i32>(shape.y, 1));\n  }\n  fn getIndexFromCoords3D(coords : vec3<i32>, shape : vec3<i32>) -> i32 {\n    return dot(coords, vec3<i32>(shape.y * shape.z, shape.z, 1));\n  }\n  fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {\n    return dot(coords, vec4<i32>(\n        shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));\n  }\n  fn getIndexFromCoords5D(coords : vec5, shape : vec5) -> i32 {\n    let shapeStrides: vec5 = vec5(shape.y * shape.z * shape.w * shape.u, shape.z * shape.w * shape.u, shape.w * shape.u, shape.u, 1);\n    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u;\n  }\n  fn getIndexFromCoords6D(coords : vec6, shape : vec6) -> i32 {\n    let shapeStrides: vec6 = vec6(shape.y * shape.z * shape.w * shape.u * shape.v, shape.z * shape.w * shape.u * shape.v, shape.w * shape.u * shape.v, shape.u * shape.v, shape.v, 1);\n    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u + coords.v*shapeStrides.v;\n  }\n\n  fn idiv(a: i32, b: i32, sign: f32) -> i32 {\n    var res: i32 = a / b;\n    let modulo: i32 = a % b;\n    if (sign < 0. && modulo != 0) {\n      res = res - 1;\n    }\n    return res;\n  }\n\n  // NaN defination in IEEE 754-1985 is :\n  //   - sign = either 0 or 1.\n  //   - biased exponent = all 1 bits.\n  //   - fraction = anything except all 0 bits (since all 0 bits represents infinity).\n  // https://en.wikipedia.org/wiki/IEEE_754-1985#Representation_of_non-numbers\n  fn isnan(val: f32) -> bool {\n    let floatToUint: u32 = bitcast<u32>(val);\n    return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n  }\n  fn isnanVec4(val : vec4<f32>) -> vec4<bool> {\n    let floatToUint: vec4<u32> = bitcast<vec4<u32>>(val);\n    return (floatToUint & vec4<u32>(0x7fffffffu)) > vec4<u32>(0x7f800000u);\n  }\n",hn="\n  fn isinf(val: f32) -> bool {\n    return abs(val) == uniforms.INFINITY;\n  }\n";function dn(e){const t=e.length;if(t<=1)return"fn getCoordsFromIndex(index : i32) -> i32 { return index; }";const n=r.computeStrides(e),s=sn(t),a=[];for(let e=0;e<t;e++)a.push(`d${e}`);if(1===n.length)return"    fn getCoordsFromIndex(index : i32) -> vec2<i32> {\n      let d0 = index / uniforms.outShapeStrides; let d1 = index - d0 * uniforms.outShapeStrides;\n      return vec2<i32>(d0, d1);\n    }";let i;return i="var index2 = index;"+n.map(((e,t)=>`${`let ${a[t]} = index2 / uniforms.outShapeStrides.${an(t)}`}; ${t===n.length-1?`let ${a[t+1]} = index2 - ${a[t]} * uniforms.outShapeStrides.${an(t)}`:`index2 = index2 - ${a[t]} * uniforms.outShapeStrides.${an(t)}`};`)).join(""),`\n    fn getCoordsFromIndex(index : i32) -> ${s} {\n      ${i}\n      return ${s}(${a.join(",")});\n    }\n  `}function pn(e){let t="";switch(e){case 0:case 1:t+="\n        fn getOutputIndexFromCoords(coords : i32) -> i32 {\n          return coords;\n        }\n        ";break;case 2:t+="\n        fn getOutputIndexFromCoords(coords : vec2<i32>) -> i32 {\n          return dot(coords, vec2<i32>(uniforms.outShapeStrides, 1));\n        }\n        ";break;case 3:t+="\n        fn getOutputIndexFromCoords(coords : vec3<i32>) -> i32 {\n          return dot(coords, vec3<i32>(uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, 1));\n        }\n        ";break;case 4:t+="\n        fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {\n          return dot(coords, vec4<i32>(\n            uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, uniforms.outShapeStrides.z, 1));\n        }\n        ";break;case 5:t+="\n        fn getOutputIndexFromCoords(coords : vec5) -> i32 {\n          return coords.x * uniforms.outShapeStrides.x +\n              coords.y * uniforms.outShapeStrides.y +\n              coords.z * uniforms.outShapeStrides.z +\n              coords.w * uniforms.outShapeStrides.w +\n              coords.u;\n        }\n        ";break;case 6:t+="\n        fn getOutputIndexFromCoords(coords : vec6) -> i32 {\n          return coords.x * uniforms.outShapeStrides.x +\n              coords.y * uniforms.outShapeStrides.y +\n              coords.z * uniforms.outShapeStrides.z +\n              coords.w * uniforms.outShapeStrides.w +\n              coords.u * uniforms.outShapeStrides.u +\n              coords.v;\n        }\n        ";break;default:r.assert(!1,(()=>`Unsupported ${e}D shape`))}return t}function cn(e){return 1===e.dispatch[1]&&1===e.dispatch[2]}function fn(e,t){return"float32"===e?t?"vec4<f32>":"f32":"int32"===e||"bool"===e?t?"vec4<i32>":"i32":e}function mn(e){return(!e.dispatchLayout.hasOwnProperty("y")||0===e.dispatchLayout.y.length)&&(!e.dispatchLayout.hasOwnProperty("z")||0===e.dispatchLayout.z.length)}const gn=e=>{let t=1;for(let n=0;n<e.length;n++)t*=e[n];return t};function bn(e,t,n=[1,1,1],r=[1,1,1]){const[s,a,i]=[Math.ceil(gn(e.x.map((e=>t[e])))/(n[0]*r[0])),e.y?Math.ceil(gn(e.y.map((e=>t[e])))/(n[1]*r[1])):1,e.z?Math.ceil(gn(e.z.map((e=>t[e])))/(n[2]*r[2])):1];return[s,a,i]}function xn(e,t,n,r=!1){const s=[8,8,1],a=[4,4,1];return r||(e<=8&&(a[1]=1),t<=16&&n<=16&&(s[0]=4)),{workgroupSize:s,elementsPerThread:a}}function wn(e,t,n=!1){if(n)return[8,8,1];const r=gn(e.x.map((e=>t[e]))),s=gn(e.y.map((e=>t[e])));return r<=4?[4,16,1]:s<=4?[16,4,1]:[16,16,1]}function yn(e,t,n=!1){if(n)return[4,4,1];const r=gn(e.x.map((e=>t[e]))),s=gn(e.y.map((e=>t[e])));return r<=4?[1,2,1]:s<=4?[2,1,1]:[2,2,1]}function In(e){return{x:e.map(((e,t)=>t))}}function Sn(e){if("float32"===e||"int32"===e||"bool"===e||"string"===e)return 4;if("complex64"===e)return 8;throw new Error(`Unknown dtype ${e}`)}function kn(){return("undefined"!=typeof window||"undefined"!=typeof WorkerGlobalScope)&&!!navigator.gpu}function vn(e,t){Array.isArray(e)||(e=[e]),e.forEach((e=>{null!=e&&r.assert("complex64"!==e.dtype,(()=>`${t} does not support complex64 tensors in the WebGPU backend.`))}))}var Cn;!function(e){e[e.MatMulReduceProgram=0]="MatMulReduceProgram",e[e.MatMulSplitKProgram=1]="MatMulSplitKProgram",e[e.MatMulSmallOutputSizeProgram=2]="MatMulSmallOutputSizeProgram",e[e.MatMulPackedProgram=3]="MatMulPackedProgram",e[e.MatMulMax=4]="MatMulMax"}(Cn||(Cn={}));var $n={__proto__:null,tilesFitEvenlyIntoShape:function(e,t){if(e.length!==t.length)throw new Error(`Cannot compute whether rank ${e.length} tiles fit evenly into rank ${t.length} shape - ranks must match.`);return t.every(((t,n)=>t%e[n]==0))},computeDispatch:bn,computeWorkgroupInfoForMatMul:xn,computeWorkgroupSizeForConv2d:wn,computeWorkPerThreadForConv2d:yn,flatDispatchLayout:In,GPUBytesPerElement:Sn,isWebGPUSupported:kn,assertNotComplex:vn,get MatMulProgramType(){return Cn}};const Rn=t().getNumber("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD");class An extends s{constructor(e,n){if(super(),this.commandQueueOwnedIds=new WeakSet,this.dispatchNumberInEncoder=0,this.disposed=!1,this.downloadWaitMs=0,this.tensorDataPendingDisposal=[],this.stagingPendingDisposal=[],this.uniformPendingDisposal=[],this.uploadWaitMs=0,!kn())throw new Error("WebGPU is not supported on this device");this.pipelineCache={},this.device=e,this.queue=e.queue,this.currentCommandEncoder=null,this.currentComputePass=null,this.supportTimeQuery=e.features.has("timestamp-query-inside-passes"),this.adapterInfo=new jt(n),this.thresholdToIncreaseWorkgroups=this.adapterInfo.intelGPUGeneration>=12?16:8,this.bufferManager=new Yt(this.device),this.textureManager=new Zt(this.device),this.tensorMap=new a(this,i()),this.supportTimeQuery&&(this.querySet=this.device.createQuerySet({type:"timestamp",count:2})),t().getBool("WEBGPU_USE_PROFILE_TOOL")&&(this.dummyCanvas=document.createElement("canvas"),this.dummyCanvas.width=1,this.dummyCanvas.height=1,this.dummyContext=this.dummyCanvas.getContext("webgpu"),this.dummyContext.configure({device:e,format:"bgra8unorm"}),document.body.appendChild(this.dummyCanvas))}nextDataId(){return An.nextDataId++}floatPrecision(){return 32}defaultGpuBufferUsage(){return GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST}disposeData(e,t=!1){if(this.tensorDataPendingDisposal.indexOf(e)>=0)return!1;if(!this.tensorMap.has(e))return!0;const n=this.tensorMap.get(e);if(this.decRef(e),!t&&n.refCount>0)return!1;if(this.commandQueueOwnedIds.has(e))return this.tensorDataPendingDisposal.push(e),!1;const{complexTensorInfos:r}=this.tensorMap.get(e);return null!=r&&(this.disposeData(r.real.dataId,t),this.disposeData(r.imag.dataId,t)),this.releaseResource(e),this.tensorMap.delete(e),!0}memory(){return{numBytesInGPU:this.bufferManager.numBytesUsed,numBytesAllocatedInGPU:this.bufferManager.numBytesAllocated,unreliable:!1}}releaseResource(e){const t=this.tensorMap.get(e);if(t&&t.resourceInfo)if(t.external)t.resourceInfo=null;else{if("texture"in t.resourceInfo){const e=t.resourceInfo;e.texture instanceof GPUTexture&&this.textureManager.releaseTexture(e.texture,e.width,e.height,e.format,e.usage),e.texture=null}else{const e=t.resourceInfo;this.bufferManager.releaseBuffer(e.buffer,e.size,e.usage),e.buffer=null}t.resourceInfo=null}}refCount(e){if(this.tensorMap.has(e)){return this.tensorMap.get(e).refCount}return 0}incRef(e){this.tensorMap.get(e).refCount++}decRef(e){if(this.tensorMap.has(e)){this.tensorMap.get(e).refCount--}}write(e,t,n){if("complex64"===n&&null!=e)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const r={id:this.nextDataId()};return this.tensorMap.set(r,{dtype:n,shape:t,values:e,refCount:1}),r}move(e,t,n,r,s){if("complex64"===r)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.tensorMap.set(e,{dtype:r,shape:n,values:t,refCount:s})}submitQueue(){this.ensureComputePassEnded(),this.queue.submit([this.currentCommandEncoder.finish()]),this.currentCommandEncoder=null,this.dispatchNumberInEncoder=0,this.commandQueueOwnedIds=new WeakSet,this.tensorDataPendingDisposal.forEach((e=>{this.releaseResource(e),this.tensorMap.delete(e)})),this.uniformPendingDisposal.forEach((e=>this.bufferManager.releaseBuffer(e.buffer,e.size,e.usage))),this.stagingPendingDisposal.forEach((e=>this.bufferManager.releaseUploadBuffer(e.buffer,e.size,e.usage))),this.tensorDataPendingDisposal=[],this.uniformPendingDisposal=[],this.stagingPendingDisposal=[]}ensureCommandEncoderReady(){this.currentCommandEncoder||(this.currentCommandEncoder=this.device.createCommandEncoder())}ensureComputePassEnded(){this.currentComputePass&&(this.currentComputePass.end(),this.currentComputePass=null)}getComputePass(){return this.currentComputePass||(this.currentComputePass=this.currentCommandEncoder.beginComputePass()),this.currentComputePass}async getBufferData(e,n){const s=this.bufferManager.acquireBuffer(n,GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ);this.ensureCommandEncoderReady(),this.ensureComputePassEnded(),this.currentCommandEncoder.copyBufferToBuffer(e,0,s,0,n),this.submitQueue(),await s.mapAsync(GPUMapMode.READ);const a=s.getMappedRange().slice(0);return s.unmap(),null!=s&&this.bufferManager.releaseBuffer(s,n,GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ),t().getBool("WEBGPU_USE_PROFILE_TOOL")&&(r.assert(void 0!==this.dummyContext,(()=>"Fail to get context for profiling tool")),this.dummyContext.getCurrentTexture()),a}convertAndCacheOnCPU(e,t){const n=this.tensorMap.get(e);return this.releaseResource(e),n.values=t,n.values}readSync(e){const t=this.tensorMap.get(e),{values:n}=t;if(null==n)throw new Error("WebGPU readSync is only available for CPU-resident tensors.");return n}async read(e){if(!this.tensorMap.has(e))throw new Error(`Tensor ${e} was not registered!`);const t=this.tensorMap.get(e),{values:s}=t;if(null!=s)return this.convertAndCacheOnCPU(e,s);let a;if("complex64"===t.dtype){const e=await Promise.all([this.read(t.complexTensorInfos.real.dataId),this.read(t.complexTensorInfos.imag.dataId)]),r=e[0],s=e[1];a=n.mergeRealAndImagArrays(r,s)}else{const e=t.resourceInfo,n=await this.getBufferData(e.buffer,e.size);a=r.convertBackendValuesAndArrayBuffer(n,t.dtype)}return this.convertAndCacheOnCPU(e,a),a}copyBuffer(e,t,n){const r=this.bufferManager.acquireBuffer(t,n);return this.ensureCommandEncoderReady(),this.ensureComputePassEnded(),this.currentCommandEncoder.copyBufferToBuffer(e,0,r,0,t),this.submitQueue(),r}createTensorFromGPUData(e,t,n){let s=e.buffer;if("complex64"===n)throw new Error("Cannot write to a complex64 dtype. ");const a={id:this.nextDataId()};this.tensorMap.set(a,{dtype:n,shape:t,values:null,refCount:1,external:e.zeroCopy});const o=this.tensorMap.get(a),u=Sn(o.dtype)*r.sizeFromShape(o.shape);if(e.buffer.size<u)throw new Error(`GPUBuffer size(${e.buffer.size}) is smaller than tensor size(${u})!`);if((e.buffer.usage&(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC))!=(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC))throw new Error("GPUBuffer.usage should include GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC!");return!0!==e.zeroCopy&&(s=this.copyBuffer(s,u,s.usage)),o.resourceInfo={size:s.size,usage:s.usage,buffer:s},i().makeTensorFromDataId(a,t,n,this)}readToGPU(e){const t=this.tensorMap.get(e),{values:n,dtype:r,shape:s,resourceInfo:a}=t;if("complex64"===r)throw new Error("Does not support reading buffer for complex64 dtype.");if(null==a)throw null!=n?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const o=a.size,u=this.bufferManager.acquireBuffer(o,a.usage);this.ensureCommandEncoderReady(),this.ensureComputePassEnded(),this.currentCommandEncoder.copyBufferToBuffer(a.buffer,0,u,0,o),this.submitQueue();const l=this.makeTensorInfo(s,r),h=i().makeTensorFromTensorInfo(l);return this.tensorMap.get(l.dataId).resourceInfo={size:o,usage:this.defaultGpuBufferUsage(),buffer:u},{tensorRef:h,buffer:u,bufSize:o}}bufferSync(e){const t=this.readSync(e.dataId);if("string"===e.dtype)try{const n=t.map((e=>r.decodeString(e)));return o(e.shape,e.dtype,n)}catch(e){throw new Error("Failed to decode encoded string bytes into utf-8")}return o(e.shape,e.dtype,t)}async time(e){this.supportTimeQuery||console.warn("This device doesn't support timestamp-query-inside-passes extension. Start Chrome browser with flag --disable-dawn-features=disallow_unsafe_apis then try again. Otherwise, zero will be shown for the kernel time when profiling mode is enabled. Using performance.now is not workable for webgpu since it doesn't support synchronous data read from GPU.");const t=this.activeTimers,n=[];let s=!1;null==this.programTimersStack?(this.programTimersStack=n,s=!0):this.activeTimers.push(n),this.activeTimers=n,e();const a=r.flatten(this.activeTimers.map((e=>e.query))).filter((e=>null!=e)),i=r.flatten(this.activeTimers.map((e=>e.name))).filter((e=>null!=e));this.activeTimers=t,s&&(this.programTimersStack=null);const o={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null},u=await Promise.all(a);return o.kernelMs=r.sum(u),o.getExtraProfileInfo=()=>u.map(((e,t)=>({name:i[t],ms:e}))).map((e=>`${e.name}: ${e.ms}`)).join(", "),this.uploadWaitMs=0,this.downloadWaitMs=0,o}makeTensorInfo(e,t,n){"string"===t&&null!=n&&n.length>0&&r.isString(n[0])&&(n=n.map((e=>r.encodeString(e))));return{dataId:this.write(n,e,t),shape:e,dtype:t}}tensorToBinding(e){if(!e)return null;const t=this.tensorMap.get(e.dataId);if("texture"in t.resourceInfo){const e=t.resourceInfo;return e.texture instanceof GPUExternalTexture?e.texture:e.texture.createView()}const n=t.resourceInfo;return{offset:0,size:n.size,buffer:n.buffer}}async getQueryTime(e){return this.supportTimeQuery?this.getTimeFromQuerySet(e):0}uploadToGPU(e){const t=this.tensorMap.get(e);if(t.resourceInfo)return;const n=Sn(t.dtype)*r.sizeFromShape(t.shape),s=this.bufferManager.acquireBuffer(n,this.defaultGpuBufferUsage());if(t.resourceInfo={size:n,usage:this.defaultGpuBufferUsage(),buffer:s},t.values){const e=this.bufferManager.acquireUploadBuffer(n,GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC),r=e.getMappedRange();"int32"===t.dtype||"bool"===t.dtype?new Int32Array(r).set(t.values):new Float32Array(r).set(t.values),e.unmap(),this.ensureCommandEncoderReady(),this.ensureComputePassEnded(),this.currentCommandEncoder.copyBufferToBuffer(e,0,s,0,n);const a={size:n,usage:GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC,buffer:e};this.stagingPendingDisposal.push(a)}}makeUniforms(e){let t=0,n=0;const s=[];let a=1;e.forEach((e=>{let i;switch(0===e.data.length&&(e.data=[1]),e.data.length){case 1:i=4;break;case 2:i=8;break;case 3:case 4:case 5:case 6:i=16;break;default:r.assert(!1,(()=>`Unsupported ${e.data.length}D shape`))}5!==n&&6!==n||(i=16),i>a&&(a=i),t=Math.ceil(t/i)*i,n=e.data.length,s.push(t),t+=4*e.data.length})),t=Math.ceil(t/a)*a;const i=new ArrayBuffer(t);e.forEach(((e,t)=>{const n=s[t];"int32"===e.type?new Int32Array(i,n,e.data.length).set(e.data):"uint32"===e.type?new Uint32Array(i,n,e.data.length).set(e.data):new Float32Array(i,n,e.data.length).set(e.data)}));const o=this.bufferManager.acquireBuffer(t,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);this.queue.writeBuffer(o,0,i,0,t);const u={size:t,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM,buffer:o};return this.uniformPendingDisposal.push(u),{offset:0,size:t,buffer:o}}runWebGPUProgram(e,s,a,i,o){if(o||(o=this.makeTensorInfo(e.outputShape,a)),0===r.sizeFromShape(o.shape))return this.tensorMap.get(o.dataId).values=r.getTypedArrayFromDType(o.dtype,0),o;this.uploadToGPU(o.dataId),e.dispatch=((e,t)=>{const n=e.limits.maxComputeWorkgroupsPerDimension,s=t.dispatchLayout,a=t.dispatch;if(a.every((e=>e<=n)))return a;r.assert(a[0]>n&&void 0===s.y&&void 0===s.z,(()=>"Dispatch size exceeds WebGPU limits in Y or Z dimension."));let i=Math.ceil(Math.sqrt(a[0]));return i>n?(i=Math.ceil(Math.cbrt(a[0])),r.assert(i<=n,(()=>"Total dispatch size exceeds WebGPU maximum.")),[i,i,i]):[i,i,1]})(this.device,e);let u=[],l=[];if(!e.isFromPixels){u.push({type:"float32",data:[NaN]},{type:"float32",data:[1/0]}),l=s.concat(o).map((e=>e.shape));const t="int32";l.map((e=>{u.push({type:t,data:e})}));const n=r.computeStrides(o.shape);if(u.push({type:t,data:n}),e.size){const n=r.sizeFromShape(e.outputShape);u.push({type:t,data:[e.isVec4?n/4:n]})}}const h=s.map(((t,n)=>{if("complex64"===t.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");return this.uploadToGPU(t.dataId),{dtype:this.tensorMap.get(t.dataId).dtype,shape:t.shape,name:e.variableNames[n]}})),d=function(e,t,s,a){let i=e.shaderKey;if(e.isFromPixels)return i;const o=s.map((e=>e.dtype)).concat(a.dtype),u=s.map((e=>n.getBroadcastDims(e.shape,a.shape))),l=s.map((e=>r.arraysEqual(e.shape,a.shape))).join("_"),h=u.map((e=>e.join("_"))).join(";"),d=cn(e)?"flatDispatch":"";return i+="_"+(e.workgroupSize?e.workgroupSize.join(","):"")+t.map((e=>e.length)).join(",")+o.join(",")+e.variableNames.join(",")+h+l+d,i}(e,l,h,o);let p;d in this.pipelineCache?p=this.pipelineCache[d]:(p=rn(this.device,e,h,o),this.pipelineCache[d]=p),i&&(u=[...u,...i]);const c=[this.tensorToBinding(o),...s.map((e=>this.tensorToBinding(e))),this.makeUniforms(u)],f=this.device.createBindGroup({layout:p.getBindGroupLayout(0),entries:c.map(((e,t)=>({binding:t,resource:e})))});this.ensureCommandEncoderReady();const m=this.getComputePass(),g=null!=this.activeTimers;return g&&this.supportTimeQuery&&m.writeTimestamp(this.querySet,0),m.setPipeline(p),m.setBindGroup(0,f),m.dispatchWorkgroups(e.dispatch[0],e.dispatch[1],e.dispatch[2]),g&&this.supportTimeQuery&&m.writeTimestamp(this.querySet,1),this.dispatchNumberInEncoder++,s.forEach((e=>{this.commandQueueOwnedIds.add(e.dataId)})),this.commandQueueOwnedIds.add(o.dataId),t().get("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE")<=this.dispatchNumberInEncoder&&this.submitQueue(),g&&this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(this.querySet)}),o}async getTimeFromQuerySet(e){const t=this.bufferManager.acquireBuffer(16,GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE),n=this.bufferManager.acquireBuffer(16,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);this.ensureCommandEncoderReady(),this.ensureComputePassEnded(),this.currentCommandEncoder.resolveQuerySet(e,0,2,t,0),this.currentCommandEncoder.copyBufferToBuffer(t,0,n,0,16),this.submitQueue(),await n.mapAsync(GPUMapMode.READ);const r=new BigUint64Array(n.getMappedRange()),s=Number(r[1]-r[0]);return n.unmap(),this.bufferManager.releaseBuffer(n,16,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST),this.bufferManager.releaseBuffer(t,16,GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE),s/1e6}shouldExecuteOnCPU(e,n=Rn){return t().getBool("WEBGPU_CPU_FORWARD")&&e.every((e=>null==this.tensorMap.get(e.dataId).resourceInfo&&r.sizeFromShape(e.shape)<n))}numDataIds(){return this.tensorMap.numDataIds()-this.tensorDataPendingDisposal.length}dispose(){this.disposed||(this.bufferManager.dispose(),this.textureManager.dispose(),this.disposed=!0)}}var Tn;An.nextDataId=0,kn()&&u("webgpu",(async()=>{t().set("CHECK_COMPUTATION_FOR_ERRORS",!1);const e={powerPreference:t().get("WEBGPU_USE_LOW_POWER_GPU")?"low-power":"high-performance"},n=await navigator.gpu.requestAdapter(e),r={};n.features.has("timestamp-query-inside-passes")&&(r.requiredFeatures=["timestamp-query-inside-passes"]);const s=n.limits;r.requiredLimits={maxComputeWorkgroupStorageSize:s.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:s.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:s.maxStorageBufferBindingSize};const a=await n.requestDevice(r),i=await n.requestAdapterInfo();return new An(a,i)}),3),function(e){e[e.ADD=0]="ADD",e[e.ATAN2=1]="ATAN2",e[e.COMPLEX_MULTIPLY_IMAG=2]="COMPLEX_MULTIPLY_IMAG",e[e.COMPLEX_MULTIPLY_REAL=3]="COMPLEX_MULTIPLY_REAL",e[e.DIV=4]="DIV",e[e.EQUAL=5]="EQUAL",e[e.GREATER=6]="GREATER",e[e.GREATER_EQUAL=7]="GREATER_EQUAL",e[e.INT_DIV=8]="INT_DIV",e[e.LESS=9]="LESS",e[e.LESS_EQUAL=10]="LESS_EQUAL",e[e.LOGICAL_AND=11]="LOGICAL_AND",e[e.LOGICAL_OR=12]="LOGICAL_OR",e[e.MAX=13]="MAX",e[e.MIN=14]="MIN",e[e.MOD=15]="MOD",e[e.MUL=16]="MUL",e[e.NOT_EQUAL=17]="NOT_EQUAL",e[e.POW=18]="POW",e[e.PRELU=19]="PRELU",e[e.SQUARED_DIFFERENCE=20]="SQUARED_DIFFERENCE",e[e.SUB=21]="SUB"}(Tn||(Tn={}));const Pn="\n  if (isnan(a)) { return a; }\n  if (isnan(b)) { return b; }\n  ",Nn="\n  resultTemp = select(\n      resultTemp, vec4<f32>(valueForNaN),\n      vec4<bool>(isNaN) | isnanVec4(a) | isnanVec4(b));\n  ",zn=`\n  ${Pn}\n  if (b == 0.) {\n    return uniforms.NAN;\n  }\n  var resultTemp = a % b;\n  if ((a < 0. && b < 0.) || (a >= 0. && b > 0.)) {\n    return resultTemp;\n  } else {\n    return (resultTemp + b) % b;\n  }\n`,En=`\n  let isNaN = !vec4<bool>(b);\n  let valueForNaN = uniforms.NAN;\n  var resultTemp = vec4<f32>(a % b);\n  ${Nn}\n\n  if (!((a[0] < 0. && b[0] < 0.) || (a[0] >= 0. && b[0] > 0.))) {\n    resultTemp[0] = (resultTemp[0] + b[0]) % b[0];\n  }\n  if (!((a[1] < 0. && b[1] < 0.) || (a[1] >= 0. && b[1] > 0.))) {\n    resultTemp[1] = (resultTemp[1] + b[1]) % b[1];\n  }\n  if (!((a[2] < 0. && b[2] < 0.) || (a[2] >= 0. && b[2] > 0.))) {\n    resultTemp[2] = (resultTemp[2] + b[2]) % b[2];\n  }\n  if (!((a[3] < 0. && b[3] < 0.) || (a[3] >= 0. && b[3] > 0.))) {\n    resultTemp[3] = (resultTemp[3] + b[3]) % b[3];\n  }\n\n  return resultTemp;\n`,Fn=`\n  var resultTemp = vec4<f32>(a != b);\n  let valueForNaN = 1.0;\n  ${Nn}\n\n  return resultTemp;\n`,Bn=`\n  let isModRound1Bool = vec4<i32>(round(abs(b) % vec4<f32>(2.0))) == vec4<i32>(1);\n  let isModRound1 = vec4<f32>(isModRound1Bool);\n  let multiplier = sign(a) * isModRound1 + (vec4<f32>(1.0) - isModRound1);\n  var resultTemp = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  let isExpZero = b == vec4<f32>(0.0);\n  if (isExpZero.r) {\n    resultTemp.r = 1.0;\n  }\n  if (isExpZero.g) {\n    resultTemp.g = 1.0;\n  }\n  if (isExpZero.b) {\n    resultTemp.b = 1.0;\n  }\n  if (isExpZero.a) {\n    resultTemp.a = 1.0;\n  }\n  let isNaN = (a < vec4<f32>(0.0)) & (floor(b) < b);\n  let valueForNaN = uniforms.NAN;\n  ${Nn}\n  return resultTemp;\n`;function _n(e,t,n="uniforms.NAN"){const r=t?Nn:Pn;return t?`\n    let valueForNaN = ${n};\n    var resultTemp = vec4<f32>(${e}(a, b));\n    `+r+"\n    return resultTemp;\n  ":r+`\n    return ${e}(a, b);\n  `}function On(e,t){switch(e){case Tn.ADD:return"return a + b;";case Tn.ATAN2:return _n("atan2",t);case Tn.COMPLEX_MULTIPLY_IMAG:return"return areal * bimag + aimag * breal;";case Tn.COMPLEX_MULTIPLY_REAL:return"return areal * breal - aimag * bimag;";case Tn.DIV:return"return a / b;";case Tn.EQUAL:return t?"return vec4<f32>(a == b);":"return f32(a == b);";case Tn.GREATER:return t?"return vec4<f32>(a > b);":"return f32(a > b);";case Tn.GREATER_EQUAL:return t?"return vec4<f32>(a >= b);":"return f32(a >= b);";case Tn.INT_DIV:return t?"\n  let ia = vec4<i32>(round(a));\n  let ib = vec4<i32>(round(b));\n  let cond = ib != vec4<i32>(0);\n  var resultTemp = vec4<i32>(0);\n  let s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    resultTemp[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    resultTemp[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    resultTemp[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    resultTemp[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4<f32>(resultTemp);\n":"\n  let s = sign(a) * sign(b);\n  let ia = i32(round(a));\n  let ib = i32(round(b));\n  return f32(idiv(ia, ib, s));\n";case Tn.LESS:return t?"return vec4<f32>(a < b);":"return f32(a < b);";case Tn.LESS_EQUAL:return t?"return vec4<f32>(a <= b);":"return f32(a <= b);";case Tn.LOGICAL_AND:return t?"return (vec4<f32>(a >= vec4<f32>(1.0)) *\n  vec4<f32>(b >= vec4<f32>(1.0)));":"return f32(a >= 1.0 && b >= 1.0);";case Tn.LOGICAL_OR:return t?"return min(vec4<f32>(a >= vec4<f32>(1.0)) +\n  vec4<f32>(b >= vec4<f32>(1.0)), vec4<f32>(1.0));":"return f32(a >= 1.0 || b >= 1.0);";case Tn.MAX:return _n("max",t);case Tn.MIN:return _n("min",t);case Tn.MOD:return t?En:zn;case Tn.MUL:return"return a * b;";case Tn.NOT_EQUAL:return t?Fn:"\n  if (isnan(a) || isnan(b)) {\n    return 1.0;\n  }\n  return f32(a != b);\n";case Tn.POW:return t?Bn:"\n  if(a < 0.0 && floor(b) < b) {\n    return uniforms.NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  if (round(abs(b) % 2.0) != 1.0) {\n    return pow(abs(a), b);\n  }\n  return sign(a) * pow(abs(a), b);\n";case Tn.PRELU:return t?"\n  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));\n  return (aLessThanZero * (b * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);\n":"if (a < 0.0) { return b * a; }  return a;";case Tn.SQUARED_DIFFERENCE:return"return (a - b) * (a - b);";case Tn.SUB:return"return a - b;";default:throw new Error(`BinaryType ${e} is not implemented!`)}}var Ln;!function(e){e[e.ABS=0]="ABS",e[e.ACOS=1]="ACOS",e[e.ACOSH=2]="ACOSH",e[e.ASIN=3]="ASIN",e[e.ASINH=4]="ASINH",e[e.ATAN=5]="ATAN",e[e.ATANH=6]="ATANH",e[e.CEIL=7]="CEIL",e[e.COS=8]="COS",e[e.COSH=9]="COSH",e[e.ELU=10]="ELU",e[e.ERF=11]="ERF",e[e.EXP=12]="EXP",e[e.EXPM1=13]="EXPM1",e[e.FLOOR=14]="FLOOR",e[e.IS_FINITE=15]="IS_FINITE",e[e.IS_INF=16]="IS_INF",e[e.IS_NAN=17]="IS_NAN",e[e.LINEAR=18]="LINEAR",e[e.LOG=19]="LOG",e[e.LOG1P=20]="LOG1P",e[e.LOGICAL_NOT=21]="LOGICAL_NOT",e[e.NEG=22]="NEG",e[e.RELU=23]="RELU",e[e.RELU6=24]="RELU6",e[e.LEAKYRELU=25]="LEAKYRELU",e[e.RECIPROCAL=26]="RECIPROCAL",e[e.ROUND=27]="ROUND",e[e.RSQRT=28]="RSQRT",e[e.SELU=29]="SELU",e[e.SIGMOID=30]="SIGMOID",e[e.SIGN=31]="SIGN",e[e.SIN=32]="SIN",e[e.SINH=33]="SINH",e[e.SOFTPLUS=34]="SOFTPLUS",e[e.SQRT=35]="SQRT",e[e.SQUARE=36]="SQUARE",e[e.STEP=37]="STEP",e[e.TAN=38]="TAN",e[e.TANH=39]="TANH",e[e.TO_INT=40]="TO_INT"}(Ln||(Ln={}));const Un=`\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  let p = ${n.ERF_P};\n  let a1 = ${n.ERF_A1};\n  let a2 = ${n.ERF_A2};\n  let a3 = ${n.ERF_A3};\n  let a4 = ${n.ERF_A4};\n  let a5 = ${n.ERF_A5};\n\n  let sign = sign(a);\n  let absA = abs(a);\n  let t = 1.0 / (1.0 + p * absA);\n  return sign * (1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * exp(-absA * absA));\n`,Dn=`\n  if (a >= 0.0) {\n    return ${n.SELU_SCALE} * a;\n  } else {\n    return ${n.SELU_SCALEALPHA} * (exp(a) - 1.0);\n  }\n`;function Wn(e,t){switch(e){case Ln.ABS:return"return abs(a);";case Ln.ACOS:return"\n  if (abs(a) > 1.) {\n    return uniforms.NAN;\n  }\n  return acos(a);\n";case Ln.ACOSH:return"\n  if (a < 1.) {\n    return uniforms.NAN;\n  }\n  return acosh(a);\n";case Ln.ASIN:return"\n  if (abs(a) > 1.) {\n    return uniforms.NAN;\n  }\n  return asin(a);\n";case Ln.ASINH:return"return asinh(a);";case Ln.ATAN:return"\n  if (isnan(a)) {\n    return uniforms.NAN;\n  }\n  return atan(a);\n";case Ln.ATANH:return"\n  if (abs(a) > 1.) {\n    return uniforms.NAN;\n  }\n  if (a == 1.) {\n    return uniforms.INFINITY;\n  }\n  if (a == -1.) {\n    return -uniforms.INFINITY;\n  }\n  return atanh(a);\n";case Ln.COS:return"return cos(a);";case Ln.COSH:return"\n  let e2x = exp(-a);\n  return (e2x + 1.0 / e2x) / 2.0;\n";case Ln.CEIL:return"return ceil(a);";case Ln.ELU:return t?"\n  var resFloat = exp(a) - vec4<f32>(1.0);\n  if (a.r >= 0.0) {\n    resFloat.r = a.r;\n  }\n  if (a.g >= 0.0) {\n    resFloat.g = a.g;\n  }\n  if (a.b >= 0.0) {\n    resFloat.b = a.b;\n  }\n  if (a.a >= 0.0) {\n    resFloat.a = a.a;\n  }\n  return resFloat;\n":"if (a >= 0.0) { return a; }  return (exp(a) - 1.0);";case Ln.ERF:return Un;case Ln.EXP:return"return exp(a);";case Ln.EXPM1:return"return exp(a) - 1.0;";case Ln.FLOOR:return"return floor(a);";case Ln.IS_FINITE:return"return f32(!isnan(a) && !isinf(a));";case Ln.IS_INF:return"return f32(isinf(a));";case Ln.IS_NAN:return"return f32(isnan(a));";case Ln.LINEAR:return"return a;";case Ln.LOG:return"if (a < 0.0) { return uniforms.NAN; }\n  return log(a);";case Ln.LOG1P:return"\n  if (isnan(a)) { return a; }\n  return log(1.0 + a);\n";case Ln.LOGICAL_NOT:return"return f32(!(a >= 1.0));";case Ln.NEG:return"return -a;";case Ln.LEAKYRELU:return t?"\n  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));\n  return (aLessThanZero * (uniforms.alpha * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);\n":"if (a < 0.0) { return uniforms.alpha * a; } return a;";case Ln.RECIPROCAL:return"return 1.0 / a;";case Ln.RELU:return t?"\n  return select(a, vec4<f32>(0.0), a < vec4<f32>(0.0));\n":"return select(a, 0.0, a < 0.0);";case Ln.RELU6:return t?"return clamp(a, vec4<f32>(0.0, 0.0, 0.0, 0.0), vec4<f32>(6.0, 6.0, 6.0, 6.0));":"return clamp(a, 0.0, 6.0);";case Ln.ROUND:return"return round(a);";case Ln.RSQRT:return"return inverseSqrt(a);";case Ln.SELU:return Dn;case Ln.SIGMOID:return"return 1.0 / (1.0 + exp(-1.0 * a));";case Ln.SIGN:return"return sign(a);";case Ln.SIN:return"return sin(a);";case Ln.SINH:return"\n  let e2x = exp(a);\n  return (e2x - 1.0 / e2x) / 2.0;\n";case Ln.SOFTPLUS:return"\n  let epsilon = 1.1920928955078125e-7;\n  let threshold = log(epsilon) + 2.0;\n\n  let too_large = a > -threshold;\n  let too_small = a < threshold;\n  let exp_a = exp(a);\n\n  if (too_large) {\n    return a;\n  } else if (too_small) {\n    return exp_a;\n  } else {\n    return log(exp_a + 1.0);\n  }\n";case Ln.SQRT:return"return sqrt(a);";case Ln.SQUARE:return"return a * a;";case Ln.STEP:return"\n  if (isnan(a)) {\n    return a;\n  }\n\n  return select(uniforms.stepAlpha, 1.0, a > 0.0);\n";case Ln.TAN:return"return tan(a);";case Ln.TANH:return"\n  let e2x = exp(-2.0 * abs(a));\n  return sign(a) * (1.0 - e2x) / (1.0 + e2x);\n";case Ln.TO_INT:return"return f32(i32((a)));";default:throw new Error(`BinaryType ${e} is not implemented!`)}}const Mn=e=>{switch(e){case 1:return"f32";case 2:return"vec2<f32>";case 3:return"vec3<f32>";case 4:return"vec4<f32>";default:throw new Error(`${e}-component is not supported.`)}};function Vn(e,t=!1,n=!1,r=3){if(null===e)return"";let s="";if("linear"===e)s=Wn(Ln.LINEAR);else if("relu"===e)s=Wn(Ln.RELU,n);else if("elu"===e)s=Wn(Ln.ELU,n);else if("relu6"===e)s=Wn(Ln.RELU6,n);else if("prelu"===e)s=On(Tn.PRELU,n);else if("sigmoid"===e)s=Wn(Ln.SIGMOID,n);else{if("leakyrelu"!==e)throw new Error(`Activation ${e} has not been implemented for the WebGPU backend.`);s=Wn(Ln.LEAKYRELU,n)}const a=Mn(n?4:1);let i="";return i=t?`\n      fn activation(a : ${a}, coords : vec${r}<i32>) -> ${a} {\n        let b = getPreluActivationWeightsByOutputCoords(coords);\n        ${s}\n      }`:`\n      fn activation(a : ${a}, coords : vec${r}<i32>) -> ${a} {\n        ${s}\n      }`,i}function Gn(e,t){return`\n      ${e?"value = value + getBiasByOutputCoords(coords);":""}\n      ${t?"value = activation(value, coords);":""}\n      `}function Hn(e,t,n=!1,s=!1,a=!1,i=1){r.assert(e&&1===i||!e,(()=>`transposeA ${e} is not compatible with component size ${i}`));const o=`\n      ${e?"value = getA(batch, col, row);":"value = getA(batch, row, col);"}\n\n    `,u=t?"value = getB(batch, col, row);":"value = getB(batch, row, col);";return`\n  fn mm_readA(batch: i32, row: i32, colIn: i32) -> ${Mn(i)} {\n    var value = ${Mn(i)}(0.0);\n    let col = colIn * ${i};\n    ${n&&a?o:`\n    ${e?"if(row < uniforms.dimAOuter && col < uniforms.dimInner)":"if(row < uniforms.aShape[1] && col < uniforms.aShape[2])"}\n    {\n      ${o}\n    }\n    `}\n    return value;\n  }\n\n  fn mm_readB(batch: i32, row: i32, colIn: i32) -> ${Mn(i)} {\n    let col = colIn * ${i};\n    var value = ${Mn(i)}(0.0);\n    ${u}\n    return value;\n  }\n  `}function Xn(e,t,n,r,s=!1,a=!1,i=!1,o=1){return`\n  ${Hn(n,r,s,a,i,o)}\n  fn mm_write(batch: i32, row: i32, colIn: i32, valueIn: ${Mn(o)}) {\n    let col = colIn * ${o};\n    ${s&&a?"":"if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)"}\n    {\n      var value = valueIn;\n      let coords = vec3<i32>(batch, row, col);\n      ${Gn(e,t)}\n      setOutputAtCoords(coords[0], coords[1], coords[2], value);\n    }\n  }\n  `}function Kn(e,t,n=!1,s=32,a=!1,i=32,o=!1,u=!1){const l=t[1]*e[1],h=t[0]*e[0],d=n?l:s,p=n?s:l,c=d/t[0],f=s/t[1],m=e[1];return r.assert((n&&4===c&&4===e[1]||!n&&(3===c||4===c))&&d%t[0]==0&&s%t[1]==0&&4===e[0],(()=>`If transposeA ${n} is true, innerElementSize ${c} and workPerThread[1] ${e[1]} must be 4.\n          Otherwise, innerElementSize ${c} must be 3 or 4.\n      tileAWidth ${d} must be divisible by workgroupSize[0]${t[0]}. tileInner ${s} must be divisible by workgroupSize[1] ${t[1]}. colPerThread ${e[0]} must be 4.`)),`\n  var<workgroup> mm_Asub : array<array<vec${c}<f32>, ${d/c}>, ${p}>;\n  var<workgroup> mm_Bsub : array<array<vec4<f32>, ${h/e[0]}>, ${s}>;\n\n  ${on()} {\n    let localRow = i32(localId.y);\n    let tileRow = ${o?"0":`localRow * ${m}`};\n    let tileCol = i32(localId.x);\n\n    let globalRow = ${o?"0":`i32(globalId.y) * ${m}`};\n    let globalCol = i32(globalId.x);\n    let batch = ${a?"0":"i32(globalId.z)"};\n    let batchA = ${a||!u?"batch":"batch % uniforms.aShape[0]"};\n    let batchB = ${a||!u?"batch":"batch % uniforms.bShape[0]"};\n    let globalRowStart = i32(workgroupId.y) * ${l};\n\n    let numTiles = ${a?`${Math.ceil(i/s)}`:`(uniforms.dimInner - 1) / ${s} + 1`};\n    var kStart = ${a?`i32(globalId.z) * ${i}`:"0"};\n\n    var acc: array<vec4<f32>, ${m}>;\n\n    // Loop over shared dimension.\n    let tileRowB = localRow * ${f};\n    for (var t = 0; t < numTiles; t++) {\n        // Load one tile of A into local memory.\n        for (var innerRow = 0; innerRow < ${m}; innerRow++) {\n            let inputRow = tileRow + innerRow;\n            let inputCol = tileCol;\n            ${((e,t)=>e?`\n        mm_Asub[inputRow][inputCol] = mm_readA(batchA,\n          kStart + inputRow,\n          globalRowStart / ${t} + inputCol);\n        `:`\n        mm_Asub[inputRow][inputCol] = mm_readA(batchA,\n          globalRow + innerRow,\n          kStart / ${t} + inputCol);\n        `)(n,c)}\n        }\n\n        // Load one tile of B into local memory.\n        for (var innerRow = 0; innerRow < ${f}; innerRow++) {\n            let inputRow = tileRowB + innerRow;\n            let inputCol = tileCol;\n            mm_Bsub[inputRow][inputCol] = mm_readB(batchB, kStart + inputRow, globalCol);\n        }\n        kStart = kStart + ${s};\n        workgroupBarrier();\n\n        // Compute acc values for a single thread.\n        for (var k = 0; k < ${s/c}; k++) {\n            let BCached0 = mm_Bsub[k * ${c}][tileCol];\n            let BCached1 = mm_Bsub[k * ${c} + 1][tileCol];\n            let BCached2 = mm_Bsub[k * ${c} + 2][tileCol];\n            ${3===c?"":`let BCached3 = mm_Bsub[k * ${c} + 3][tileCol];`}\n\n            ${((e,t,n)=>e?`\n        let ACached0 = mm_Asub[k * ${t}][localRow];\n        let ACached1 = mm_Asub[k * ${t} + 1][localRow];\n        let ACached2 = mm_Asub[k * ${t} + 2][localRow];\n        ${3===t?"":`let ACached3 = mm_Asub[k * ${t} + 3][localRow];`}\n        for (var i = 0; i < ${n}; i++) {\n          acc[i] = BCached0 * ACached0[i] + acc[i];\n          acc[i] = BCached1 * ACached1[i] + acc[i];\n          acc[i] = BCached2 * ACached2[i] + acc[i];\n          ${3===t?"":"acc[i] = BCached3 * ACached3[i] + acc[i];"}\n        }`:`\n        for (var i = 0; i < ${n}; i++) {\n          let ACached = mm_Asub[tileRow + i][k];\n          acc[i] = BCached0 * ACached.x + acc[i];\n          acc[i] = BCached1 * ACached.y + acc[i];\n          acc[i] = BCached2 * ACached.z + acc[i];\n          ${3===t?"":"acc[i] = BCached3 * ACached.w + acc[i];"}\n        }`)(n,c,m)}\n        }\n\n        workgroupBarrier();\n    }\n\n    for (var innerRow = 0; innerRow < ${m}; innerRow++) {\n        mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);\n    }\n  }`}const qn=e=>e?"\n        mm_Asub[inputRow][inputCol] = mm_readA(batchA,\n          kStart + inputRow,\n          globalRowStart + inputCol);\n        ":"\n        mm_Asub[inputRow][inputCol] = mm_readA(batchA,\n          globalRowStart + inputRow,\n          kStart + inputCol);\n        ";function jn(e,t,n=!1,s=32,a=!1,i=32,o=!1,u=!1){const l=e[1]*t[1],h=e[0]*t[0],d=n?l:s,p=n?s:l;r.assert(p%t[1]==0&&d%t[0]==0&&s%t[1]==0,(()=>`tileAHight ${p} must be divisible by workgroupSize[1]${t[1]}, tileAWidth ${d} must be divisible by workgroupSize[0]${t[0]}, tileInner ${s} must be divisible by workgroupSize[1]${t[1]}`));const c=p/t[1],f=d/t[0],m=s/t[1],g=e[1],b=e[0],x=o?`\n      let localRow = i32(localId.y);\n      let localCol = i32(localId.x);\n      let globalRowStart = i32(workgroupId.y) * ${l};\n      let globalColStart = i32(workgroupId.x) * ${h};\n\n      // Loop over shared dimension.\n      for (var t = 0; t < numTiles; t++) {\n        // Load one tile of A into local memory.\n        for (var inputRow = localRow; inputRow < ${p}; inputRow = inputRow + ${t[1]}) {\n          for (var inputCol = localCol; inputCol < ${d}; inputCol = inputCol + ${t[0]}) {\n            ${qn(n)}\n          }\n        }\n        // Load one tile of B into local memory.\n        for (var inputRow = localRow; inputRow < ${s}; inputRow = inputRow + ${t[1]}) {\n              for (var inputCol = localCol; inputCol < ${h}; inputCol = inputCol + ${t[0]}) {\n            mm_Bsub[inputRow][inputCol] = mm_readB(batchB,\n              kStart + inputRow,\n              globalColStart + inputCol);\n          }\n        }\n        kStart = kStart + ${s};\n        workgroupBarrier();\n\n        // Compute acc values for a single thread.\n        var BCached : array<f32, ${b}>;\n        for (var k = 0; k < ${s}; k++) {\n          for (var inner = 0; inner < ${b}; inner++) {\n            BCached[inner] = mm_Bsub[k][localCol + inner * ${t[0]}];\n          }\n          for (var innerRow = 0; innerRow < ${g}; innerRow++) {\n            let ACached = ${n?`mm_Asub[k][localRow + innerRow * ${t[1]}];`:`mm_Asub[localRow + innerRow * ${t[1]}][k];`}\n            for (var innerCol = 0; innerCol < ${b}; innerCol++) {\n              acc[innerRow][innerCol] = acc[innerRow][innerCol] +\n                  ACached * BCached[innerCol];\n            }\n          }\n        }\n        workgroupBarrier();\n      }\n      for (var innerRow = 0; innerRow < ${g}; innerRow++) {\n        let gRow = globalRowStart + localRow + innerRow * ${t[1]};\n        for (var innerCol = 0; innerCol < ${b}; innerCol++) {\n          let gCol = globalColStart + localCol + innerCol * ${t[0]};\n          mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);\n        }\n      }\n      `:`\n  let tileRow = i32(localId.y) * ${g};\n  let tileCol = i32(localId.x) * ${b};\n\n  let globalRow = i32(globalId.y) * ${g};\n  let globalCol = i32(globalId.x) * ${b};\n  let globalRowStart = i32(workgroupId.y) * ${l};\n\n  let tileRowA = i32(localId.y) * ${c};\n  let tileColA = i32(localId.x) * ${f};\n  let tileRowB = i32(localId.y) * ${m};\n  // Loop over shared dimension.\n  for (var t = 0; t < numTiles; t++) {\n    // Load one tile of A into local memory.\n    for (var innerRow = 0; innerRow < ${c}; innerRow++) {\n      for (var innerCol = 0; innerCol < ${f}; innerCol++) {\n        let inputRow = tileRowA + innerRow;\n        let inputCol = tileColA + innerCol;\n        ${qn(n)}\n      }\n    }\n\n    // Load one tile of B into local memory.\n    for (var innerRow = 0; innerRow < ${m}; innerRow++) {\n      for (var innerCol = 0; innerCol < ${b}; innerCol++) {\n        let inputRow = tileRowB + innerRow;\n        let inputCol = tileCol + innerCol;\n        mm_Bsub[inputRow][inputCol] = mm_readB(batchB,\n          kStart + inputRow,\n          globalCol + innerCol);\n      }\n    }\n    kStart = kStart + ${s};\n    workgroupBarrier();\n\n    // Compute acc values for a single thread.\n    var BCached : array<f32, ${b}>;\n    for (var k = 0; k < ${s}; k++) {\n      for (var inner = 0; inner < ${b}; inner++) {\n        BCached[inner] = mm_Bsub[k][tileCol + inner];\n      }\n\n      for (var innerRow = 0; innerRow < ${g}; innerRow++) {\n        ${(e=>e?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];")(n)}\n        for (var innerCol = 0; innerCol < ${b}; innerCol++) {\n          acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];\n        }\n      }\n    }\n\n    workgroupBarrier();\n  }\n\n  for (var innerRow = 0; innerRow < ${g}; innerRow++) {\n    for (var innerCol = 0; innerCol < ${b}; innerCol++) {\n      mm_write(batch, globalRow + innerRow, globalCol + innerCol,\n          acc[innerRow][innerCol]);\n    }\n  }\n  `;return`\n    var<workgroup> mm_Asub : array<array<f32, ${d}>, ${p}>;\n    var<workgroup> mm_Bsub : array<array<f32, ${h}>, ${s}>;\n\n    ${on()} {\n      let batch = ${a?"0":"i32(globalId.z)"};\n      let batchA = ${a||!u?"batch":"batch % uniforms.aShape[0]"};\n      let batchB = ${a||!u?"batch":"batch % uniforms.bShape[0]"};\n      let numTiles = ${a?`${Math.ceil(i/s)}`:`(uniforms.dimInner - 1) / ${s} + 1`};\n      var kStart = ${a?`i32(globalId.z) * ${i}`:"0"};\n\n      var acc : array<array<f32, ${b}>, ${g}>;\n\n      // Without this initialization strange values show up in acc.\n      for (var innerRow = 0; innerRow < ${g}; innerRow++) {\n        for (var innerCol = 0; innerCol < ${b}; innerCol++) {\n          acc[innerRow][innerCol] = 0.0;\n        }\n      }\n      ${x}\n    }\n  `}class Yn{constructor(e,t,n=!1,r=!1,s=null,a=null,i=null,o=!1){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=t,this.dispatchLayout={x:[2],y:[1],z:[0]};const u=n?e[1]:e[2];if(this.isVec4=(u%4==0&&!n||t[1]%4==0&&n)&&t[2]%4==0&&!r,this.isVectorA=1===t[1]&&!n,!this.isVec4&&this.isVectorA)this.elementsPerThread=[1,1,1],this.workgroupSize=[32,1,1];else{const e=xn(t[1],u,t[2],n);this.workgroupSize=e.workgroupSize,this.elementsPerThread=e.elementsPerThread}this.dispatch=bn(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread);const l=null!=s,h=null!=i;l&&this.variableNames.push("bias"),h&&this.variableNames.push("preluActivationWeights"),this.sequentialAccessByThreads=o,this.transposeA=n,this.transposeB=r,this.addBias=l,this.activation=a,this.hasPreluActivationWeights=h,[this.fitAOuter,this.fitBOuter,this.fitInner]=this.getShapeFit(t[1],t[2],u),this.shaderKey=`matMulPacked_${this.elementsPerThread}_${n}_${r}_${this.activation}_${this.fitAOuter}_${this.fitBOuter}_${this.fitInner}_${this.isVec4}_${this.isVectorA}_${this.sequentialAccessByThreads}`}getShapeFit(e,t,n){const r=this.workgroupSize[1]*this.elementsPerThread[1],s=this.workgroupSize[0]*this.elementsPerThread[0];!this.isVec4&&this.isVectorA?this.tileInner=4*this.workgroupSize[0]:this.tileInner=s;return[e%r==0,t%s==0,n%this.tileInner==0]}getUserCode(){const e=`\n      ${Vn(this.activation,this.hasPreluActivationWeights,this.isVec4)}\n      ${Xn(this.addBias,this.activation,!1,this.transposeB,this.fitAOuter,this.fitBOuter,this.fitInner,this.isVec4?4:1)}\n      ${this.isVec4?Kn(this.elementsPerThread,this.workgroupSize,this.transposeA,this.tileInner,!1,null,this.isVectorA,!0):this.isVectorA?function(e,t=!1){r.assert(1===e[1]&&1===e[2],(()=>`A linear work group size is required. But got ${e}.`));const n=4*e[0];return`\n    var<workgroup> mm_Asub : array<vec4<f32>, ${e[0]}>;\n\n    ${on()} {\n      let tileCol = i32(localId.x);\n      let globalCol = i32(globalId.x);\n      let globalRow = i32(globalId.y);\n\n      let numTiles = (uniforms.dimInner - 1) / ${n} + 1;\n      let batch = i32(globalId.z);\n      let batchA = batch % uniforms.aShape[0];\n      let batchB = batch % uniforms.bShape[0];\n      // Without this initialization strange values show up in acc.\n      var acc = 0.0;\n\n      // Loop over shared dimension.\n      for (var t = 0; t < numTiles; t++) {\n        // Load one tile of A into local memory.\n        let colA = t * ${n} + tileCol * 4;\n        mm_Asub[tileCol] = vec4<f32>(${(e=>e?"\n      mm_readA(batchA, colA, globalRow),\n      mm_readA(batchA, colA + 1, globalRow),\n      mm_readA(batchA, colA + 2, globalRow),\n      mm_readA(batchA, colA + 3, globalRow)\n  ":"\n      mm_readA(batchA, globalRow, colA),\n      mm_readA(batchA, globalRow, colA + 1),\n      mm_readA(batchA, globalRow, colA + 2),\n      mm_readA(batchA, globalRow, colA + 3)\n  ")(t)});\n        workgroupBarrier();\n\n        // Compute acc values for a single thread.\n        for (var k = 0; k < ${n/4}; k++) {\n          let rowB = t * ${n} + k * 4;\n          let BCached = vec4<f32>(mm_readB(batchB, rowB, globalCol),\n                              mm_readB(batchB, rowB + 1, globalCol),\n                              mm_readB(batchB, rowB + 2, globalCol),\n                              mm_readB(batchB, rowB + 3, globalCol));\n\n          let ACached = mm_Asub[k];\n          acc = acc + dot(ACached, BCached);\n        }\n\n        workgroupBarrier();\n      }\n\n      mm_write(batch, globalRow, globalCol, acc);\n    }\n  `}(this.workgroupSize,this.transposeA):jn(this.elementsPerThread,this.workgroupSize,this.transposeA,this.tileInner,!1,null,this.sequentialAccessByThreads,!0)}\n    `;return e}}class Qn{constructor(e,t=!1,n=!1,r=null,s=null,a=null){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[256,1,1],this.outputShape=e,this.dispatchLayout={x:[],y:[1,2],z:[0]},this.dispatch=bn(this.dispatchLayout,this.outputShape,this.workgroupSize);const i=null!=r,o=null!=a;i&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),this.transposeA=t,this.transposeB=n,this.addBias=i,this.activation=s,this.hasPreluActivationWeights=o,this.shaderKey=`matMulReduce_${this.activation}_${t}_${n}`}getUserCode(){var e;return`\n      ${Vn(this.activation,this.hasPreluActivationWeights)}\n      ${Xn(this.addBias,this.activation,this.transposeA,this.transposeB)}\n      ${e=this.workgroupSize[0],`\n    var<workgroup> sumValues : array<f32, ${e}>;\n    ${on()} {\n      let coords = getOutputCoords();\n      let batch = coords[0];\n      let batchA = batch % uniforms.aShape[0];\n      let batchB = batch % uniforms.bShape[0];\n      let row = coords[1];\n      let col = coords[2];\n      var sum = 0.0;\n      let Length = uniforms.dimInner;\n      for (var k = i32(localId.x); k < Length; k = k + ${e}) {\n        let dataA = mm_readA(batchA, row, k);\n        let dataB = mm_readB(batchB, k, col);\n        sum = sum + dataA * dataB;\n      }\n      sumValues[localId.x] = sum;\n      workgroupBarrier();\n\n      for(var currentSize = ${e/2}u; currentSize > 1u;\n          currentSize = currentSize / 2u) {\n        if (localId.x < currentSize)\n        {\n          sumValues[localId.x] = sumValues[localId.x] + sumValues[localId.x + currentSize];\n        }\n        workgroupBarrier();\n      }\n\n      if (localId.x == 0u) {\n        sum = sumValues[0] + sumValues[1];\n        mm_write(batch, row, col, sum);\n      }\n    }\n  `}\n    `}}class Zn{constructor(e,t,n,r=!1,s=!1,a=null,i=null,o=null){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[16,8,1],this.outputShape=n,this.dispatchLayout={x:[2],y:[1],z:[0]},this.dispatch=[Math.ceil(n[2]/this.workgroupSize[0]),Math.ceil(n[1]/this.workgroupSize[1]),n[0]];const u=null!=a;u&&this.variableNames.push("bias");const l=null!=o;l&&this.variableNames.push("preluActivationWeights"),this.transposeA=r,this.transposeB=s,this.addBias=u,this.activation=i,this.hasPreluActivationWeights=l,this.shaderKey=`matMulSmallOutputSize_${this.activation}_${r}_${s}`}getUserCode(){return`\n      ${Vn(this.activation,this.hasPreluActivationWeights)}\n      ${Xn(this.addBias,this.activation,this.transposeA,this.transposeB)}\n      ${function(e){const t=e[1],n=e[0],r=t>n?t:n;return`\n  var<workgroup> mm_Asub : array<array<f32, ${r}>, ${t}>;\n  var<workgroup> mm_Bsub : array<array<f32, ${n}>, ${r}>;\n\n  // If the output size is small for matrix multiplication, avoid to use vec4\n  // and handle some elements per thread to optimally utilize the ALU.\n  // Read data from global memory to registers firstly, then store them into\n  // shared memory, so it is instruction-Level parallelism for arithmetic\n  // operations and others handle IO operations between barrier api, makes ALU\n  // and load/store units work simultaneously, could improves the performance.\n  ${on()} {\n    let tileRow = i32(localId.y);\n    let tileCol = i32(localId.x);\n    let globalRow = i32(globalId.y);\n    let globalCol = i32(globalId.x);\n    let batch = i32(globalId.z);\n    let batchA = batch % uniforms.aShape[0];\n    let batchB = batch % uniforms.bShape[0];\n\n    // uniforms.dimInner should be greater than 0.\n    let numTiles = (uniforms.dimInner - 1) / ${r} + 1;\n    var acc = 0.0;\n\n    var globalColA = tileCol;\n    var globalRowB = 0;\n    var regA = mm_readA(batchA, globalRow, globalColA);\n    var regB0 = mm_readB(batchB, globalRowB + 2 * tileRow, globalCol);\n    var regB1 = mm_readB(batchB, globalRowB + 2 * tileRow + 1, globalCol);\n    globalColA = globalColA + ${r};\n    globalRowB = globalRowB + ${r};\n\n    for (var t = 0; t < numTiles; t = t + 1) {\n      mm_Asub[tileRow][tileCol] = regA;\n      mm_Bsub[2 * tileRow][tileCol] = regB0;\n      mm_Bsub[2 * tileRow + 1][tileCol] = regB1;\n\n      workgroupBarrier();\n\n      regA = mm_readA(batchA, globalRow, globalColA);\n      regB0 = mm_readB(batchB, globalRowB + 2 * tileRow, globalCol);\n      regB1 = mm_readB(batchB, globalRowB + 2 * tileRow + 1, globalCol);\n      globalColA = globalColA + ${r};\n      globalRowB = globalRowB + ${r};\n\n      for (var k = 0; k < ${r}; k = k + 1) {\n        acc = acc + mm_Asub[tileRow][k] * mm_Bsub[k][tileCol];\n      }\n      workgroupBarrier();\n    }\n\n    mm_write(batch, globalRow, globalCol, acc);\n  }\n  `}(this.workgroupSize)}\n    `}}class Jn{constructor(e,t,n=!1,s=!1){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[8,8,1],this.atomic=!0,this.isVec4=!1,this.splitedDimInner=128,r.assert(1===e[0],(()=>"MatMulSplitKProgram only supports batch = 1.")),this.outputShape=e,this.dispatchLayout={x:[2],y:[1],z:[0,3]},this.isVec4=(n&&this.outputShape[1]%4==0||!n&&t%4==0)&&this.outputShape[2]%4==0,this.elementsPerThread=[4,4,this.splitedDimInner],this.isVec4||(this.outputShape[1]<16&&(this.elementsPerThread[1]=1),this.outputShape[2]<16&&(this.elementsPerThread[0]=1)),this.dispatch=bn(this.dispatchLayout,[this.outputShape[0],this.outputShape[1],this.outputShape[2],t],this.workgroupSize,this.elementsPerThread),this.transposeA=n,this.transposeB=s,this.shaderKey=`matMulSplitK_${n}_${s}_${this.elementsPerThread}_${this.isVec4}`}getUserCode(){const e=this.isVec4?4:1;return`\n      ${Hn(!1,this.transposeB,!1,!1,!1,e)}\n      fn mm_write(batch: i32, row : i32, colIn : i32, value : ${Mn(e)}) {\n        let col = colIn * ${e};\n        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {\n          let coords = vec3<i32>(batch, row, col);\n          let flatIndex = getOutputIndexFromCoords(coords);\n          // The problem is that we should initialize output to zero before using.\n          // Otherwise, the original value will be added to the result.\n          for (var i = 0; i < ${e}; i = i + 1) {\n            ${nn("&result[flatIndex + i]",""+(e>1?"value[i]":"value"),"float32")}\n          }\n        }\n      }\n      ${this.isVec4?Kn(this.elementsPerThread,this.workgroupSize,this.transposeA,32,!0,this.splitedDimInner):jn(this.elementsPerThread,this.workgroupSize,this.transposeA,32,!0,this.splitedDimInner)}\n    `}}class er{constructor(e,t=null,n=null,r=null){this.uniforms="",this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=In(this.outputShape),this.dispatch=bn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.addBias=null!=t,this.hasPreluActivationWeights=null!=r,this.activation=n,this.addBias&&this.variableNames.push("bias"),this.hasPreluActivationWeights&&this.variableNames.push("preluActivationWeights"),this.shaderKey=`biasActivation_${n}`}getUserCode(){return`\n    ${Vn(this.activation,this.hasPreluActivationWeights)}\n    ${on("index")} {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        var value = getXByOutputIndex(index);\n        ${Gn(this.addBias,this.activation)}\n        setOutputAtIndex(index, value);\n      }\n    }\n    `}}class tr{constructor(e){this.variableNames=[],this.outputShape=[],this.uniforms="value : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=In(this.outputShape),this.dispatch=bn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="fill"}getUserCode(){return`\n    ${on("index")} {\n      if (index < uniforms.size) {\n        setOutputAtIndex(index, uniforms.value);\n      }\n    }\n  `}}function nr(e){const{backend:t,attrs:n}=e,{shape:s,value:a}=n;let{dtype:i}=n;if(i=i||r.inferDtype(a),"string"===i){const e=r.getArrayFromDType(i,r.sizeFromShape(s));return e.fill(a),t.makeTensorInfo(s,i,e)}{const e=new tr(s),n=[{type:"float32",data:[a]}];return t.runWebGPUProgram(e,[],i,n)}}const rr={kernelName:l,backendName:"webgpu",kernelFunc:nr};function sr(e){const{inputs:t,attrs:n}=e,{x:s}=t,{shape:a}=n,i=r.sizeFromShape(s.shape),o=r.inferFromImplicitShape(a,i),u=r.sizeFromShape(o);return r.assert(i===u,(()=>`The new shape (${o}) has ${u} elements and the old shape (${s.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`)),e.backend.incRef(s.dataId),{dataId:s.dataId,shape:o,dtype:s.dtype}}const ar={kernelName:h,backendName:"webgpu",kernelFunc:sr};function ir({a:e,b:n,transposeA:s,transposeB:a,backend:i,bias:o=null,preluActivationWeights:u=null,leakyreluAlpha:l=0,activation:h=null}){const p=e.shape.length,c=n.shape.length,f=s?e.shape[p-2]:e.shape[p-1],m=a?n.shape[c-1]:n.shape[c-2],g=s?e.shape[p-1]:e.shape[p-2],b=a?n.shape[c-2]:n.shape[c-1],x=e.shape.slice(0,-2),w=n.shape.slice(0,-2),y=r.sizeFromShape(x),I=r.sizeFromShape(w),S=d.assertAndGetBroadcastShape(e.shape.slice(0,-2),n.shape.slice(0,-2)).concat([g,b]);r.assert(f===m,(()=>`Error in matMul: inner shapes (${f}) and (${m}) of Tensors with shapes ${e.shape} and ${n.shape} and transposeA=${s} and transposeB=${a} must match.`));const k=s?[y,f,g]:[y,g,f],v=a?[I,b,m]:[I,m,b],C=sr({inputs:{x:e},backend:i,attrs:{shape:k}}),$=sr({inputs:{x:n},backend:i,attrs:{shape:v}}),R=[C,$],A=Math.max(y,I),T=[C,$],P=[{type:"int32",data:[g]},{type:"int32",data:[b]},{type:"int32",data:[f]}];let N,z;const E=[A,g,b];let F=t().get("WEBGPU_MATMUL_PROGRAM_TYPE");if(F<0){const e=t().getNumber("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL"),n=e>0?e:i.thresholdToIncreaseWorkgroups,r=A*Math.ceil(g/32)*Math.ceil(b/32);F=r<=n||g<=8&&r<=2*n?A*g*b<=128?Cn.MatMulReduceProgram:1===A&&m>=2e3?Cn.MatMulSplitKProgram:Cn.MatMulSmallOutputSizeProgram:Cn.MatMulPackedProgram}switch(F){case Cn.MatMulReduceProgram:N=new Qn(E,s,a,o,h,u);break;case Cn.MatMulSplitKProgram:if(z=nr({backend:i,attrs:{shape:E,value:0,dtype:e.dtype}}),N=new Jn(E,m,s,a),o||h){z=i.runWebGPUProgram(N,T,e.dtype,P,z);const t=new er(z.shape,o,h,u);let n=null;const r=[z];o&&r.push(o),u&&r.push(u),"leakyrelu"===h&&(n=[{type:"float32",data:[l]}],t.uniforms+=" alpha : f32,");const s=i.runWebGPUProgram(t,r,z.dtype,n);R.push(z);const a=sr({inputs:{x:s},backend:i,attrs:{shape:S}});R.push(s);for(const e of R)i.disposeData(e.dataId);return a}break;case Cn.MatMulSmallOutputSizeProgram:N=new Zn(k,v,E,s,a,o,h,u);break;case Cn.MatMulPackedProgram:const t=i.adapterInfo.isIntel();N=new Yn(k,E,s,a,o,h,u,t);break;default:throw new Error(`Unsupported MatMulProgramType ${F}.`)}o&&T.push(o),u&&T.push(u),"leakyrelu"===h&&(P.push({type:"float32",data:[l]}),N.uniforms+=" alpha : f32,"),z=i.runWebGPUProgram(N,T,e.dtype,P,z);const B=sr({inputs:{x:z},backend:i,attrs:{shape:S}});R.push(z);for(const e of R)i.disposeData(e.dataId);return B}const or={kernelName:p,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{a:s,b:a,bias:i,preluActivationWeights:o}=t,{transposeA:u,transposeB:l,activation:h,leakyreluAlpha:d}=r;return ir({a:s,b:a,transposeA:u,transposeB:l,backend:n,bias:i,preluActivationWeights:o,leakyreluAlpha:d,activation:h})}};class ur{constructor(e,t,r){this.variableNames=["AReal","AImag","BReal","BImag"],this.workgroupSize=[128,1,1],this.size=!0,this.outputShape=n.assertAndGetBroadcastShape(t,r),this.dispatchLayout=In(this.outputShape),this.dispatch=bn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey=`binaryOpComplex_${e}`,this.op=e}getUserCode(){return`\n      fn binaryOpComplex(\n          areal : f32, aimag : f32, breal : f32, bimag : f32) -> f32 {\n        ${On(this.op,!1)}\n      }\n\n      ${on("index")} {\n        if(index < uniforms.size) {\n          let areal = getARealByOutputIndex(index);\n          let aimag = getAImagByOutputIndex(index);\n          let breal = getBRealByOutputIndex(index);\n          let bimag = getBImagByOutputIndex(index);\n          setOutputAtIndex(index, binaryOpComplex(areal, aimag, breal, bimag));\n        }\n      }\n    `}}class lr{constructor(e,t,s){this.size=!0,this.variableNames=["A","B"],this.outputShape=n.assertAndGetBroadcastShape(t,s),this.dispatchLayout=In(this.outputShape),this.op=e,this.useSharedMemoryWithA=t.length<=1&&s.length>1&&t[0]<128,this.useSharedMemoryWithB=s.length<=1&&t.length>1&&s[0]<128,this.useSharedMemoryWithA||this.useSharedMemoryWithB?(this.isVec4=!1,this.lastDimensionSize=this.useSharedMemoryWithB?s[0]:t[0],this.shaderKey=`binary_${this.type}_${e}_${this.lastDimensionSize}_${this.useSharedMemoryWithB}`,this.type="shared",this.workgroupSize=[256,1,1],this.workPerThread=1):(r.arraysEqual(t,s)&&r.sizeFromShape(t)%4==0?(this.isVec4=!0,this.type="vec4",this.workPerThread=4):(this.isVec4=!1,this.type="plain",this.workPerThread=1),this.shaderKey=`binary_${this.type}_${e}`,this.workgroupSize=[128,1,1]),this.dispatch=bn(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1])}getUserCode(){let e;const t=this.isVec4?"vec4<f32>":"f32",n=`\n    fn binaryOperation(a : ${t}, b : ${t}) -> ${t} {\n      let isNaN = false;\n      {\n        ${On(this.op,this.isVec4)}\n      }\n    };\n    `;if("shared"===this.type){const t=this.lastDimensionSize>1?`coords[${this.outputShape.length-1}]`:"0",r=this.useSharedMemoryWithB?`let a = getAByOutputIndex(index);\n          let b = sharedBuf[${t}];`:`let a = sharedBuf[${t}];\n          let b = getBByOutputIndex(index);`;e=`\n        ${n}\n        var<workgroup> sharedBuf : array<f32, ${this.lastDimensionSize}>;\n        ${on("index")} {\n          // Fill in the shared memory buffer.\n          let localIndex = i32(localId.x);\n          if(localIndex < ${this.lastDimensionSize}) {\n            sharedBuf[localIndex] = f32(${this.useSharedMemoryWithB?"B":"A"}[localIndex]);\n          }\n          workgroupBarrier();\n\n          if(index < uniforms.size) {\n            let coords = getCoordsFromIndex(index);\n            ${r}\n            setOutputAtIndex(index, binaryOperation(a, b));\n          }\n        }\n        `}else e=`\n       ${n}\n       ${on("index")} {\n         if (index < uniforms.size) {\n           let a = getAByOutputIndex(index);\n           let b = getBByOutputIndex(index);\n           setOutputAtIndex(index, binaryOperation(a, b));\n         }\n       }\n       `;return e}}function hr(e){const{inputs:t}=e,{x:n}=t;return e.backend.incRef(n.dataId),{dataId:n.dataId,shape:n.shape,dtype:n.dtype}}const dr={kernelName:c,backendName:"webgpu",kernelFunc:hr};function pr(e){const{inputs:t,backend:n}=e,{real:r,imag:s}=t,a=n.makeTensorInfo(r.shape,"complex64"),i=n.tensorMap.get(a.dataId),o=hr({inputs:{x:r},backend:n}),u=hr({inputs:{x:s},backend:n});return i.complexTensorInfos={real:o,imag:u},a}const cr={kernelName:f,backendName:"webgpu",kernelFunc:pr};class fr{constructor(e,t,n=""){this.variableNames=["A"],this.size=!0;this.workgroupSize=[128,1,1],this.outputShape=e,this.dispatchLayout=In(this.outputShape),this.dispatch=bn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.op=t,""!==n&&(this.uniforms=n),this.shaderKey=`unary_${t}`}getUserCode(){return`\n      fn unaryOperation(a : f32) -> f32 {\n        ${Wn(this.op,!1)}\n      }\n      ${on("index")} {\n        if (index < uniforms.size) {\n          let a = getAByOutputIndex(index);\n          setOutputAtIndex(index, unaryOperation(a));\n        }\n      }\n      `}}function mr({opType:e,cpuKernelImpl:t,dtype:n}){return({inputs:r,backend:s})=>{const{x:a}=r,i=s,o=n||a.dtype;if(i.shouldExecuteOnCPU([a])&&null!=t){const e=i.tensorMap.get(a.dataId),n=t(e.values,o);return i.makeTensorInfo(a.shape,o,n)}const u=new fr(a.shape,e);return i.runWebGPUProgram(u,[a],o)}}function gr({opType:e,cpuKernelImpl:t,supportsComplex:r=!1,dtype:s}){return({inputs:a,backend:i})=>{const{a:o,b:u}=a,l=i;if(r&&"complex64"===o.dtype){const t=l.tensorMap.get(o.dataId),n=l.tensorMap.get(u.dataId);let r,s;if(e!==Tn.MUL)[r,s]=[[t.complexTensorInfos.real,n.complexTensorInfos.real],[t.complexTensorInfos.imag,n.complexTensorInfos.imag]].map((t=>{const[n,r]=t,s={dataId:n.dataId,dtype:n.dtype,shape:o.shape},a={dataId:r.dataId,dtype:r.dtype,shape:u.shape},i=new lr(e,o.shape,u.shape);return l.runWebGPUProgram(i,[s,a],m(n.dtype,r.dtype))}));else{const e=new ur(Tn.COMPLEX_MULTIPLY_REAL,o.shape,u.shape),a=new ur(Tn.COMPLEX_MULTIPLY_IMAG,o.shape,u.shape),i=[{dataId:t.complexTensorInfos.real.dataId,dtype:t.complexTensorInfos.real.dtype,shape:o.shape},{dataId:t.complexTensorInfos.imag.dataId,dtype:t.complexTensorInfos.imag.dtype,shape:o.shape},{dataId:n.complexTensorInfos.real.dataId,dtype:n.complexTensorInfos.real.dtype,shape:u.shape},{dataId:n.complexTensorInfos.imag.dataId,dtype:n.complexTensorInfos.imag.dtype,shape:u.shape}];r=l.runWebGPUProgram(e,i,"float32"),s=l.runWebGPUProgram(a,i,"float32")}const a=pr({inputs:{real:r,imag:s},backend:l});return l.disposeData(r.dataId),l.disposeData(s.dataId),a}const h=s||m(o.dtype,u.dtype);if(("string"===o.dtype||"string"===u.dtype||l.shouldExecuteOnCPU([o,u]))&&null!=t){const e=l.tensorMap.get(o.dataId).values,r=l.tensorMap.get(u.dataId).values,s="string"===o.dtype?n.fromUint8ToStringArray(e):e,a="string"===o.dtype?n.fromUint8ToStringArray(r):r,[i,d]=t(o.shape,u.shape,s,a,h);return l.makeTensorInfo(d,h,i)}const d=new lr(e,o.shape,u.shape);return l.runWebGPUProgram(d,[o,u],h)}}function br(e){return(t,s,a,i,o)=>{const u=n.assertAndGetBroadcastShape(t,s),l=u.length,h=r.computeStrides(u),d=r.sizeFromShape(u),p=r.getTypedArrayFromDType(o,d),c=t.length,f=s.length,m=r.computeStrides(t),g=r.computeStrides(s),b=n.getBroadcastDims(t,u),x=n.getBroadcastDims(s,u);if(b.length+x.length===0)for(let t=0;t<p.length;++t)p[t]=e(a[t%a.length],i[t%i.length]);else for(let t=0;t<p.length;++t){const n=r.indexToLoc(t,l,h),s=n.slice(-c);b.forEach((e=>s[e]=0));const o=r.locToIndex(s,c,m),u=n.slice(-f);x.forEach((e=>u[e]=0));const d=r.locToIndex(u,f,g);p[t]=e(a[o],i[d])}return[p,u]}}const xr=br(((e,t)=>e+t));function wr(e){return(t,n,s)=>{const a=r.getTypedArrayFromDType(n,t.length);for(let n=0;n<t.length;++n)a[n]=e(t[n],s);return a}}const yr=wr((e=>Math.ceil(e)));const Ir=br(((e,t)=>e===t?1:0)),Sr=wr((e=>Math.exp(e))),kr=wr((e=>Math.expm1(e))),vr=wr((e=>Math.floor(e)));const Cr=br(((e,t)=>e>t?1:0)),$r=br(((e,t)=>e>=t?1:0)),Rr=br(((e,t)=>e<t?1:0)),Ar=br(((e,t)=>e<=t?1:0));const Tr=wr((e=>Math.log(e)));const Pr=br(((e,t)=>Math.max(e,t))),Nr=br(((e,t)=>Math.min(e,t))),zr=br(((e,t)=>e*t));const Er=br(((e,t)=>e!==t?1:0));function Fr(e,t,n,r){const s=[];let a=0;const i=t.length-1+n.length,o=new Array(i).fill(null).map((()=>[0]));!function(e,t){for(let n=0;n<e.length;++n){const r=e[n],s=n===e.length-1?t:e[n+1].length;if(0===r.length)throw new Error("Ragged splits may not be empty");if(r[0]<0)throw new Error("Ragged splits must be non-negative");if(r[r.length-1]>s)throw new Error("Ragged splits must not point past values");for(let e=1;e<r.length;++e)if(r[e-1]>r[e])throw new Error("Ragged splits must be sorted in ascending order")}}(n,r);let u=1;for(let e=0;e<t.length-1;++e){u*=t[e];const n=t[e+1];for(let t=1;t<u+1;++t)o[e].push(t*n)}for(let r=0;r<e.length;++r){let i=e[r],u=e[r]+1;for(let e=0;e<n.length;++e){const r=n[e],s=e+t.length-1;if(s>=0){const e=o[s],t=e[e.length-1]-r[i];for(let e=i;e<u;++e)o[s].push(r[e+1]+t)}i=r[i],u=r[u]}u!==i&&(s.push([i,u]),a+=u-i)}return{outSplits:o,valueSlices:s,numValues:a}}function Br(e,t){const n=e.slice(0,t);for(;n.length<t;)n.push(1);for(let r=t;r<e.length;r++)n[t-1]*=e[r];return n}function _r(e,t,n,s,a){const i=t.slice();i[0]=a;const o=r.getArrayFromDType(n,r.sizeFromShape(i)),u=e.length;return function(e,t,n,r,s,a){const i=Br(t,2)[1],o=Br(a,2)[1];let u=0;for(const t of n)for(let n=t[0];n<t[1];++n){for(let t=0;t<r;++t)s[u*o+t]=e[n*i+t];++u}}(e,t,s,0===u?0:u/t[0],o,i),[o,i]}var Or=n.RowPartitionType;class Lr{constructor(e,t,r,s,a,i,o,u,l,h){this.shape=e,this.shapeShape=t,this.values=r,this.valuesShape=s,this.valuesDType=a,this.defaultValue=i,this.defaultValueShape=o,this.rowPartitionValues=u,this.rowPartitionValuesShapes=l,this.rowPartitionTypes=n.getRowPartitionTypesHelper(h),this.raggedRank=n.getRaggedRank(this.rowPartitionTypes)}getRowPartitionTypeByDimension(e){return this.rowPartitionTypes[0]===Or.FIRST_DIM_SIZE?this.rowPartitionTypes[e+1]:this.rowPartitionTypes[e]}getRowPartitionTensor(e){return this.rowPartitionTypes[0]===Or.FIRST_DIM_SIZE?this.rowPartitionValues[e+1]:this.rowPartitionValues[e]}getMaxWidth(e){const t=this.getRowPartitionTensor(e-1);switch(this.getRowPartitionTypeByDimension(e-1)){case Or.VALUE_ROWIDS:return Lr.getMaxWidthValueRowID(t);case Or.ROW_SPLITS:return Lr.getMaxWidthRowSplit(t);default:throw new Error(`Cannot handle partition type ${Or[this.getRowPartitionTypeByDimension(e-1)]}`)}}static getMaxWidthRowSplit(e){const t=e.length;if(0===t||1===t)return 0;let n=0;for(let r=0;r<t-1;++r){const t=e[r+1]-e[r];t>n&&(n=t)}return n}static getMaxWidthValueRowID(e){const t=e.length;if(0===t)return 0;let n=0,r=e[0],s=0;for(let a=1;a<t;++a){const t=e[a];t!==r&&(r=t,s=Math.max(a-n,s),n=a)}return Math.max(t-n,s)}tensorShapeFromTensor(e,t,n=!0){if(0===t.length){if(-1===e[0])return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return Dr(e,n)}calculateOutputSize(e){const t=this.valuesShape,r=this.defaultValueShape;n.validateDefaultValueShape(r,t);const s=this.tensorShapeFromTensor(this.shape,this.shapeShape),a=n.combineRaggedTensorToTensorShapes(this.raggedRank,s,t);a[0]<0&&(a[0]=e);for(let e=1;e<=this.raggedRank;++e)a[e]<0&&(a[e]=this.getMaxWidth(e));return a}calculateFirstParentOutputIndex(e,t,n){const s=Math.min(e,n),a=[];let i=0;for(let e=0;e<s;++e,i+=t)a.push(i);for(let t=s;t<e;++t)a.push(-1);return r.assert(a.length===e,(()=>"Final length of result must be equal to firstDimension.")),a}calculateOutputIndexRowSplit(e,t,n,r){const s=e.length,a=[];for(let i=0;i<s-1;++i){const s=e[i+1]-e[i];let o=Math.min(r,s),u=t[i];-1===u&&(o=0);for(let e=0;e<o;++e)a.push(u),u+=n;for(let e=0;e<s-o;++e)a.push(-1)}if(s>0&&a.length!==e[s-1])throw new Error("Invalid row split size.");return a}calculateOutputIndexValueRowID(e,t,n,r){const s=e.length,a=[];if(0===s)return[];let i=0,o=e[0];if(o>=t.length)throw new Error(`Got currentValueRowId=${o}, which is not less than ${t.length}`);let u=t[o];a.push(u);for(let l=1;l<s;++l){const s=e[l];if(s===o)u>=0&&(++i,i<r?u+=n:u=-1);else{if(i=0,o=s,s>=t.length)throw new Error(`Got nextValueRowId=${s} which is not less than ${t.length}`);u=t[s]}a.push(u)}if(a.length!==e.length)throw new Error("Invalid row ids.");return a}calculateOutputIndex(e,t,n,r){const s=this.getRowPartitionTensor(e),a=this.getRowPartitionTypeByDimension(e);switch(a){case Or.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(s,t,n,r);case Or.ROW_SPLITS:if(s.length-1>t.length)throw new Error(`Row partition size is greater than output size: ${s.length-1} > ${t.length}`);return this.calculateOutputIndexRowSplit(s,t,n,r);default:throw new Error(`Unsupported partition type: ${Or[a]}`)}}getFirstDimensionSize(){const e=this.rowPartitionValues[0];if(0===this.rowPartitionTypes.length)throw new Error("No row_partition_types given.");const t=this.rowPartitionTypes[0];switch(t){case Or.FIRST_DIM_SIZE:return e[0];case Or.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case Or.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${Or[t]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const e=this.getFirstDimensionSize(),t=this.calculateOutputSize(e),n=new Array(this.raggedRank+1);n[n.length-1]=1;for(let e=n.length-2;e>=0;--e)n[e]=n[e+1]*t[e+1];const s=Dr(t,!1),a=r.getArrayFromDType(this.valuesDType,r.sizeFromShape(s));if(n[0]*t[0]>0){let r=this.calculateFirstParentOutputIndex(e,n[0],t[0]);for(let e=1;e<=this.raggedRank;++e){r=this.calculateOutputIndex(e-1,r,n[e],t[e])}this.setOutput(this.raggedRank,r,a,s)}return[s,a]}setOutput(e,t,n,s){if(0===n.length)return;const a=this.values,i=n;let o=s.slice();o=o.slice(e+1);const u=r.sizeFromShape(o),l=t.length;let h=this.defaultValue;if(h.length!==u&&1!==h.length){const e=this.defaultValueShape;g((()=>{const t=b(h,e),n=x(t,o);h=n.dataSync()}))}let d=0,p=0,c=0;for(let e=0;e<=l;++e){let r=e<l?t[e]:-1;if(r!==c){if(p<c){const e=a.subarray(d*u);Ur(i.subarray(p*u),e,(c-p)*u)}if(e>=l){const e=n.length;r=Math.floor(e/u)}if(r>c)if(1===this.defaultValue.length)i.subarray(c*u,r*u).fill(this.defaultValue[0]),c=r;else for(;r>c;){Ur(i.slice(c*u),h,u),++c}r<0?(d=e+1,p=c):(d=e,p=c,c=p+1)}else++c}}}function Ur(e,t,n){for(let r=0;r<n;r++)e[r]=t[r]}function Dr(e,t){const n=[];for(let r of e){if(r<0){if(!t)throw new Error(`Dimension ${r} must be >= 0`);if(r<-1)throw new Error(`Dimension ${r} must be >= -1`);r=-1}n.push(r)}return n}const Wr=wr((e=>1/Math.sqrt(e)));const Mr=wr((e=>1/(1+Math.exp(-e))));const Vr=wr((e=>Math.sqrt(e))),Gr=br(((e,t)=>{const n=e-t;return n*n}));class Hr{constructor(e,t,n,s,a,i){this.separator=r.encodeString(e),this.nGramWidths=t,this.leftPad=r.encodeString(n),this.rightPad=r.encodeString(s),this.padWidth=a,this.preserveShort=i}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){const n=this.getPadWidth(t);return Math.max(0,e+2*n-t+1)}createNGrams(e,t,n,r,s,a){for(let i=0;i<s;++i){const o=this.getPadWidth(a),u=Math.max(0,o-i),l=Math.max(0,o-(s-(i+1))),h=a-(u+l),d=t+(u>0?0:i-o);let p=0;p+=u*this.leftPad.length;for(let t=0;t<h;++t)p+=e[d+t].length;p+=l*this.rightPad.length;p+=(u+l+h-1)*this.separator.length,n[r+i]=new Uint8Array(p);const c=n[r+i];let f=0;const m=e=>e.forEach((e=>c[f++]=e));for(let e=0;e<u;++e)m(this.leftPad),m(this.separator);for(let t=0;t<h-1;++t)m(e[d+t]),m(this.separator);if(h>0){m(e[d+h-1]);for(let e=0;e<l;++e)m(this.separator),m(this.rightPad)}else{for(let e=0;e<l-1;++e)m(this.rightPad),m(this.separator);m(this.rightPad)}}}compute(e,t){const n=e.length,s=t.length;if(s>0){let e=t[0];if(0!==e)throw new Error(`First split value must be 0, got ${e}`);for(let r=1;r<s;++r){let s=t[r]>=e;if(s=s&&t[r]<=n,!s)throw new Error(`Invalid split value ${t[r]}, must be in [${e}, ${n}]`);e=t[r]}if(e!==n)throw new Error(`Last split value must be data size. Expected ${n}, got ${e}`)}const a=s-1,i=r.getArrayFromDType("int32",s);if(0===n||0===s){const e=new Array(n);for(let e=0;e<=a;++e)i[e]=0;return[e,i]}i[0]=0;for(let e=1;e<=a;++e){const n=t[e]-t[e-1];let r=0;this.nGramWidths.forEach((e=>{r+=this.getNumNGrams(n,e)})),this.preserveShort&&n>0&&0===r&&(r=1),i[e]=i[e-1]+r}const o=new Array(i[a]);for(let n=0;n<a;++n){const r=t[n];let s=i[n];if(this.nGramWidths.forEach((a=>{const i=t[n+1]-t[n],u=this.getNumNGrams(i,a);this.createNGrams(e,r,o,s,u,a),s+=u})),this.preserveShort&&s===i[n]){const a=t[n+1]-t[n];if(0===a)continue;const i=a+2*this.padWidth,u=1;this.createNGrams(e,r,o,s,u,i)}}return[o,i]}}function Xr(e,t,n,r){if(!e.length)return;if(0===t.length){for(let t=0;t<e.length;++t)r.push(e.subarray(t,t+1));return}if(1===t.length){const s=t[0];let a=e.indexOf(s);for(;-1!==a;){const t=e.subarray(0,a);n&&0===t.length||r.push(t),a=(e=e.subarray(a+1)).indexOf(s)}return void(n&&0===e.length||r.push(e))}let s=0;for(let a=0;a<e.length+1;a++)if(a===e.length||-1!==t.indexOf(e[a])){const t=e.subarray(s,a);n&&0===t.length||r.push(t),s=a+1}}const Kr=br(((e,t)=>e-t));const qr=(e,t)=>{const n=t.value-e.value;return 0===n?e.index-t.index:n};function jr(e,t,n=0,s=e.length-1){for(;s>n;){if(s-n>600){const r=s-n+1,a=t-n+1,i=Math.log(r),o=.5*Math.exp(2*i/3),u=.5*Math.sqrt(i*o*(r-o)/r)*Math.sign(a-r/2);jr(e,t,Math.max(n,Math.floor(t-a*o/r+u)),Math.min(s,Math.floor(t+(r-a)*o/r+u)))}const a=e[t];let i=n,o=s;for(r.swap(e,n,t),qr(e[s],a)>0&&r.swap(e,n,s);i<o;){for(r.swap(e,i,o),i++,o--;qr(e[i],a)<0;)i+=1;for(;qr(e[o],a)>0;)o-=1}0===qr(e[n],a)?r.swap(e,n,o):(o+=1,r.swap(e,o,s)),o<=t&&(n=o+1),t<=o&&(s=o-1)}}var Yr={__proto__:null,simpleAbsImpl:function(e){const t=new Float32Array(e.length);for(let n=0;n<e.length;++n)t[n]=Math.abs(e[n]);return t},addImpl:xr,bincountImpl:function(e,t,n,s,a){const i=r.sizeFromShape(s),o=r.makeZerosTypedArray(a,n);for(let n=0;n<e.length;n++){const r=e[n];if(r<0)throw new Error("Input x must be non-negative!");r>=a||(o[r]+=i>0?t[n]:1)}return o},bincountReduceImpl:function(e,t,n,r=!1){const s=e.shape[0],a=e.shape[1],i=o([s,n],t.dtype);for(let o=0;o<s;o++)for(let s=0;s<a;s++){const a=e.get(o,s);if(a<0)throw new Error("Input x must be non-negative!");a>=n||(r?i.set(1,o,a):t.size>0?i.set(i.get(o,a)+t.get(o,s),o,a):i.set(i.get(o,a)+1,o,a))}return i},castImpl:function(e,t,n,s){if("int32"===s){return[t,"int32",Int32Array.from(e)]}if("bool"===s){const s=r.toTypedArray([0],n),[a,i]=br(((e,t)=>e!==t?1:0))(t,[],e,s,"bool");return[i,"bool",a]}throw new Error(`Error in Cast: failed to cast ${n} to ${s}`)},ceilImpl:yr,concatImpl:function(e,t,s,a){const i=r.getArrayFromDType(s,r.sizeFromShape(t));if(a&&"string"!==s){let t=0;e.forEach((e=>{const n=r.sizeFromShape(e.shape);i.set(e.vals,t),t+=n}))}else{let r=0;e.forEach((e=>{const a="string"===s?n.fromUint8ToStringArray(e.vals):e.vals;let o=0;for(let n=0;n<e.shape[0];++n){const s=n*t[1]+r;for(let t=0;t<e.shape[1];++t)i[s+t]=a[o++]}r+=e.shape[1]}))}return i},equalImpl:Ir,expImpl:Sr,expm1Impl:kr,floorImpl:vr,gatherNdImpl:function(e,t,n,r,s,a,i,u,l){const h=o([r,a],n);for(let n=0;n<r;n++){const r=[];let o=0;for(let t=0;t<s;t++){const a=e[n*s+t];o+=a*i[t],r.push(a)}if(o<0||o>=l/a)throw new Error(`Invalid indices: ${r} does not index into ${u}`);for(let e=0;e<a;e++)h.values[n*a+e]=t.get(...t.indexToLoc(o*a+e))}return h},gatherV2Impl:function(e,t,n){const r=o(n,e.dtype);for(let n=0;n<r.size;++n){const s=r.indexToLoc(n).slice(),a=s[0],i=s[2],o=t.locToIndex([a,i]);s[2]=t.values[o];const u=e.locToIndex(s);0<=u&&u<e.values.length&&(r.values[n]=e.values[u])}return r},greaterImpl:Cr,greaterEqualImpl:$r,lessImpl:Rr,lessEqualImpl:Ar,linSpaceImpl:function(e,t,n){const s=(t-e)/(n-1),a=r.makeZerosTypedArray(n,"float32");a[0]=e;for(let e=1;e<a.length;e++)a[e]=a[e-1]+s;return a},logImpl:Tr,maxImpl:function(e,t,n,s){const a=r.getTypedArrayFromDType(s,r.sizeFromShape(n));for(let n=0;n<a.length;++n){const r=n*t;let s=e[r];for(let n=0;n<t;++n){const t=e[r+n];(Number.isNaN(t)||t>s)&&(s=t)}a[n]=s}return a},maximumImpl:Pr,minimumImpl:Nr,multiplyImpl:zr,negImpl:function(e,t,n){const s=r.createScalarValue(-1,n);return zr([],t,s,e,n)},notEqualImpl:Er,prodImpl:function(e,t,s,a){const[i,o]=n.computeOutAndReduceShapes(e,a),u=m(t,"int32"),l=r.makeZerosTypedArray(r.sizeFromShape(i),u),h=r.sizeFromShape(o);for(let e=0;e<l.length;++e){const t=e*h;let n=1;for(let e=0;e<h;++e)n*=s[t+e];l[e]=n}return{outVals:l,outShape:i,outDtype:u}},raggedGatherImpl:function(e,t,n,s,a,i,o,u){if(0===e.length)throw new Error("paramsNestedSplits must be non empty");if(0===t[0].length)throw new Error("Split tensors must not be scalars");if(function(e,t,n){e.forEach(((e,s)=>{if(e<0||e>=n){const a=r.indexToLoc(s,t.length,r.computeStrides(t)).join(",");throw new Error(`indices[${a}] = ${e} is not in [0, ${n})`)}}))}(i,o,t[0][0]-1),0===s.length)throw new Error("params.rank must be nonzero");const l=s[0],{outSplits:h,valueSlices:d,numValues:p}=Fr(i,o,e,l),c=function(e){const t=[];for(let n=0;n<e.length;++n){const s=e[n].length,a=r.getArrayFromDType("int32",s);t.push(a),e[n].forEach(((e,t)=>a[t]=e))}return t}(h),f=_r(n,s,a,d,p);return[c,f[0],f[1]]},raggedRangeImpl:function(e,t,n,s,a,i,o){if(t.length>1)throw new Error("starts must be a scalar or vector");if(a.length>1)throw new Error("limits must be a scalar or vector");if(o.length>1)throw new Error("deltas must be a scalar or vector");const u=0===t.length,l=0===a.length,h=0===o.length,d=[];u||d.push(t[0]),l||d.push(a[0]),h||d.push(o[0]);for(let e=1;e<d.length;++e)if(d[e]!==d[e-1])throw new Error("starts, limits, and deltas must have the same shape");const p=0===d.length?1:d[0],c=r.getArrayFromDType("int32",p+1);c[0]=0;for(let t=0;t<p;++t){const n=u?e[0]:e[t],r=l?s[0]:s[t],a=h?i[0]:i[t];if(0===a)throw new Error("Requires delta != 0");let o;if(a>0&&r<n||a<0&&r>n)o=0;else if(o=Math.ceil(Math.abs((r-n)/a)),o>2147483647)throw new Error("Requires ((limit - start) / delta) <= 2147483647");c[t+1]=c[t]+o}const f=c[p],m=r.getArrayFromDType(n,f);let g=0;for(let t=0;t<p;++t){const n=c[t+1]-c[t];let r=u?e[0]:e[t];const s=h?i[0]:i[t];for(let e=0;e<n;++e)m[g++]=r,r+=s}return[c,m]},raggedTensorToTensorImpl:function(e,t,n,r,s,a,i,o,u,l){return new Lr(e,t,n,r,s,a,i,o,u,l).compute()},rangeImpl:function(e,t,n,s){if(e===t||e<t&&n<0||t<e&&n>1)return r.makeZerosTypedArray(0,s);const a=Math.abs(Math.ceil((t-e)/n)),i=r.makeZerosTypedArray(a,s);t<e&&1===n&&(n=-1),i[0]=e;for(let e=1;e<i.length;e++)i[e]=i[e-1]+n;return i},rsqrtImpl:Wr,scatterImpl:function(e,t,n,r,s,a,i,u,l,h){const d=[r/s,s],p=e.values,c=t.values;if(0===r)return o(n,t.dtype);const f=o(d,t.dtype);"string"==typeof l||"number"==typeof l?f.values.fill(l):"boolean"==typeof l&&f.values.fill(+l);for(let e=0;e<a;e++){const a=[];let o=0;for(let t=0;t<i;t++){const n=p[e*i+t];a.push(n),o+=n*u[t]}if(o<0||o>=r/s)throw new Error(`Invalid indices: ${a} does not index into ${n}`);for(let n=0;n<s;n++)h?f.values[o*s+n]+=c[e*s+n]:f.values[o*s+n]=0===t.rank?c[0]:c[e*s+n]}return f},sigmoidImpl:Mr,sliceImpl:function(e,t,s,a,i){const u=w.isSliceContinous(a,t,s),l=r.sizeFromShape(s),h=r.computeStrides(a);if(u){const n=w.computeFlatOffset(t,h);return"string"===i?e.slice(n,n+l):e.subarray(n,n+l)}const d="string"===i?n.fromUint8ToStringArray(e):e,p=o(a,i,d),c=o(s,i);for(let e=0;e<c.size;++e){const n=c.indexToLoc(e),r=n.map(((e,n)=>e+t[n]));c.set(p.get(...r),...n)}return"string"===i?n.fromStringArrayToUint8(c.values):c.values},sparseFillEmptyRowsImpl:function(e,t,s,a,i,o,u){const l=t[0],h=o[0],d=new Array(h),p=new Array(l),c=t[1];if(0===h){if(0!==l)throw new Error(n.getSparseFillEmptyRowsIndicesDenseShapeMismatch(l));return[r.getArrayFromDType(s,0),[0,c],r.getArrayFromDType(i,0),d,p]}let f=!0,m=0;const g=new Array(h).fill(0);for(let t=0;t<l;++t){const r=e[t*c];if(r<0)throw new Error(n.getSparseFillEmptyRowsNegativeIndexErrorMessage(t,r));if(r>=h)throw new Error(n.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(t,r,h));++g[r],f=f&&r>=m,m=r}let b=!0;for(let e=0;e<h;++e){const t=0===g[e];d[e]=t,b=b&&!t,g[e]=Math.max(g[e],1),e>0&&(g[e]+=g[e-1])}if(b&&f){const t=e,n=a;for(let e=0;e<l;++e)p[e]=e;return[t,[l,c],n,d,p]}{const t=g[h-1],n=r.getArrayFromDType(s,t*c),o=r.getArrayFromDType(i,t),f=new Array(h).fill(0);for(let t=0;t<l;++t){const r=e[t*c],s=f[r],i=(0===r?0:g[r-1])+s;f[r]++;for(let r=0;r<c;++r)n[i*c+r]=e[t*c+r];o[i]=a[t],p[t]=i}for(let e=0;e<h;++e){if(0===f[e]){const t=0===e?0:g[e-1];n[t*c+0]=e;for(let e=1;e<c;++e)n[t*c+e]=0;o[t]=u}}return[n,[t,c],o,d,p]}},sparseReshapeImpl:function(e,t,s,a,i){const o=r.sizeFromShape(a),u=t[0],l=i.length,h=[];let d=1,p=-1;for(let e=0;e<l;++e){const t=i[e];if(-1===t){if(-1!==p)throw new Error(n.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(p,e));p=e,h.push(1)}else{if(t<0)throw new Error(n.getSparseReshapeNegativeOutputDimErrorMessage(e,t));d*=t,h.push(t)}}if(-1!==p){if(d<=0)throw new Error(n.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage());const e=Math.trunc(o/d);if(d*e!==o)throw new Error(n.getSparseReshapeInputOutputMultipleErrorMessage(a,h));h[p]=e}if(r.sizeFromShape(h)!==o)throw new Error(n.getSparseReshapeInputOutputMismatchErrorMessage(a,h));const c=a.length,f=[];if(c>0){f[c-1]=1;for(let e=c-2;e>=0;--e)f[e]=f[e+1]*a[e+1]}const m=[];if(l>0){m[l-1]=1;for(let e=l-2;e>=0;--e)m[e]=m[e+1]*h[e+1]}const g=r.getArrayFromDType(s,u*l);for(let t=0;t<u;++t){let n=0;for(let r=0;r<c;++r)n+=e[t*c+r]*f[r];for(let e=0;e<l;++e)g[t*l+e]=Math.trunc(n/m[e]),n%=m[e]}return[g,[u,l],h]},sparseSegmentReductionImpl:function(e,t,s,a,i,o=!1,u=0){const l=a.length,h=[t[0],e.length/t[0]],d=h[1],p=l>0?i[l-1]+1:0;if(p<0)throw new Error(n.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());const c=t.slice();c[0]=p;const f=c.reduce(((e,t)=>e*t),1),m=r.getArrayFromDType(s,f);if(0===l)return p>0&&m.fill(u),[m,c];if(p<=0)throw new Error(n.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let g=0,b=1,x=0,w=i[g];for(;;){let t=0;if(b<l){if(t=i[b],w===t){++b;continue}if(w>=t)throw new Error(n.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage())}if(w<0||w>=p)throw new Error(n.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(w,p));w>x&&m.fill(u,x*d,w*d);for(let t=g;t<b;++t){const r=a[t];if(r<0||r>=h[0])throw new Error(n.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(t,a[t],h[0]));for(let t=0;t<d;t++)m[w*d+t]+=e[r*d+t]}if(o)for(let e=0;e<d;e++)m[w*d+e]/=b-g;if(g=b,++b,x=w+1,w=t,b>l)break}return x<p&&m.fill(u,x*d,p*d),[m,c]},sqrtImpl:Vr,squaredDifferenceImpl:Gr,stridedSliceImpl:function(e,t,n,r){const s=o(e,t.dtype);for(let e=0;e<s.size;e++){const a=s.indexToLoc(e),i=new Array(a.length);for(let e=0;e<i.length;e++)i[e]=a[e]*n[e]+r[e];s.set(t.get(...i),...a)}return s},stringNGramsImpl:function(e,t,n,r,s,a,i,o){return new Hr(n,r,s,a,i,o).compute(e,t)},stringSplitImpl:function(e,t,n){const s=e.length,a=[];let i=0,o=0;const u=new Array(s);for(let r=0;r<s;++r){const s=a.length;Xr(e[r],t,n,a);const l=a.length-s;u[r]=l,i+=l,o=Math.max(o,l)}const l=r.getArrayFromDType("int32",2*i),h=new Array(i),d=[s,o];let p=0;for(let e=0;e<s;++e)for(let t=0;t<u[e];++t)l[2*p]=e,l[2*p+1]=t,h[p]=a[p],++p;return[l,h,d]},stringToHashBucketFastImpl:function(e,t){const n=r.getArrayFromDType("int32",e.length);for(let s=0;s<e.length;++s)n[s]=r.fingerPrint64(e[s]).modulo(t).getLowBitsUnsigned();return n},subImpl:Kr,tileImpl:function(e,t){const n=new Array(e.rank);for(let r=0;r<n.length;r++)n[r]=e.shape[r]*t[r];const r=o(n,e.dtype);for(let t=0;t<r.values.length;++t){const n=r.indexToLoc(t),s=new Array(e.rank);for(let t=0;t<s.length;t++)s[t]=n[t]%e.shape[t];const a=e.locToIndex(s);r.values[t]=e.values[a]}return r},topKImpl:function(e,t,n,s,a){const i=t[t.length-1],[u,l]=[e.length/i,i],h=r.getTypedArrayFromDType(n,u*s),d=r.getTypedArrayFromDType("int32",u*s);for(let t=0;t<u;t++){const n=t*l,r=e.subarray(n,n+l);let i=new Array(r.length);r.forEach(((e,t)=>i[t]={value:e,index:t})),s<i.length&&(jr(i,s),i=i.slice(0,s)),a&&i.sort(qr);const o=t*s,u=h.subarray(o,o+s),p=d.subarray(o,o+s);for(let e=0;e<s;e++)u[e]=i[e].value,p[e]=i[e].index}const p=t.slice();return p[p.length-1]=s,[o(p,n,h),o(p,"int32",d)]},transposeImpl:function(e,t,n,s,a){const i=t.length,o=r.sizeFromShape(t),u=r.computeStrides(t),l=r.computeStrides(a),h=r.getTypedArrayFromDType(n,r.sizeFromShape(a));for(let t=0;t<o;++t){const n=r.indexToLoc(t,i,u),a=new Array(n.length);for(let e=0;e<a.length;e++)a[e]=n[s[e]];h[r.locToIndex(a,i,l)]=e[t]}return h},uniqueImpl:function(e,t,n,s){const a=r.parseAxisParam(t,n)[0],i=[1,n[0],1];for(let e=0;e<a;e++)i[0]*=n[e];i[1]=n[a];for(let e=a+1;e<n.length;e++)i[2]*=n[e];const o={},u=new Int32Array(n[a]),l=new y(i,s,e),h=[],d=1===i[0]&&1===i[2];for(let t=0;t<n[a];t++){let n;if(d)n=e[t].toString();else{const e=[];for(let n=0;n<i[0];n++)for(let r=0;r<i[2];r++)e.push(l.get(n,t,r));n=e.join(",")}if(void 0!==o[n])u[t]=o[n];else{const e=Object.keys(o).length;o[n]=e,u[t]=e,h.push(t)}}const p=i.slice();p[1]=Object.keys(o).length;const c=new y(p,s);h.forEach(((e,t)=>{for(let n=0;n<i[0];n++)for(let r=0;r<i[2];r++)c.set(l.get(n,e,r),n,t,r)}));const f=n.slice();return f[a]=p[1],{outputValues:c.values,outputShape:f,indices:u}}};const{addImpl:Qr,castImpl:Zr,ceilImpl:Jr,concatImpl:es,equalImpl:ts,expImpl:ns,expm1Impl:rs,floorImpl:ss,gatherNdImpl:as,gatherV2Impl:is,greaterEqualImpl:os,greaterImpl:us,lessEqualImpl:ls,lessImpl:hs,logImpl:ds,maxImpl:ps,maximumImpl:cs,minimumImpl:fs,multiplyImpl:ms,negImpl:gs,notEqualImpl:bs,prodImpl:xs,rangeImpl:ws,rsqrtImpl:ys,scatterImpl:Is,simpleAbsImpl:Ss,sliceImpl:ks,stridedSliceImpl:vs,stringNGramsImpl:Cs,subImpl:$s,tileImpl:Rs,topKImpl:As,transposeImpl:Ts,uniqueImpl:Ps}=Yr,Ns={kernelName:I,backendName:"webgpu",kernelFunc:mr({opType:Ln.ABS,cpuKernelImpl:Ss})},zs={kernelName:S,backendName:"webgpu",kernelFunc:mr({opType:Ln.ACOS})},Es={kernelName:k,backendName:"webgpu",kernelFunc:mr({opType:Ln.ACOSH})},Fs={kernelName:v,backendName:"webgpu",kernelFunc:gr({opType:Tn.ADD,cpuKernelImpl:Qr,supportsComplex:!0})};class Bs{constructor(e){this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e[0],this.variableNames=e.map(((e,t)=>`T${t}`)),this.dispatchLayout=In(this.outputShape),this.dispatch=bn(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.shaderKey="addN"}getUserCode(){const e=[];this.variableNames.forEach((t=>{e.push(`let v${t} = get${t}ByOutputCoords(coords);`)}));const t=this.variableNames.map((e=>`v${e}`)).join(" + ");return`\n      ${on("index")} {\n        for (var i = 0; i < ${this.workPerThread}; i = i + 1) {\n          let flatIndex = index * ${this.workPerThread} + i;\n          if (flatIndex < uniforms.size) {\n            let coords = getCoordsFromIndex(flatIndex);\n            ${e.join("\n        ")}\n            setOutputAtIndex(flatIndex, ${t});\n          }\n        }\n      }\n    `}}const _s={kernelName:C,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,r=t;if(1===r.length)return hr({inputs:{x:r[0]},backend:n});const s=r.map((e=>e.dtype)).reduce(((e,t)=>m(e,t))),a=r.map((e=>e.shape)),i=new Bs(a);return n.runWebGPUProgram(i,r,s)}};class Os{constructor(e,t){this.variableNames=["A"],this.workgroupSize=[16,16,1];const n=new Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[t[r]];this.outputShape=n,this.dispatchLayout={x:[0],y:[1]},this.dispatch=bn(this.dispatchLayout,this.outputShape,this.workgroupSize,[1,1,1]),this.shaderKey="transposeShared"}getUserCode(){r.assert(this.workgroupSize[0]===this.workgroupSize[1],(()=>`Must be a square tile, current tile shape is ${this.workgroupSize[0]} x ${this.workgroupSize[1]}`));const e=this.workgroupSize[0];return`\n      var<workgroup> tile : array<array<f32, ${this.workgroupSize[0]+1}>, ${this.workgroupSize[0]}>;\n      ${on()} {\n        var x = i32(workgroupId.x) * ${e} + i32(localId.x);\n        var y = i32(workgroupId.y) * ${e} + i32(localId.y);\n        let width = uniforms.outShape[0];\n        let height = uniforms.outShape[1];\n        if (x < width && y < height) {\n          tile[localId.y][localId.x] = f32(A[y * width + x]);\n        }\n        workgroupBarrier();\n\n        x = i32(workgroupId.y) * ${e} + i32(localId.x);\n        y = i32(workgroupId.x) * ${e} + i32(localId.y);\n        if (x < height && y < width) {\n          setOutputAtIndex((y * height + x), tile[localId.x]\n            [localId.y]);\n        }\n      }\n    `}}class Ls{constructor(e,t){this.variableNames=["A"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0;const n=new Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[t[r]];this.outputShape=n,this.dispatchLayout=In(this.outputShape),this.dispatch=bn(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.newDim=t,this.shaderKey=`transpose_${t}`}getUserCode(){const e=sn(this.outputShape.length),t=function(e){const t=e.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);const n=new Array(t);for(let t=0;t<e.length;t++)n[e[t]]=`resRC.${an(t)}`;return n.join()}(this.newDim);return`\n      ${on("index")} {\n        for(var i = 0; i < ${this.workPerThread}; i = i + 1) {\n          let flatIndex = index * ${this.workPerThread} + i;\n          if(flatIndex < uniforms.size) {\n            let resRC = getCoordsFromIndex(flatIndex);\n            setOutputAtIndex(flatIndex, A[getIndexFromCoords${this.outputShape.length}D(\n              ${e}(${t}), uniforms.aShape)]);\n          }\n        }\n      }\n    `}}function Us(e){const{inputs:t,backend:n,attrs:s}=e,{x:a}=t,{perm:i}=s,o=n,u=a.shape.length,l=new Array(u);for(let e=0;e<l.length;e++)l[e]=a.shape[i[e]];if(n.shouldExecuteOnCPU([a])){const e=o.tensorMap.get(a.dataId).values,t=Ts(e,a.shape,a.dtype,i,l);return n.makeTensorInfo(l,a.dtype,t)}if(2===a.shape.length&&r.arraysEqual(i,[1,0])){const e=new Os(a.shape,i);return o.runWebGPUProgram(e,[a],a.dtype)}const h=new Ls(a.shape,i);return o.runWebGPUProgram(h,[a],a.dtype)}const Ds={kernelName:$,backendName:"webgpu",kernelFunc:Us};class Ws{constructor(e,t){this.workgroupSize=[64,1,1],this.variableNames=["x"],this.uniforms="reduceSize : i32,",this.size=!0,this.inputShape=[e.batchSize,e.inSize];const[r]=n.computeOutAndReduceShapes(this.inputShape,[1]);this.outputShape=0===r.length?[1]:r,this.dispatchLayout=In(this.outputShape),this.dispatch=bn(this.dispatchLayout,this.outputShape,[1,1,1]),this.reduceType=t,this.shaderKey=`reduce_${t}`}getUserCode(){let e="",t="0.0";const n=this.workgroupSize[0];"min"===this.reduceType||"max"===this.reduceType?(e=`\n         if (isnan(candidate)) {\n          bestValue = uniforms.NAN;\n         } else if (!isnan(bestValue) && candidate ${"min"===this.reduceType?"<":">"} bestValue)\n           {  bestValue = candidate; }`,t="f32(x[offset])"):"sum"===this.reduceType||"mean"===this.reduceType?e=" bestValue = bestValue + candidate; ":"prod"===this.reduceType?(e=" bestValue = bestValue * candidate; ",t="1.0"):"all"===this.reduceType?(e=" bestValue = f32(bestValue >= 1.0 && candidate >= 1.0); ",t="1.0"):"any"===this.reduceType&&(e=" bestValue = f32(bestValue >= 1.0 || candidate >= 1.0); ",t="0.0");const r="mean"===this.reduceType?"setOutputAtIndex(outputIndex, bestValue / f32(uniforms.reduceSize));":"setOutputAtIndex(outputIndex, bestValue);";return`\n       fn DIV_CEIL(a : u32, b : u32) -> u32 {\n        return ((a - 1u) / b + 1u);\n       }\n\n       ${`\n         var<workgroup> xBestValues : array<f32, ${n}>;\n       `}\n       fn getOffset(outputIndex : i32) -> i32 {\n         let outputCoords = getCoordsFromIndex(outputIndex);\n         let offset = ${1===this.outputShape.length?"outputCoords":"outputCoords[0]"} * uniforms.reduceSize;\n          return offset;\n       }\n       ${on("index")} {\n         let outputIndex = index / ${n};\n         let offset = getOffset(outputIndex);\n         var bestValue = ${t};\n         let Length = uniforms.reduceSize;\n         let WorkPerThread = DIV_CEIL(u32(Length), ${n}u);\n         for (var k = i32(localId.x); k < Length && outputIndex < uniforms.size;\n             k = k + ${n}) {\n           let candidate = f32(x[offset + k]);\n           ${e}\n         }\n         xBestValues[localId.x] = bestValue;\n         workgroupBarrier();\n\n         var reduceSize = min(u32(Length), ${n}u);\n         for (var currentSize = reduceSize / 2u; reduceSize > 1u;\n             currentSize = reduceSize / 2u) {\n           let interval = DIV_CEIL(reduceSize, 2u);\n           if (localId.x < currentSize) {\n            let candidate = xBestValues[localId.x + interval];\n            ${e}\n            xBestValues[localId.x] = bestValue;\n           }\n           reduceSize = interval;\n           workgroupBarrier();\n         }\n\n         if (localId.x == 0u && outputIndex < uniforms.size) {\n          ${r}\n        }\n       }\n     `}}function Ms(e,t,s,a,i){const o=e.shape.length,u=[],l=r.parseAxisParam(t,e.shape);let h=l;const d=n.getAxesPermutation(h,o);let p=e;null!=d&&(p=Us({inputs:{x:e},attrs:{perm:d},backend:i}),h=n.getInnerMostAxes(h.length,o),u.push(p)),n.assertAxesAreInnerMostDims(a,h,o);const[c,f]=n.computeOutAndReduceShapes(p.shape,h);let m,g=c;if(s&&(g=n.expandShapeToKeepDim(c,l)),"max"!==a&&"prod"!==a||!i.shouldExecuteOnCPU([p])){const t=r.sizeFromShape(f),n={windowSize:t,inSize:t,batchSize:r.sizeFromShape(p.shape)/t,outSize:1},s="mean"===a?"float32":R(e.dtype),o=[{type:"int32",data:[t]}],l=new Ws(n,a),h=i.runWebGPUProgram(l,[p],s,o);u.push(h),m=sr({inputs:{x:h},attrs:{shape:g},backend:i})}else{const t=i.tensorMap.get(p.dataId).values;switch(a){case"max":const n=ps(t,r.sizeFromShape(f),g,e.dtype);m=i.makeTensorInfo(g,e.dtype,n);break;case"prod":const{outVals:s,outShape:o,outDtype:u}=xs(p.shape,p.dtype,t,h);m=i.makeTensorInfo(o,u,s);break;default:throw new Error(`${a} CPU implementation is not yet supported.`)}}return u.forEach((e=>i.disposeData(e.dataId))),m}const Vs={kernelName:A,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{keepDims:a,axis:i}=r;return Ms(s,i,a,"all",n)}};const Gs={kernelName:T,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{keepDims:a,axis:i}=r;return Ms(s,i,a,"any",n)}};class Hs{constructor(e,t,s){this.workgroupSize=[64,1,1],this.variableNames=["x"],this.uniforms="infinityValue : f32,",this.size=!0;const a=[t];this.op="min"===s?"<":">";const[i,o]=n.computeOutAndReduceShapes(e,a);this.outputShape=0===i.length?[1]:i,this.dispatchLayout=In(this.outputShape),r.sizeFromShape(o)<32||r.sizeFromShape(i)>1e3?(this.type="plain",this.dispatch=bn(this.dispatchLayout,this.outputShape,this.workgroupSize)):(this.type="shared",this.dispatch=bn(this.dispatchLayout,this.outputShape,[1,1,1])),this.inputShape=e,this.shaderKey=`argMinMax_${this.op}_${this.type}`}getUserCode(){const e=this.workgroupSize[0],t=()=>1===this.inputShape.length?"uniforms.xShape":`uniforms.xShape.${an(this.inputShape.length-1)}`,n=()=>{let e="";if(1===this.outputShape.length)1!==this.inputShape.length&&(e+="outputCoords,");else for(let t=0;t<this.outputShape.length;t++)e+=`outputCoords.${an(t)},`;return e};if("shared"===this.type){return`\n      fn DIV_CEIL(a : u32, b : u32) -> u32 {\n        return ((a - 1u) / b + 1u);\n      }\n\n      ${`\n      var<workgroup> xBestIndices : array<i32, ${e}>;\n      var<workgroup> xBestValues : array<f32, ${e}>;\n    `}\n\n      ${on("index")} {\n        let outputIndex = index / ${e};\n        let reduceLength = ${t()};\n\n        var bestIndex = i32(localId.x);\n        var bestValue = uniforms.infinityValue;\n        let outputCoords = getCoordsFromIndex(outputIndex);\n        for (var k = i32(localId.x); k < reduceLength && outputIndex < uniforms.size;\n            k = k + ${e}) {\n          let candidate = getX(${n()} k);\n          if (!isnan(candidate) && candidate ${this.op} bestValue) {\n            bestValue = candidate;\n            bestIndex = k;\n          }\n        }\n        xBestValues[localId.x] = bestValue;\n        xBestIndices[localId.x] = bestIndex;\n        workgroupBarrier();\n\n        var reduceSize = min(u32(reduceLength), ${e}u);\n        for (var currentSize = reduceSize / 2u; reduceSize > 1u;\n            currentSize = reduceSize / 2u) {\n          let interval = DIV_CEIL(reduceSize, 2u);\n          if (localId.x < currentSize) {\n            let candidate = xBestValues[localId.x + interval];\n            if (candidate ${this.op} bestValue) {\n              bestValue = candidate;\n              xBestValues[localId.x] = bestValue;\n              xBestIndices[localId.x] = xBestIndices[localId.x + interval];\n            }\n          }\n          reduceSize = interval;\n          workgroupBarrier();\n        }\n\n        if (localId.x == 0u && outputIndex < uniforms.size) {\n          setOutputAtIndexI32(outputIndex, xBestIndices[localId.x]);\n        }\n      }\n    `}return`\n      ${on("index")} {\n        if (index < uniforms.size) {\n          let outputCoords = getCoordsFromIndex(index);\n          var bestIndex = 0;\n          var bestValue = getX(${n()} 0);\n          let reduceLength = ${t()};\n          for (var i = 1; i < reduceLength; i++) {\n            let candidate = getX(${n()} i);\n            if (candidate ${this.op} bestValue) {\n              bestValue = candidate;\n              bestIndex = i;\n            }\n          }\n          setOutputAtIndexI32(index, bestIndex);\n        }\n      }\n      `}}const Xs={kernelName:P,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:s,attrs:a}=e,{x:i}=t,{axis:o}=a;let u=r.parseAxisParam(o,i.shape);const l=n.getAxesPermutation(u,i.shape.length);let h=i;const d=[];null!=l&&(h=Us({inputs:{x:i},backend:s,attrs:{perm:l}}),d.push(h),u=n.getInnerMostAxes(u.length,h.shape.length)),n.assertAxesAreInnerMostDims("argMax",[u[0]],h.shape.length);const p=new Hs(h.shape,u[0],"max"),c=[{type:"float32",data:[Number.NEGATIVE_INFINITY]}],f=s.runWebGPUProgram(p,[h],"int32",c);return d.forEach((e=>s.disposeData(e.dataId))),f}};const Ks={kernelName:N,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:s,attrs:a}=e,{x:i}=t,{axis:o}=a;let u=r.parseAxisParam(o,i.shape);const l=n.getAxesPermutation(u,i.shape.length);let h=i;const d=[];null!=l&&(h=Us({inputs:{x:i},backend:s,attrs:{perm:l}}),d.push(h),u=n.getInnerMostAxes(u.length,h.shape.length)),n.assertAxesAreInnerMostDims("argMin",[u[0]],h.shape.length);const p=new Hs(h.shape,u[0],"min"),c=[{type:"float32",data:[Number.POSITIVE_INFINITY]}],f=s.runWebGPUProgram(p,[h],"int32",c);return d.forEach((e=>s.disposeData(e.dataId))),f}},qs={kernelName:z,backendName:"webgpu",kernelFunc:mr({opType:Ln.ASIN})},js={kernelName:E,backendName:"webgpu",kernelFunc:mr({opType:Ln.ASINH})},Ys={kernelName:F,backendName:"webgpu",kernelFunc:mr({opType:Ln.ATAN})},Qs={kernelName:B,backendName:"webgpu",kernelFunc:gr({opType:Tn.ATAN2})},Zs={kernelName:_,backendName:"webgpu",kernelFunc:mr({opType:Ln.ATANH})};class Js{constructor(e,t){this.variableNames=["x"],this.uniforms="stride : vec2<i32>, pad : vec2<i32>, dilation : vec2<i32>, convDims : vec2<i32>, filterDims : vec2<i32>,",this.workgroupSize=[128,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=In(this.outputShape),this.dispatch=bn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey=`pool2D_${t}`,this.poolType=t}getUserCode(){let e="resultValue = max(value, resultValue);";"avg"===this.poolType&&(e="resultValue = resultValue + value; count = count + 1.0;");let t="resultValue";"avg"===this.poolType&&(t="resultValue / max(count, 1.0)");return`\n      ${on("index")} {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n          let batch = coords[0];\n          let xRCCorner = vec2<i32>(coords.yz) * uniforms.stride - uniforms.pad;\n          let xRCorner = xRCCorner.x;\n          let xCCorner = xRCCorner.y;\n\n          var resultValue = ${"avg"===this.poolType?"0.0":"-1.0 / pow(10.0, -20.0)"};\n          var count = 0.0;\n\n          for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + uniforms.dilation.x) {\n            let xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= uniforms.convDims.x) {\n              continue;\n            }\n\n            for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + uniforms.dilation.y) {\n              let xC = xCCorner + wC;\n              if (xC < 0 || xC >= uniforms.convDims.y) {\n                continue;\n              }\n\n              let value = getX(batch, xR, xC, coords[3]);\n              ${e}\n            }\n          }\n\n          setOutputAtIndex(index, ${t});\n        }\n      }\n    `}}class ea{constructor(e){this.variableNames=["x"],this.uniforms="stride : vec2<i32>,",this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=In(this.outputShape),this.dispatch=bn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="poolWithFilterSizeEqualsOne"}getUserCode(){return`\n      ${on("index")} {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let batch = coords[0];\n          let d = coords[3];\n\n          let xRCCorner = coords.yz * uniforms.stride;\n          let xRCorner = xRCCorner.x;\n          let xCCorner = xRCCorner.y;\n\n          let value = getX(batch, xRCorner, xCCorner, d);\n          setOutputAtIndex(index, value);\n        }\n      }\n    `}}function ta(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{reductionIndices:a,keepDims:i}=r;return Ms(s,a,i,"max",n)}const na={kernelName:O,backendName:"webgpu",kernelFunc:ta};function ra(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{keepDims:a,axis:i}=r;return Ms(s,i,a,"mean",n)}const sa={kernelName:L,backendName:"webgpu",kernelFunc:ra};function aa(e,t,n,s){if(1===t.filterWidth&&1===t.filterHeight&&r.arraysEqual(t.inShape,t.outShape))return hr({inputs:{x:e},backend:s});if(t.filterWidth===t.inWidth&&t.filterHeight===t.inHeight&&1===t.batchSize&&"VALID"===t.padInfo.type){const a=e.shape.length,i=sr({inputs:{x:e},backend:s,attrs:{shape:[e.shape[a-3]*e.shape[a-2],e.shape[a-1]]}});let o;"avg"===n?o=ra({inputs:{x:i},backend:s,attrs:{axis:0,keepDims:!1}}):(r.assert("max"===n,(()=>`Invalid pool type ${n}`)),o=ta({inputs:{x:i},backend:s,attrs:{reductionIndices:0,keepDims:!1}}));const u=sr({inputs:{x:o},backend:s,attrs:{shape:t.outShape}});return s.disposeData(i.dataId),s.disposeData(o.dataId),u}let a;const i=[{type:"int32",data:[t.strideHeight,t.strideWidth]}];return 1===t.filterHeight&&1===t.filterWidth?a=new ea(t):("avg"===n?a=new Js(t,"avg"):(r.assert("max"===n,(()=>`Invalid pool type ${n}`)),a=new Js(t,"max")),i.push({type:"int32",data:[t.padInfo.top,t.padInfo.left]},{type:"int32",data:[t.dilationHeight,t.dilationWidth]},{type:"int32",data:[t.inHeight,t.inWidth]},{type:"int32",data:[t.effectiveFilterHeight,t.effectiveFilterWidth]})),s.runWebGPUProgram(a,[e],e.dtype,i)}const ia={kernelName:U,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:r,attrs:s}=e,{x:a}=t,{filterSize:i,strides:o,pad:u,dimRoundingMode:l}=s;return aa(a,n.computePool2DInfo(a.shape,i,o,1,u,l),"avg",r)}};class oa{constructor(e){this.variableNames=["dy"],this.uniforms="stride : vec2<i32>, pads : vec2<i32>, dilation : vec2<i32>, filterDims : vec2<i32>,\n       outHeight : i32, outWidth : i32, avgMultiplier : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=In(this.outputShape),this.dispatch=bn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="avg_pool2d_backprop"}getUserCode(){return`\n      ${on("index")} {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let batch = coords[0];\n        let d = coords[3];\n\n        let dyRCCorner = vec2<i32>(coords.yz) - uniforms.pads;\n        let dyRCorner = dyRCCorner.x;\n        let dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        var dotProd = 0.0;\n        for (var wR = 0; wR < uniforms.filterDims[0]; wR = wR + uniforms.dilation[0]) {\n          let dyR = f32(dyRCorner + wR) / f32(uniforms.stride[0]);\n\n          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {\n            continue;\n          }\n          let idyR = i32(dyR);\n\n          for (var wC = 0; wC < uniforms.filterDims[1]; wC = wC + uniforms.dilation[1]) {\n            let dyC = f32(dyCCorner + wC) / f32(uniforms.stride[1]);\n\n            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {\n              continue;\n            }\n            let idyC = i32(dyC);\n\n            let dyValue = getDy(batch, idyR, idyC, d);\n\n            dotProd = dotProd + dyValue * uniforms.avgMultiplier;\n          }\n        }\n        setOutputAtIndex(index, dotProd);\n      }\n    }\n    `}}const ua={kernelName:D,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:r,attrs:s}=e,{dy:a,input:i}=t,o=i;vn([a,i],"avgPoolGrad");const{filterSize:u,strides:l,pad:h}=s,d=n.computePool2DInfo(o.shape,u,l,1,h),p=new oa(d),c=1/(d.filterHeight*d.filterWidth),f=[{type:"int32",data:[d.strideHeight,d.strideWidth]},{type:"int32",data:[d.effectiveFilterHeight-1-d.padInfo.top,d.effectiveFilterWidth-1-d.padInfo.left]},{type:"int32",data:[d.dilationHeight,d.dilationWidth]},{type:"int32",data:[d.effectiveFilterHeight,d.effectiveFilterWidth]},{type:"int32",data:[d.outHeight]},{type:"int32",data:[d.outWidth]},{type:"float32",data:[c]}];return r.runWebGPUProgram(p,[a],o.dtype,f)}};const la={kernelName:W,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{a:s,b:a}=t,{transposeA:i,transposeB:o}=r;return ir({a:s,b:a,transposeA:i,transposeB:o,backend:n})}};class ha{constructor(e,t){this.variableNames=["source"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.rank=t.length,this.dispatchLayout=In(this.outputShape),this.dispatch=bn(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.start=e,this.uniforms=`start : ${sn(e.length)}, `,this.shaderKey="slice"}getUserCode(){const e=sn(this.rank),t=function(e){if(1===e)return"sourceLoc";if(e<=6)return da.slice(0,e).map((e=>`sourceLoc.${e}`)).join(",");throw Error(`Slicing for rank ${e} is not yet supported`)}(this.rank);let n;n=1===this.start.length?this.outputShape.map(((e,t)=>"sourceLoc = uniforms.start + coords;")):this.outputShape.map(((e,t)=>`sourceLoc.${da[t]} = uniforms.start.${an(t)} + coords.${da[t]};`));return`\n      ${on("index")} {\n        if (index < uniforms.size) {\n          var sourceLoc : ${e};\n          let coords = getCoordsFromIndex(index);\n          ${n.join("\n")}\n          setOutputAtIndex(index, getSource(${t}));\n        }\n      }\n    `}}const da=["x","y","z","w","u","v"];function pa(e){const{inputs:t,backend:n,attrs:s}=e,{x:a}=t,{begin:i,size:o}=s,[u,l]=w.parseSliceParams(a,i,o);if(w.assertParamsValid(a,u,l),n.shouldExecuteOnCPU([a])||"string"===a.dtype){const e=n.tensorMap.get(a.dataId),t=ks(e.values,u,l,a.shape,a.dtype);return n.makeTensorInfo(l,a.dtype,t)}if(0===r.sizeFromShape(l))return n.makeTensorInfo(l,a.dtype,[]);const h=new ha(u,l),d=[{type:"int32",data:u}];return n.runWebGPUProgram(h,[a],a.dtype,d)}const ca={kernelName:M,backendName:"webgpu",kernelFunc:pa},fa={kernelName:V,backendName:"webgpu",kernelFunc:e=>{const{inputs:t,backend:s,attrs:a}=e,{x:i}=t,{blockShape:o,crops:u}=a;r.assert(i.shape.length<=4,(()=>"batchToSpaceND for rank > 4 with a WebGPU backend not implemented yet"));const l=o.reduce(((e,t)=>e*t)),h=n.getReshaped(i.shape,o,l),d=n.getPermuted(h.length,o.length),p=n.getReshapedPermuted(i.shape,o,l),c=n.getSliceBeginCoords(u,o.length),f=n.getSliceSize(p,u,o.length),m=[],g=sr({inputs:{x:i},backend:s,attrs:{shape:h}}),b=Us({inputs:{x:g},backend:s,attrs:{perm:d}}),x=sr({inputs:{x:b},backend:s,attrs:{shape:p}}),w=pa({inputs:{x:x},backend:s,attrs:{begin:c,size:f}});return m.push(g),m.push(b),m.push(x),m.forEach((e=>s.disposeData(e.dataId))),w}},ma=`\n  fn bincount_write(index: i32, value: f32) {\n    ${nn("&result[index]","value","float32")}\n  }\n`;class ga{constructor(e,t,n=!1){this.outputShape=[],this.variableNames=["x"],this.uniforms="binCountSize : i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.hasWeights=!0,this.binaryOutput=!1,this.outputShape=e,this.rank=e.length,this.dispatchLayout=In(this.outputShape),this.dispatch=bn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.binaryOutput=n,n&&(this.atomic=!1),this.hasWeights=t,this.hasWeights&&this.variableNames.push("w"),this.shaderKey=`bincount_${this.hasWeights}_${this.binaryOutput}_${this.rank}`}getUserCode(){return`\n    ${this.binaryOutput?"\n  fn bincount_write(index: i32, value: f32) {\n    atomicStore(&result[index], bitcast<i32>(value));\n  }\n":ma}\n  ${on("index")} {\n    ${1===this.rank?`if (index < uniforms.xShape) {\n      let indexVal = i32(getX(index));\n      if (indexVal < uniforms.binCountSize) {\n        let value = ${this.binaryOutput?1:this.hasWeights?"getW(index)":"1."};\n        bincount_write(indexVal, value);\n      }\n    }`:`let coord = getCoordsFromIndex(index);\n    if (coordsInBounds2D(coord, uniforms.xShape)) {\n      let indexVal = i32(getX(coord[0], coord[1]));\n      if (indexVal < uniforms.binCountSize) {\n        let value = ${this.binaryOutput?1:this.hasWeights?"getW(coord[0], coord[1])":"1."};\n        bincount_write(coord.x * uniforms.binCountSize + indexVal, value);\n      }\n    }`}\n  }\n  `}}const ba={kernelName:G,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:a,weights:i}=t,{size:o}=s,u=r.sizeFromShape(a.shape),l=r.sizeFromShape(i.shape)>0,h=[o],d=i.dtype,p=nr({backend:n,attrs:{shape:h,value:0,dtype:d}}),c=new ga([u],l),f=[{type:"int32",data:[o]}],m=l?[a,i]:[a];return n.runWebGPUProgram(c,m,d,f,p)}},xa=gr({opType:Tn.NOT_EQUAL,dtype:"bool",cpuKernelImpl:bs}),wa={kernelName:H,backendName:"webgpu",kernelFunc:xa};function ya(e){const{inputs:t,backend:n}=e,{input:r}=t;return hr({inputs:{x:n.tensorMap.get(r.dataId).complexTensorInfos.real},backend:n})}const Ia={kernelName:X,backendName:"webgpu",kernelFunc:ya};const Sa={kernelName:K,backendName:"webgpu",kernelFunc:function t(n){const{inputs:s,backend:a,attrs:i}=n,{x:o}=s,{dtype:u}=i;if("complex64"===u){if("complex64"===o.dtype)return hr({inputs:{x:o},backend:a});const n=e.zeros(o.shape),r=t({inputs:{x:o},backend:a,attrs:{dtype:"float32"}}),s=pr({inputs:{real:r,imag:n},backend:a});return n.dispose(),a.disposeData(r.dataId),s}if("complex64"===o.dtype){const e=ya({inputs:{input:o},backend:a}),n=t({inputs:{x:e},backend:a,attrs:{dtype:u}});return a.disposeData(e.dataId),n}if(!r.hasEncodingLoss(o.dtype,u)){const e=hr({inputs:{x:o},backend:a});return{dataId:e.dataId,shape:e.shape,dtype:u}}if(a.shouldExecuteOnCPU([o])){const e=a.tensorMap.get(o.dataId).values,[t,n,r]=Zr(e,o.shape,o.dtype,u);return a.makeTensorInfo(t,n,r)}if("int32"===u)return function(e,t){const n=new fr(e.shape,Ln.TO_INT),r=t.runWebGPUProgram(n,[e],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}(o,a);if("bool"===u){const e=a.makeTensorInfo([],"bool",r.getTypedArrayFromDType("bool",1)),t=xa({inputs:{a:o,b:e},backend:a});return a.disposeData(e.dataId),t}throw new Error(`Error in Cast: failed to cast ${o.dtype} to ${u}`)}},ka={kernelName:q,backendName:"webgpu",kernelFunc:mr({opType:Ln.CEIL,cpuKernelImpl:Jr})};class va{constructor(e){this.variableNames=["A"],this.uniforms="minVal : f32, maxVal : f32,",this.workPerThread=4,this.workgroupSize=[64,1,1],this.isVec4=!0,this.size=!0,this.outputShape=e,this.dispatchLayout=In(this.outputShape),this.dispatch=bn(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.shaderKey="clipVec4"}getUserCode(){return`\n      ${on("index")} {\n        if(index < uniforms.size) {\n          let value = getAByOutputIndex(index);\n          var clampedValue = clamp(\n              value, vec4<f32>(uniforms.minVal), vec4<f32>(uniforms.maxVal));\n          clampedValue = select(clampedValue, value, isnanVec4(value));\n          setOutputAtIndex(index, clampedValue);\n        }\n      }\n    `}}class Ca{constructor(e){this.variableNames=["A"],this.uniforms="minVal : f32, maxVal : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=In(this.outputShape),this.dispatch=bn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="clip"}getUserCode(){return`\n      ${on("index")} {\n        if(index < uniforms.size) {\n          let value = getAByOutputIndex(index);\n          if (isnan(value)) {\n            setOutputAtIndex(index, value);\n            return;\n          }\n          setOutputAtIndex(index, clamp(value, uniforms.minVal, uniforms.maxVal));\n        }\n      }\n    `}}const $a={kernelName:j,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:a}=t,{clipValueMin:i,clipValueMax:o}=s;let u;const l=[{type:"float32",data:[i]},{type:"float32",data:[o]}];return u=r.sizeFromShape(a.shape)%4==0?new va(a.shape):new Ca(a.shape),n.runWebGPUProgram(u,[a],a.dtype,l)}};class Ra{constructor(e){this.uniforms="",this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=n.computeOutShape(e,1),this.variableNames=e.map(((e,t)=>`T${t}`)),this.dispatchLayout=In(this.outputShape),this.dispatch=bn(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.offsetLength=e.length-1;for(let e=0;e<this.offsetLength;e++)this.uniforms+=`offset${e} : i32,`;this.shaderKey="concat"}getUserCode(){const e=[];if(this.offsetLength>0){e.push("if (yC < uniforms.offset0){ setOutputAtCoords(coords.x, coords.y, getT0(yR, yC)); }");for(let t=1;t<this.offsetLength;t++)e.push(`else if (yC < uniforms.offset${[t]}){ setOutputAtCoords(coords.x, coords.y, getT${t}(yR, yC - uniforms.offset${t-1})); }`);const t=this.offsetLength,n=this.offsetLength-1;e.push(`else { setOutputAtCoords(coords.x, coords.y, getT${t}(yR, yC - uniforms.offset${n})); }`)}else e.push("setOutputAtCoords(coords.x, coords.y, getT0(yR, yC));");return`\n      ${on("index")} {\n        for(var i = 0; i < ${this.workPerThread}; i = i + 1) {\n          let flatIndex = index * ${this.workPerThread} + i;\n          if(flatIndex < uniforms.size) {\n            let coords = getCoordsFromIndex(flatIndex);\n            let yR = coords.x;\n            let yC = coords.y;\n\n            ${e.join("\n        ")}\n          }\n        }\n      }\n    `}}function Aa(e){const{inputs:t,backend:n}=e,{input:r}=t;return hr({inputs:{x:n.tensorMap.get(r.dataId).complexTensorInfos.imag},backend:n})}const Ta={kernelName:Y,backendName:"webgpu",kernelFunc:Aa};function Pa(e,t,s){const a=e[0].dtype;if("complex64"===a){const n=e.map((e=>ya({inputs:{input:e},backend:s}))),r=e.map((e=>Aa({inputs:{input:e},backend:s}))),a=Pa(n,t,s),i=Pa(r,t,s),o=pr({inputs:{real:a,imag:i},backend:s});return n.forEach((e=>s.disposeData(e.dataId))),r.forEach((e=>s.disposeData(e.dataId))),s.disposeData(a.dataId),s.disposeData(i.dataId),o}let i=s.shouldExecuteOnCPU(e);if("string"===a&&(i=!0),i){const i=e.map((e=>{const n=r.sizeFromShape(e.shape.slice(t));return sr({inputs:{x:e},backend:s,attrs:{shape:[-1,n]}})})),o=i.map((e=>({vals:s.readSync(e.dataId),shape:e.shape}))),u=n.computeOutShape(i.map((e=>e.shape)),1),l=1===i[0].shape[0],h=es(o,u,a,l),d=n.computeOutShape(e.map((e=>e.shape)),t),p=s.makeTensorInfo(d,a,h);return i.forEach((e=>s.disposeData(e.dataId))),p}const o=s.device.limits.maxStorageBuffersPerShaderStage-1;if(e.length>o){const n=[];for(let r=0;r<e.length;r+=o){const a=e.slice(r,r+o);n.push(Pa(a,t,s))}const r=Pa(n,t,s);for(const e of n)s.disposeData(e.dataId);return r}const{tensors2D:u,outShape:l}=function(e,t,s){const a=n.computeOutShape(e.map((e=>e.shape)),t);return{tensors2D:e.map((e=>sr({inputs:{x:e},backend:s,attrs:{shape:[r.sizeFromShape(e.shape.slice(0,t)),r.sizeFromShape(e.shape.slice(t))]}}))),outShape:a}}(e,t,s),h=u.map((e=>e.shape)),d=new Ra(h),p=[],c=new Array(h.length-1);if(c.length>0){c[0]=h[0][1],p.push({type:"int32",data:[c[0]]});for(let e=1;e<c.length;e++)c[e]=c[e-1]+h[e][1],p.push({type:"int32",data:[c[e]]})}const f=s.runWebGPUProgram(d,u,u[0].dtype,p);u.forEach((e=>s.disposeData(e.dataId)));const m=sr({inputs:{x:f},backend:s,attrs:{shape:l}});return s.disposeData(f.dataId),m}function Na(e){const{inputs:t,backend:s,attrs:a}=e,{axis:i}=a,o=r.parseAxisParam(i,t[0].shape)[0],u=t.map((e=>e.shape));n.assertParamsConsistent(u,o);const l=n.computeOutShape(t.map((e=>e.shape)),o);if(0===r.sizeFromShape(l))return s.makeTensorInfo(l,t[0].dtype,[]);const h=t.filter((e=>r.sizeFromShape(e.shape)>0));return 1===h.length?hr({inputs:{x:h[0]},backend:s}):Pa(h,o,s)}const za={kernelName:Q,backendName:"webgpu",kernelFunc:Na};class Ea{constructor(e,t,n,r,s=!1,a=null,i=!1,o=!1){this.variableNames=["x","W"],this.uniforms="filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>, dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=e.outShape,this.isChannelsLast="channelsLast"===e.dataFormat,this.isVec4=((e.inChannels%4==0||e.inChannels%3==0)&&this.isChannelsLast||e.outWidth%4==0&&!this.isChannelsLast)&&e.outChannels%4==0,this.dispatchLayout=this.isChannelsLast?{x:[3],y:[1,2],z:[0]}:{x:[2,3],y:[1],z:[0]},this.workgroupSize=wn(this.dispatchLayout,this.outputShape,this.isVec4),this.elementsPerThread=yn(this.dispatchLayout,this.outputShape,this.isVec4),this.dispatch=bn(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread),this.isVec4?(this.isChannelsLast&&e.inChannels%4!=0?(this.innerElementSize=3,this.variableTypes=["f32","vec4<f32>"]):(this.innerElementSize=4,this.variableTypes=["vec4<f32>","vec4<f32>"]),s&&(this.variableNames.push("bias"),this.variableTypes.push("vec4<f32>")),i&&(this.variableNames.push("preluActivationWeights"),this.variableTypes.push("vec4<f32>"))):(this.innerElementSize=this.elementsPerThread[0],s&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights")),this.sequentialAccessByThreads=o,this.addBias=s,this.activation=a,this.hasPreluActivationWeights=i,this.tileAOuter=this.workgroupSize[1]*this.elementsPerThread[1],this.tileBOuter=this.workgroupSize[0]*this.elementsPerThread[0],this.tileInner=Math.max(this.workgroupSize[0]*this.innerElementSize,this.workgroupSize[1]),this.fitAOuter=t%this.tileAOuter==0,this.fitBOuter=n%this.tileBOuter==0,this.fitInner=r%this.tileInner==0,this.shaderKey=`conv2DMM_${this.elementsPerThread}_${this.activation}}_${this.fitAOuter}_${this.fitBOuter}_${this.fitInner}_${this.isVec4}_${this.innerElementSize}_${this.isChannelsLast}_${this.sequentialAccessByThreads}`}getUserCode(){const e=this.isVec4?Kn(this.elementsPerThread,this.workgroupSize,!this.isChannelsLast,this.tileInner):jn(this.elementsPerThread,this.workgroupSize,!this.isChannelsLast,this.tileInner,!1,null,this.sequentialAccessByThreads),t=this.isVec4?[this.innerElementSize,4,4]:[1,1,1];return`\n    ${function(e,t,n,r,s=!1,a=null,i=!1,o=4,u=4,l=4){const h=e?"\n      let coord = vec4<i32>(batch, xRow, xCol, xCh);\n      ":"\n      let coord = vec4<i32>(batch, xCh, xRow, xCol);\n      ",d=e?"\n      let coords = vec4<i32>(\n        batch,\n        row / outWidth,\n        row % outWidth,\n        col);\n      ":"\n      let coords = vec4<i32>(\n        batch,\n        row,\n        col / outWidth,\n        col % outWidth);\n      ",p=e?"uniforms.xShape[1]":"uniforms.xShape[2]",c=e?"uniforms.xShape[2]":"uniforms.xShape[3]",f=e?"row":"col",m=e?"col":"row",g=`\n      let inChannels = uniforms.wShape[2];\n      let outWidth = ${e?"uniforms.outShape[2]":"uniforms.outShape[3]"};\n      let outRow = ${f} / outWidth;\n      let outCol = ${f} % outWidth;\n\n      let WRow = ${m} / (uniforms.filterDims[1] * inChannels);\n      let WCol = ${m} / inChannels % uniforms.filterDims[1];\n      let xRow = outRow * uniforms.stride[0] + uniforms.dilation[0] * WRow - uniforms.pad[0];\n      let xCol = outCol * uniforms.stride[1] + uniforms.dilation[1] * WCol - uniforms.pad[1];\n      let xCh = ${m} % inChannels;\n      var resData = ${Mn(o)}(0.0);\n      // The bounds checking is always needed since we use it to pad zero for\n      // the 'same' padding type.\n      if (xRow >= 0 && xRow < ${p} && xCol >= 0 && xCol < ${c}) {\n        ${h}\n        let xIndex = getIndexFromCoords4D(coord, uniforms.xShape);\n        ${(e=>{switch(e){case 1:return"resData = x[xIndex];";case 3:return"resData = vec3<f32>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);";case 4:return"resData = x[xIndex / 4];";default:throw new Error(`innerElementSize ${e} is not supported.`)}})(o)}\n      }\n      return resData;`,b=e?t&&r?`\n      let col = colIn * ${o};\n      ${g}`:`\n      let col = colIn * ${o};\n      if (row < uniforms.dimAOuter && col < uniforms.dimInner) {\n        ${g}\n      }\n      return ${Mn(o)}(0.0);`:r&&n?`\n      let col = colIn * ${o};\n      ${g}`:`\n      let col = colIn * ${o};\n      if (row < uniforms.dimInner && col < uniforms.dimBOuter) {\n        ${g}\n      }\n      return ${Mn(o)}(0.0);`,x=`${(e=>{switch(e){case 1:return"return W[row * uniforms.wShape[3] + colIn];";case 4:return"return W[row * uniforms.wShape[3] / 4 + colIn];";default:throw new Error(`innerElementSize ${e} is not supported.`)}})(u)}`,w=Mn(l),y=Mn(e?o:u),I=Mn(e?u:o);return`\n      ${Vn(a,i,4===l,4)}\n      fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${y} {\n        ${e?b:x}\n      }\n\n      fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${I} {\n        ${e?x:b}\n      }\n\n      fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${w}) {\n        let col = colIn * ${l};\n        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)\n        {\n        var value = valueIn;\n        let outWidth = ${e?"uniforms.outShape[2]":"uniforms.outShape[3]"};\n        ${d}\n        ${Gn(s,a)}\n        setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n        }\n      }`}(this.isChannelsLast,this.fitAOuter,this.fitBOuter,this.fitInner,this.addBias,this.activation,this.hasPreluActivationWeights,t[0],t[1],t[2])}\n    ${e}\n  `}}class Fa{constructor(e,t=!1,n=null,r=!1){this.variableNames=["x","W"],this.uniforms="filterDims: vec2<i32>, pad: vec2<i32>, stride: vec2<i32>, dilation: vec2<i32>,",this.workgroupSize=[4,4,8],this.outputShape=e.outShape,this.isChannelsLast="channelsLast"===e.dataFormat,this.dispatchLayout=this.isChannelsLast?{x:[2],y:[1],z:[0,3]}:{x:[3],y:[2],z:[0,1]},this.dispatch=bn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.addBias=t,this.activation=n,this.hasPreluActivationWeights=r,t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),this.shaderKey=`conv2dnaive_${this.activation}_${this.isChannelsLast}`}getUserCode(){return`\n       ${Vn(this.activation,this.hasPreluActivationWeights,!1,4)}\n       fn readInp(batch : i32, row : i32, col : i32, chan : i32) -> f32{\n         let coords = vec4<i32>(batch, row, col, chan);\n         if (coordsInBounds4D(coords, uniforms.xShape)) {\n           return  getX(batch, row, col, chan);\n         } else {\n          return 0.0;\n         }\n       }\n       fn readFilt(row : i32, col : i32, xChannel : i32, outChannel : i32) -> f32{\n         let coords = vec4<i32>(row, col, xChannel, outChannel);\n         if(coordsInBounds4D(coords, uniforms.wShape)) {\n           return getW(row, col, xChannel, outChannel);\n          } else {\n            return 0.0;\n          }\n       }\n       fn writeResult(batch : i32, row : i32, col : i32, chan : i32, valueIn : f32) {\n         let coords = ${this.isChannelsLast?"vec4<i32>(batch, row, col, chan);":"vec4<i32>(batch, chan, row, col);"}\n         if (coordsInBounds4D(coords, uniforms.outShape)) {\n           var value = valueIn;\n           ${Gn(this.addBias,this.activation)}\n           setOutputAtCoords(coords.x, coords.y, coords.z, coords.w, value);\n         }\n       }\n       ${on("index")} {\n         let coords = getOutputCoords();\n         let batch = coords[0];\n         let outChannel = ${this.isChannelsLast?"coords[3];":"coords[1];"}\n         let outRow = ${this.isChannelsLast?"coords[1];":"coords[2];"}\n         let outCol = ${this.isChannelsLast?"coords[2];":"coords[3];"}\n         var acc : f32 = 0.0;\n         for (var row = 0; row < uniforms.filterDims[0]; row = row + 1) {\n           for (var col = 0; col < uniforms.filterDims[1]; col = col + 1) {\n             let xRow = outRow * uniforms.stride[0] + uniforms.dilation[0] * row - uniforms.pad[0];\n             let xCol = outCol * uniforms.stride[1] + uniforms.dilation[1] * col - uniforms.pad[1];\n             for (var xChannel = 0; xChannel < ${this.isChannelsLast?"uniforms.xShape[3];":"uniforms.xShape[1];"} xChannel = xChannel + 1) {\n               ${this.isChannelsLast?"let v = readInp(batch, xRow, xCol, xChannel);":"let v = readInp(batch, xChannel, xRow, xCol);"}\n               let f = readFilt(row, col, xChannel, outChannel);\n               acc = acc + v * f;\n             }\n           }\n         }\n         writeResult(batch, outRow, outCol, outChannel, acc);\n       }\n     `}}class Ba{constructor(e,t){this.variableNames=["x"],this.uniforms="pad : vec2<i32>, stride : vec2<i32>, dilation : vec2<i32>, outWidth : i32, itemsPerBlockRow : i32,\n       inChannels : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=In(this.outputShape),this.dispatch=bn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast=t,this.shaderKey=`im2col_${this.isChannelsLast}`}getUserCode(){const e=this.isChannelsLast?1:2,t=this.isChannelsLast?2:3,n=this.isChannelsLast?"coords[1]":"coords[2]",r=this.isChannelsLast?"coords[2]":"coords[1]",s=this.isChannelsLast?"getX(batch, xRow, xCol, ch)":"getX(batch, ch, xRow, xCol)";return`\n    ${on("index")} {\n      let coords = getCoordsFromIndex(index);\n      if(index < uniforms.size) {\n        let batch = coords[0];\n        let row = ${n};\n        let col = ${r};\n        let offsetY = (row / uniforms.outWidth) * uniforms.stride[0] - uniforms.pad[0];\n        let xRow = offsetY + uniforms.dilation[0] * (col / uniforms.itemsPerBlockRow);\n        var value = 0.0;\n        if(xRow < uniforms.xShape[${e}] && xRow >= 0) {\n          let offsetX = (row % uniforms.outWidth) * uniforms.stride[1] -\n              uniforms.pad[1];\n          let xCol = offsetX + uniforms.dilation[1] * ((col %\n              uniforms.itemsPerBlockRow) / uniforms.inChannels);\n          let ch = col % uniforms.inChannels;\n          if(xCol < uniforms.xShape[${t}] && xCol >= 0) {\n            value = ${s};\n          }\n        }\n        setOutputAtIndex(index, value);\n      }\n    }\n   `}}function _a(e,t){const n=e.length;return n>=3?t?[...e.slice(0,-3),e[n-3]*e[n-2],e[n-1]]:[...e.slice(0,-3),e[n-3],e[n-2]*e[n-1]]:!t&&1===n&&e[0]>1?[e[0],1]:null}function Oa({x:e,filter:n,convInfo:r,backend:s,bias:a=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:u=null}){const l=null!=a,h=null!=i,d="channelsLast"===r.dataFormat,p=d&&r.filterHeight===r.inHeight&&r.filterWidth===r.inWidth&&"VALID"===r.padInfo.type,c=t().getBool("WEBGPU_USE_NAIVE_CONV2D_DEBUG");if(!c&&(p||1===r.filterHeight&&1===r.filterWidth&&1===r.dilationHeight&&1===r.dilationWidth&&1===r.strideHeight&&1===r.strideWidth&&("SAME"===r.padInfo.type||"VALID"===r.padInfo.type)))return function({x:e,filter:t,convInfo:n,backend:r,bias:s=null,preluActivationWeights:a=null,leakyreluAlpha:i=0,activation:o=null}){const u="channelsLast"===n.dataFormat,l=!u,h=[];let d,p;if(u&&n.filterHeight===n.inHeight&&n.filterWidth===n.inWidth&&"VALID"===n.padInfo.type){const s=n.inHeight*n.inWidth*n.inChannels;d=sr({inputs:{x:e},backend:r,attrs:{shape:[1,n.batchSize,s]}}),p=sr({inputs:{x:t},backend:r,attrs:{shape:[1,s,n.outChannels]}})}else d=sr({inputs:{x:e},backend:r,attrs:{shape:u?[n.batchSize,n.inHeight*n.inWidth,n.inChannels]:[n.batchSize,n.inChannels,n.inHeight*n.inWidth]}}),p=sr({inputs:{x:t},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}});if(h.push(d),h.push(p),null!=a){const e=_a(a.shape,u);null!=e&&(a=sr({inputs:{x:a},backend:r,attrs:{shape:e}}),h.push(a))}if(null!=s){const e=_a(s.shape,u);null!=e&&(s=sr({inputs:{x:s},backend:r,attrs:{shape:e}}),h.push(s))}const c=ir({a:u?d:p,b:u?p:d,transposeA:l,transposeB:!1,backend:r,bias:s,activation:o,preluActivationWeights:a,leakyreluAlpha:i}),f=sr({inputs:{x:c},backend:r,attrs:{shape:n.outShape}});h.push(c);for(const e of h)r.disposeData(e.dataId);return f}({x:e,filter:n,convInfo:r,backend:s,bias:a,activation:u,preluActivationWeights:i,leakyreluAlpha:o});const f=t().getNumber("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL"),m=f>0?f:s.thresholdToIncreaseWorkgroups,g=r.batchSize*Math.ceil(r.outHeight*r.outWidth/32)*Math.ceil(r.outChannels/32);if(t().getBool("WEBGPU_CONV_SEPARATE_IM2COL_SHADER")||g<=m)return function({x:e,filter:t,convInfo:n,backend:r,bias:s=null,preluActivationWeights:a=null,leakyreluAlpha:i=0,activation:o=null}){const{filterWidth:u,filterHeight:l,inChannels:h,strideWidth:d,strideHeight:p,padInfo:c,outWidth:f,outHeight:m,dilationWidth:g,dilationHeight:b,dataFormat:x}=n,w="channelsLast"===x,y=u*l*h,I=m*f,S=w?[n.batchSize,I,y]:[n.batchSize,y,I],k=new Ba(S,w),v=[{type:"int32",data:[c.top,c.left]},{type:"int32",data:[p,d]},{type:"int32",data:[b,g]},{type:"int32",data:[f]},{type:"int32",data:[h*u]},{type:"int32",data:[h]}],C=r.runWebGPUProgram(k,[e],e.dtype,v),$=[];$.push(C);const R=sr({inputs:{x:t},backend:r,attrs:{shape:[1,y,-1]}});if($.push(R),null!=a){const e=_a(a.shape,w);null!=e&&(a=sr({inputs:{x:a},backend:r,attrs:{shape:e}}),$.push(a))}if(null!=s){const e=_a(s.shape,w);null!=e&&(s=sr({inputs:{x:s},backend:r,attrs:{shape:e}}),$.push(s))}const A=ir({a:w?C:R,b:w?R:C,transposeA:!w,transposeB:!1,backend:r,bias:s,activation:o,preluActivationWeights:a,leakyreluAlpha:i}),T=sr({inputs:{x:A},backend:r,attrs:{shape:n.outShape}});$.push(A);for(const e of $)r.disposeData(e.dataId);return T}({x:e,filter:n,convInfo:r,backend:s,bias:a,preluActivationWeights:i,leakyreluAlpha:o,activation:u});let b;const x=[r.padInfo.top,r.padInfo.left],w=[{type:"int32",data:[r.filterHeight,r.filterWidth]},{type:"int32",data:[...x]},{type:"int32",data:[r.strideHeight,r.strideWidth]},{type:"int32",data:[r.dilationHeight,r.dilationWidth]}];if(c)b=new Fa(r,l,u,h);else{const e=d?r.outHeight*r.outWidth:r.outChannels,t=d?r.outChannels:r.outHeight*r.outWidth,n=r.filterHeight*r.filterWidth*r.inChannels;w.push({type:"int32",data:[e]},{type:"int32",data:[t]},{type:"int32",data:[n]});const a=s.adapterInfo.isIntel();b=new Ea(r,e,t,n,l,u,h,a)}const y=[],I=[e,n];l&&(d||1!==a.shape.length||(a=sr({inputs:{x:a},backend:s,attrs:{shape:[a.shape[0],1,1]}}),y.push(a)),I.push(a)),h&&(d||1!==i.shape.length||(i=sr({inputs:{x:i},backend:s,attrs:{shape:[i.shape[0],1,1]}}),y.push(i)),I.push(i)),"leakyrelu"===u&&(w.push({type:"float32",data:[o]}),b.uniforms+=" alpha : f32,");const S=s.runWebGPUProgram(b,I,e.dtype,w);for(const e of y)s.disposeData(e.dataId);return S}const La={kernelName:Z,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,attrs:r,backend:s}=e,{x:a,filter:i}=t,{strides:o,pad:u,dataFormat:l,dilations:h,dimRoundingMode:d}=r,p=n.convertConv2DDataFormat(l);return Oa({x:a,filter:i,convInfo:n.computeConv2DInfo(a.shape,i.shape,o,h,u,d,!1,p),backend:s})}};class Ua{constructor(e){this.variableNames=["dy","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, stride : vec2<i32>, outBackprop : vec4<i32>,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=In(this.outputShape),this.dispatch=bn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast="channelsLast"===e.dataFormat,this.shaderKey=`conv2DDerInput_${this.isChannelsLast}`}getUserCode(){const e=this.isChannelsLast?1:2,t=this.isChannelsLast?2:3,n=this.isChannelsLast?3:1;return`\n    ${on("index")} {\n      if(index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let batch = coords[0];\n        let d1 = coords[${n}];\n\n        let dyCorner = vec2<i32>(coords[${e}], coords[${t}]) - uniforms.pads;\n        let dyRCorner = dyCorner.x;\n        let dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        var dotProd = 0.0;\n        for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + 1) {\n          let dyR = (f32(dyRCorner) + f32(wR)) / f32(uniforms.stride.x);\n          let wRPerm = uniforms.filterDims.x - 1 - wR;\n          if (dyR < 0.0 || dyR >= f32(uniforms.outBackprop[1]) || fract(dyR) > 0.0 ||\n              wRPerm < 0) {\n            continue;\n          }\n          let idyR = i32(dyR);\n\n          for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + 1) {\n            let dyC = (f32(dyCCorner) + f32(wC)) / f32(uniforms.stride.y);\n            let wCPerm = uniforms.filterDims.y - 1 - wC;\n            if (dyC < 0.0 || dyC >= f32(uniforms.outBackprop[2]) ||\n                fract(dyC) > 0.0 || wCPerm < 0) {\n              continue;\n            }\n            let idyC = i32(dyC);\n\n            for (var d2 = 0; d2 < uniforms.outBackprop[3]; d2 = d2 + 1) {\n              if (${this.isChannelsLast}) {\n                let xValue = getDy(batch, idyR, idyC, d2);\n                let wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd = dotProd + xValue * wValue;\n              } else {\n                let xValue = getDy(batch, d2, idyR, idyC);\n                let wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd = dotProd + xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutputAtIndex(index, dotProd);\n      }\n    }\n  `}}class Da{constructor(e){this.variableNames=["x","dy"],this.uniforms="pad : vec2<i32>, stride : vec2<i32>, batchSize : i32, outHeight : i32, outWidth : i32, inHeight : i32, inWidth : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.filterShape,this.dispatchLayout=In(this.outputShape),this.dispatch=bn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast="channelsLast"===e.dataFormat,this.shaderKey=`conv2DDerFilter_${this.isChannelsLast}`}getUserCode(){return`\n    ${on("index")} {\n      if(index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let wR = coords[0];\n        let wC = coords[1];\n        let d1 = coords[2];\n        let d2 = coords[3];\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        var dotProd = 0.0;\n        for (var b = 0; b < uniforms.batchSize; b = b + 1) {\n          for (var yR = 0; yR < uniforms.outHeight; yR = yR + 1) {\n            let xR = wR + yR * uniforms.stride[0] - uniforms.pad[0];\n            if (xR < 0 || xR >= uniforms.inHeight) {\n              continue;\n            }\n\n            for (var yC = 0; yC < uniforms.outWidth; yC = yC + 1) {\n              let xC = wC + yC * uniforms.stride[1] - uniforms.pad[1];\n\n              if (xC < 0 || xC >= uniforms.inWidth) {\n                continue;\n              }\n\n              if (${this.isChannelsLast}) {\n                let dyValue = getDy(b, yR, yC, d2);\n                let xValue = getX(b, xR, xC, d1);\n                dotProd = dotProd + xValue * dyValue;\n              } else {\n                let dyValue = getDy(b, d2, yR, yC);\n                let xValue = getX(b, d1, xR, xC);\n                dotProd = dotProd + xValue * dyValue;\n              }\n            }\n          }\n        }\n        setOutputAtIndex(index, dotProd);\n      }\n    }\n  `}}const Wa={kernelName:J,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:r,attrs:s}=e,{x:a,dy:i}=t,{strides:o,pad:u,dataFormat:l,dimRoundingMode:h,filterShape:d}=s,p=n.convertConv2DDataFormat(l),c=n.computeConv2DInfo(a.shape,d,o,1,u,h,!1,p),f=new Da(c),m=[{type:"int32",data:[c.padInfo.top,c.padInfo.left]},{type:"int32",data:[c.strideHeight,c.strideWidth]},{type:"int32",data:[c.batchSize]},{type:"int32",data:[c.outHeight]},{type:"int32",data:[c.outWidth]},{type:"int32",data:[c.inHeight]},{type:"int32",data:[c.inWidth]}];return r.runWebGPUProgram(f,[a,i],a.dtype,m)}};class Ma{constructor(e){this.variableNames=["x","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, stride : vec2<i32>, outBackprop : vec4<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=e.inShape,r.assert("channelsLast"===e.dataFormat,(()=>"TODO: NCHW is unimplemented")),this.isVec4=e.inChannels%4==0&&e.outChannels%4==0,this.dispatchLayout={x:[3],y:[1,2],z:[0]},this.workgroupSize=wn(this.dispatchLayout,this.outputShape,this.isVec4),this.elementsPerThread=yn(this.dispatchLayout,this.outputShape,this.isVec4),this.dispatch=bn(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread),this.isVec4&&(this.variableTypes=["vec4<f32>","f32"]),this.shaderKey=`conv2DDerInputMM_${this.isVec4}_${this.elementsPerThread}`}getUserCode(){const e=this.isVec4?Kn(this.elementsPerThread,this.workgroupSize):jn(this.elementsPerThread,this.workgroupSize);return`\n    ${function(e=4){const t=`if (row < uniforms.dimAOuter && col < uniforms.dimInner) {\n        \n      let outRow = row / uniforms.outShape[2];\n      let outCol = row % uniforms.outShape[2];\n\n      let WRow = col / (uniforms.filterDims[1] * uniforms.outBackprop[3]);\n      let WCol = col / uniforms.outBackprop[3] % uniforms.filterDims[1];\n      let xR = f32(outRow - uniforms.pads[0] + WRow) / f32(uniforms.stride[0]);\n      let xC = f32(outCol - uniforms.pads[1] + WCol) / f32(uniforms.stride[1]);\n      if (xR < 0.0 || xR >= f32(uniforms.outBackprop[1]) || fract(xR) > 0.0) {\n        return ${Mn(e)}(0.0);\n      }\n      if (xC < 0.0 || xC >= f32(uniforms.outBackprop[2]) || fract(xC) > 0.0) {\n        return ${Mn(e)}(0.0);\n      }\n      let coord = vec4<i32>(\n          batch,\n          i32(xR),\n          i32(xC),\n          col % uniforms.outBackprop[3]);\n      return x[getIndexFromCoords4D(coord, uniforms.xShape)/${e}];\n      }\n      return ${Mn(e)}(0.0);`;return`\n  fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${Mn(e)} {\n    let col = colIn * ${e};\n    ${t}\n  }\n\n  fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${Mn(e)} {\n    let col = colIn * ${e};\n    let coordX = uniforms.filterDims.x - 1 -\n        row / (uniforms.filterDims[1] * uniforms.outBackprop[3]);\n    let coordY = uniforms.filterDims.y - 1 -\n        (row / uniforms.outBackprop[3]) % uniforms.filterDims[1];\n    if (row < uniforms.dimInner && col < uniforms.dimBOuter &&\n        coordX >= 0 && coordY >= 0) {\n      let rowInner = row % uniforms.outBackprop[3];\n      let coord = vec4<i32>(coordX, coordY, col, rowInner);\n      ${(e=>{switch(e){case 1:return"return W[getIndexFromCoords4D(coord, uniforms.wShape)];";case 4:return"\n            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);\n            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);\n            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);\n            let v0 = W[getIndexFromCoords4D(coord, uniforms.wShape)];\n            let v1 = W[getIndexFromCoords4D(coord1, uniforms.wShape)];\n            let v2 = W[getIndexFromCoords4D(coord2, uniforms.wShape)];\n            let v3 = W[getIndexFromCoords4D(coord3, uniforms.wShape)];\n            return vec4<f32>(v0, v1, v2, v3);\n            ";default:throw new Error(`innerElementSize ${e} is not supported.`)}})(e)}\n    }\n    return ${Mn(e)}(0.0);\n  }\n\n  fn mm_write(batch: i32, row : i32, colIn : i32, valueInput : ${Mn(e)}) {\n    let col = colIn * ${e};\n    if (row < uniforms.dimAOuter && (col + ${e-1}) < uniforms.dimBOuter) {\n      var value = valueInput;\n      let outCoord = vec4<i32>(\n          batch,\n          row / uniforms.outShape[2],\n          row % uniforms.outShape[2],\n          col);\n      result[getIndexFromCoords4D(outCoord, uniforms.outShape)/${e}] = value;\n    }\n  }`}(this.isVec4?4:1)}\n    ${e}\n    `}}const Va={kernelName:ee,backendName:"webgpu",kernelFunc:function(e){const{inputs:r,backend:s,attrs:a}=e,{dy:i,filter:o}=r,{inputShape:u,strides:l,pad:h,dataFormat:d,dimRoundingMode:p}=a,c=n.convertConv2DDataFormat(d),f=n.computeConv2DInfo(u,o.shape,l,1,h,p,!1,c),m=[{type:"int32",data:[f.filterHeight,f.filterWidth]},{type:"int32",data:[f.filterHeight-1-f.padInfo.top,f.filterWidth-1-f.padInfo.left]},{type:"int32",data:[f.strideHeight,f.strideWidth]},{type:"int32",data:[f.batchSize,f.outHeight,f.outWidth,f.outChannels]}];let g;if(t().getBool("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE")||f.filterHeight<=2&&f.filterWidth<=2&&f.outChannels<=16&&1===f.inChannels)g=new Ua(f);else{g=new Ma(f);const e=f.inHeight*f.inWidth,t=f.inChannels,n=f.filterHeight*f.filterWidth*f.outChannels;m.push({type:"uint32",data:[e]},{type:"uint32",data:[t]},{type:"uint32",data:[n]})}return s.runWebGPUProgram(g,[i,o],"float32",m)}},Ga={kernelName:te,backendName:"webgpu",kernelFunc:mr({opType:Ln.COS})},Ha={kernelName:ne,backendName:"webgpu",kernelFunc:mr({opType:Ln.COSH})};class Xa{constructor(e,t,n,r){this.variableNames=["Image","Boxes","BoxInd"],this.uniforms="extrapolationValue : f32,",this.workgroupSize=[64,1,1],this.size=!0;const[s]=t;this.outputShape=[s,n[0],n[1],e],this.dispatchLayout=In(this.outputShape),this.dispatch=bn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.methodId="bilinear"===r?1:0,this.cropHeightBiggerThan1=this.outputShape[1]>1,this.cropWidthBiggerThan1=this.outputShape[2]>1,this.shaderKey=`cropAndResize_${this.methodId}_${this.cropHeightBiggerThan1}_${this.cropWidthBiggerThan1}`}getUserCode(){const[e,t]=["f32(uniforms.imageShape[1] - 1)","f32(uniforms.imageShape[2] - 1)"],[n,r,s]=this.cropHeightBiggerThan1?[`(${e} / f32(uniforms.outShape[1] - 1))`,"(y2-y1) * height_ratio",`y1*${e} + f32(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${e}`],[a,i,o]=this.cropWidthBiggerThan1?[`(${t} / f32(uniforms.outShape[2] - 1))`,"(x2-x1) * width_ratio",`x1*${t} + f32(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${t}`];return`\n    ${on("index")} {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let height_ratio = f32(${n});\n        let width_ratio = f32(${a});\n        let b = coords[0];\n        let y = coords[1];\n        let x = coords[2];\n        let d = coords[3];\n        // get box vals\n        let y1 = getBoxes(b, 0);\n        let x1 = getBoxes(b, 1);\n        let y2 = getBoxes(b, 2);\n        let x2 = getBoxes(b, 3);\n        // get image in batch index\n        let bInd = i32(round(getBoxInd(b)));\n        if(bInd < 0 || bInd >= uniforms.outShape[0]) {\n          return;\n        }\n        let height_scale = ${r};\n        let width_scale = ${i};\n        let in_y = ${s};\n        if( in_y < 0.0 || in_y > ${e} ) {\n          setOutputAtIndex(index, uniforms.extrapolationValue);\n          return;\n        }\n        let in_x = ${o};\n        if( in_x < 0.0 || in_x > ${t} ) {\n          setOutputAtIndex(index, uniforms.extrapolationValue);\n          return;\n        }\n        let sourceFracIndexCR = vec2<f32>(in_x,in_y);\n        if(${this.methodId} == 1) {\n          // Compute the four integer indices.\n          let sourceFloorCR = vec2<i32>(sourceFracIndexCR);\n          let sourceCeilCR = vec2<i32>(ceil(sourceFracIndexCR));\n          let topLeft = getImage(bInd, sourceFloorCR.y, sourceFloorCR.x, d);\n          let bottomLeft = getImage(bInd, sourceCeilCR.y, sourceFloorCR.x, d);\n          let topRight = getImage(bInd, sourceFloorCR.y, sourceCeilCR.x, d);\n          let bottomRight = getImage(bInd, sourceCeilCR.y, sourceCeilCR.x, d);\n          let fracCR = sourceFracIndexCR - vec2<f32>(sourceFloorCR);\n          let top = topLeft + (topRight - topLeft) * fracCR.x;\n          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          let newValue = top + (bottom - top) * fracCR.y;\n          setOutputAtIndex(index, newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          let sourceNearestCR = vec2<i32>(floor(\n            sourceFracIndexCR + vec2<f32>(0.5,0.5)));\n          let newValue = getImage(\n            bInd, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutputAtIndex(index, newValue);\n        }\n      }\n    }\n    `}}const Ka={kernelName:re,backendName:"webgpu",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{image:s,boxes:a,boxInd:i}=t,{cropSize:o,method:u,extrapolationValue:l}=r,h=new Xa(s.shape[3],a.shape,o,u),d=[{type:"float32",data:[l]}];return n.runWebGPUProgram(h,[s,a,i],"float32",d)}};var qa;!function(e){e.Prod="*",e.Sum="+"}(qa||(qa={}));class ja{constructor(e,t,n,r){this.variableNames=["x"],this.uniforms="index : f32,",this.size=!0,this.workgroupSize=[128,1,1],this.outputShape=t,this.dispatchLayout=In(this.outputShape),this.dispatch=bn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.exclusive=n,this.reverse=r,this.op=e,this.shaderKey=`cum_${this.op}_${this.exclusive}_${this.reverse}`}getUserCode(){const e=this.outputShape.length,t=this.op===qa.Prod?"1.0":"0.0",n=this.exclusive?t:`getX(${Ya(e,"coords",this.op)})`,r=this.outputShape[this.outputShape.length-1];let s="",a="";return this.exclusive?(s=this.reverse?"end != "+(r-1):"end != 0",a=this.reverse?"end + 1":"end - 1"):(s=this.reverse?`end + pow2 < ${r}`:"end >= pow2",a=this.reverse?"end + pow2":"end - pow2"),`\n      ${on("index")} {\n       if (index < uniforms.size) {\n         var coords = getCoordsFromIndex(index);\n\n         let end = ${Qa(e,"coords",this.op)};\n         var val = ${n};\n         let pow2 = i32(pow(2.0, uniforms.index));\n         if (${s}) {\n           let idx = ${a};\n           ${Qa(e,"coords",this.op)} = idx;\n           val ${this.op}= getX(${Ya(e,"coords",this.op)});\n         }\n         setOutputAtIndex(index, val);\n       }\n      }\n    `}}function Ya(e,t,n){if(1===e)return`${t}`;if(2===e)return`${t}.x, ${t}.y`;if(3===e)return`${t}.x, ${t}.y, ${t}.z`;if(4===e)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function Qa(e,t,n){if(1===e)return`${t}`;if(2===e)return`${t}.y`;if(3===e)return`${t}.z`;if(4===e)return`${t}.w`;throw Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function Za(e,t,r,s,a,i){const o=t.shape.length,u=n.getAxesPermutation([s],o);let l=t;null!=u&&(l=Us({inputs:{x:t},backend:r,attrs:{perm:u}}));const h=n.getInnerMostAxes(1,o)[0];if(h!==o-1)throw new Error(`WebGPU cumprod shader expects an inner-most axis=${t.shape.length-1} but got axis=${s}`);const d=l.shape[h];let p=hr({inputs:{x:l},backend:r});for(let t=0;t<=Math.ceil(Math.log2(d))-1;t++){const n=new ja(e,l.shape,!1,i),s=p,a=[{type:"float32",data:[t]}];p=r.runWebGPUProgram(n,[p],p.dtype,a),r.disposeData(s.dataId)}if(a){const t=new ja(e,l.shape,a,i),n=p,s=[{type:"float32",data:[0]}];p=r.runWebGPUProgram(t,[p],p.dtype,s),r.disposeData(n.dataId)}if(null!=u){const e=Us({inputs:{x:p},backend:r,attrs:{perm:n.getUndoAxesPermutation(u)}});return r.disposeData(p.dataId),r.disposeData(l.dataId),e}return p}const Ja={kernelName:se,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,exclusive:i,reverse:o}=r;return Za(qa.Prod,s,n,a,i,o)}};const ei={kernelName:ae,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,exclusive:i,reverse:o}=r;return Za(qa.Sum,s,n,a,i,o)}};const ti={kernelName:ie,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:a,weights:i}=t,{size:o,binaryOutput:u}=s,l=1===a.shape.length,h=r.sizeFromShape(i.shape)>0,d=i.dtype,p=l?[a.shape[0]]:[a.shape[0],a.shape[1]],c=nr({backend:n,attrs:{shape:l?[o]:[a.shape[0],o],value:0,dtype:d}}),f=new ga(p,h,u),m=[{type:"int32",data:[o]}],g=h?[a,i]:[a];return n.runWebGPUProgram(f,g,d,m,c)}};class ni{constructor(e,t){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.uniforms="blockSize : i32,",this.outputShape=e,this.dispatchLayout=In(this.outputShape),this.dispatch=bn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey=`depthToSpace_${t}`,this.dataFormat=t}getUserCode(){return`\n      ${on("index")} {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let b = coords[0];\n          let h = ${this.getHeightCoordString()};\n          let w = ${this.getWidthCoordString()};\n          let d = ${this.getDepthCoordString()};\n\n          let in_h = h / uniforms.blockSize;\n          let offset_h = h % uniforms.blockSize;\n          let in_w = w / uniforms.blockSize;\n          let offset_w = w % uniforms.blockSize;\n          let offset_d = (offset_h * uniforms.blockSize + offset_w) *\n            ${this.getOutputDepthSize()};\n          let in_d = d + offset_d;\n\n          let rlt = ${this.getInputSamplingString()};\n          setOutputAtIndex(index, rlt);\n        }\n      }`}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?"uniforms.outShape[3]":"uniforms.outShape[1]"}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}const ri={kernelName:oe,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockSize:a,dataFormat:i}=r,o=s.shape[0],u=("NHWC"===i?s.shape[1]:s.shape[2])*a,l=("NHWC"===i?s.shape[2]:s.shape[3])*a,h=("NHWC"===i?s.shape[3]:s.shape[1])/(a*a),d=[{type:"int32",data:[a]}],p=new ni("NHWC"===i?[o,u,l,h]:[o,h,u,l],i);return n.runWebGPUProgram(p,[s],s.dtype,d)}};class si{constructor(e,t,n,r=!1,s=null,a=!1){this.variableNames=["x","W"],this.uniforms="pad : vec2<i32>, inDims : vec2<i32>,",this.workgroupSize=[16,16,1],this.outputShape=e,this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=bn(this.dispatchLayout,this.outputShape,this.workgroupSize),r&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),this.addBias=r,this.activation=s,this.hasPreluActivation=a,this.filterHeight=t,this.filterWidth=n,this.shaderKey=`depthwiseNCHW_${this.activation}_${this.filterHeight}_${this.filterWidth}`}getUserCode(){const e=this.filterWidth*this.filterHeight,t=this.workgroupSize[0]*this.workgroupSize[1]*this.workgroupSize[2],n=this.workgroupSize[1]+this.filterHeight-1,r=this.workgroupSize[0]+this.filterWidth-1;return`\n      ${Vn(this.activation,this.hasPreluActivation,!1,4)}\n\n      var<workgroup> mm_Asub : array<array<f32, ${r}>, ${n}>;\n      var<workgroup> mm_Bsub : array<array<f32, ${this.filterWidth}>, ${this.filterHeight}>;\n      fn readX(batch : i32, channel : i32, row : i32, col : i32) -> f32 {\n        var value = 0.0;\n        if (row >=0 && row < uniforms.inDims[0] && col >=0 && col < uniforms.inDims[1])\n        {\n          value = getX(batch, channel, row, col);\n        }\n        return value;\n      }\n\n      ${on()} {\n        let coords = getOutputCoords();\n        let batch = coords[0];\n        let xRCCorner = vec2<i32>(coords.zw) - uniforms.pad;\n        let channelMul = uniforms.wShape[3];\n        let d1 = coords[1] / channelMul;\n        let q = coords[1] % channelMul;\n\n        let inputRowStart = xRCCorner.x;\n        let inputColStart = xRCCorner.y;\n\n        let localRow = i32(localId.y);\n        let localCol = i32(localId.x);\n\n        // Load one tile of X into local memory.\n        for (var inputRow = localRow; inputRow < ${n}; inputRow = inputRow + ${this.workgroupSize[1]}) {\n          for (var inputCol = localCol; inputCol < ${r}; inputCol = inputCol + ${this.workgroupSize[0]}) {\n            let rowOffset = inputRow - localRow;\n            let colOffset = inputCol - localCol;\n            mm_Asub[inputRow][inputCol] = readX(batch, d1, inputRowStart + rowOffset, inputColStart + colOffset);\n          }\n        }\n\n        // Load one tile of W into local memory.\n        var wIndex = i32(localIndex);\n        ${e<t?`if (wIndex < ${e})`:`for(; wIndex < ${e}; wIndex = wIndex + ${t})`}\n\n        {\n          let wRow = wIndex / ${this.filterWidth};\n          let wCol = wIndex % ${this.filterWidth};\n          mm_Bsub[wRow][wCol] = getW(wRow, wCol, d1, q);\n        }\n\n        workgroupBarrier();\n\n        var value = 0.0;\n        for (var wR = 0; wR < ${this.filterHeight}; wR = wR + 1) {\n          for (var wC = 0; wC < ${this.filterWidth}; wC = wC + 1) {\n            let xVal = mm_Asub[localRow + wR][localCol + wC];\n            let wVal = mm_Bsub[wR][wC];\n            value = fma(xVal, wVal, value);\n          }\n        }\n        ${Gn(this.addBias,this.activation)}\n        if (coordsInBounds4D(coords, uniforms.outShape)) {\n          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n        }\n      }\n    `}}class ai{constructor(e,t=!1,n=null,s=!1){this.variableNames=["x","W"],this.uniforms="pad : vec2<i32>, inDims : vec2<i32>,",this.workgroupSize=[4,4,4],this.workPerThread=4,this.isVec4=!0,this.outputShape=e.outShape,this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=bn(this.dispatchLayout,this.outputShape,this.workgroupSize,[4,this.workPerThread,1]),r.assert("channelsLast"===e.dataFormat,(()=>"TODO: NCHW is unimplemented")),t&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),this.convInfo=e,this.addBias=t,this.activation=n,this.hasPreluActivation=s,this.shaderKey=`depthwiseVec4_${n}_${this.convInfo.filterHeight}_${this.convInfo.filterWidth}_${this.convInfo.strideHeight}_${this.convInfo.strideWidth}_${this.workPerThread}`}getUserCode(){const e=(this.workPerThread-1)*this.convInfo.strideWidth+this.convInfo.filterWidth,t=this.convInfo.strideHeight,n=this.convInfo.strideWidth;return`\n      ${Vn(this.activation,this.hasPreluActivation,!0,4)}\n      fn readX(batch : i32, row : i32, col : i32, channel : i32) -> vec4<f32> {\n        var value = vec4<f32>(0.0);\n        if (col >=0 && col < uniforms.inDims[1]) {\n          value = getX(batch, row, col, channel);\n        }\n        return value;\n      }\n\n      ${on()} {\n        let batch = i32(globalId.z) / uniforms.outShape[1];\n        let r = i32(globalId.z) % uniforms.outShape[1];\n        let c = i32(globalId.y) * ${this.workPerThread};\n        let d1 = i32(globalId.x) * 4;\n        let xRCCorner = vec2<i32>(r, c) * vec2<i32>(${t}, ${n}) - uniforms.pad;\n\n        let xRCorner = xRCCorner.x;\n        let xCCorner = xRCCorner.y;\n        var xVals : array<vec4<f32>, ${e}>;\n        var dotProd : array<vec4<f32>, ${this.workPerThread}>;\n        for (var i = 0; i < ${this.workPerThread}; i++) {\n          dotProd[i] = vec4<f32>(0.0);\n        }\n\n        // Use constant instead of uniform can give better performance.\n        for (var wR = 0; wR < ${this.convInfo.filterHeight}; wR = wR + 1) {\n          let xR = xRCorner + wR;\n          if (xR >=0 && xR < uniforms.inDims[0]) {\n            for (var i = 0; i < ${e}; i++) {\n              xVals[i] = readX(batch, xR, xCCorner + i, d1);\n            }\n            for (var wC = 0; wC < ${this.convInfo.filterWidth}; wC = wC + 1) {\n              let wValue = getW(wR, wC, d1, 0);\n              for (var i = 0; i < ${this.workPerThread}; i++) {\n                dotProd[i] = fma(xVals[i * ${n} + wC], wValue, dotProd[i]);\n              }\n            }\n          }\n        }\n\n        for (var i = 0; i < ${this.workPerThread}; i = i + 1) {\n          let coords = vec4<i32>(batch, r, c + i, d1);\n          if (coordsInBounds4D(coords, uniforms.outShape)) {\n            var value = dotProd[i];\n            ${Gn(this.addBias,this.activation)}\n            setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n          }\n        }\n      }\n    `}}class ii{constructor(e,t=!1,n=null,r=!1){this.variableNames=["x","W"],this.uniforms="pad : vec2<i32>, inDims : vec2<i32>, filterHeight : i32,\n      filterWidth : i32, stride : vec2<i32>, dilation : vec2<i32>,",this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=In(this.outputShape),this.dispatch=bn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast="channelsLast"===e.dataFormat,t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),this.convInfo=e,this.addBias=t,this.activation=n,this.hasPreluActivation=r,this.shaderKey=`depthwise_${this.activation}_${this.isChannelsLast}`}getUserCode(){const e=this.isChannelsLast?"getX(batch, xR, xC, d1);":"getX(batch, d1, xR, xC);";return`\n      ${Vn(this.activation,this.hasPreluActivation,!1,4)}\n\n      ${on("index")} {\n        if (index < uniforms.size) {\n          let coords = getOutputCoords();\n          let batch = coords[0];\n          let xRCCorner = vec2<i32>(coords.${this.isChannelsLast?"yz":"zw"}) * uniforms.stride - uniforms.pad;\n          let d2 = coords[${this.isChannelsLast?3:1}];\n          let channelMul = uniforms.wShape[3];\n          let d1 = d2 / channelMul;\n          let q = d2 % channelMul;\n\n          let inputRowStart = xRCCorner.x;\n          let inputColStart = xRCCorner.y;\n          let inputRowEnd = inputRowStart + uniforms.filterHeight *\n              uniforms.dilation[0];\n          let inputColEnd = inputColStart + uniforms.filterWidth *\n              uniforms.dilation[1];\n\n          // Convolve x(?, ?, d1)|x(d1, ?, ?) with w(:, :, d1, q) to get\n          // y(yR, yC, d2)|y(d2, yR, yC). ? = to be determined. : = across all\n          // values in that axis. x(?, ?, d1) and y(yR, yC, d2) is for NHWC.\n          // x(d1, ?, ?) and y(d2, yR, yC) is for NCHW.\n          var value = 0.0;\n\n          // Extract if checking out of for loop for performance.\n          if (inputRowStart >= 0 && inputColStart >= 0 &&\n            inputRowEnd < uniforms.inDims[0] &&\n                inputColEnd < uniforms.inDims[1]) {\n              for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {\n                let xR = inputRowStart + wR * uniforms.dilation[0];\n\n                for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {\n                  let xC = inputColStart + wC * uniforms.dilation[1];\n\n                  let xVal = ${e};\n                  let wVal = getW(wR, wC, d1, q);\n                  value = value + xVal * wVal;\n                }\n              }\n            } else {\n              for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {\n                let xR = inputRowStart + wR * uniforms.dilation[0];\n\n                if (xR < 0 || xR >= uniforms.inDims[0]) {\n                  continue;\n                }\n\n                for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {\n                  let xC = inputColStart + wC * uniforms.dilation[1];\n\n                  if (xC < 0 || xC >= uniforms.inDims[1]) {\n                    continue;\n                  }\n\n                  let xVal = ${e};\n                  let wVal = getW(wR, wC, d1, q);\n                  value = value + xVal * wVal;\n                }\n              }\n            }\n            ${Gn(this.addBias,this.activation)}\n          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n        }\n      }\n    `}}const oi={kernelName:ue,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:r,attrs:s}=e,{x:a,filter:i}=t,{strides:o,pad:u,dataFormat:l,dilations:h,dimRoundingMode:d}=s,p=n.convertConv2DDataFormat(l);let c=h;null==c&&(c=[1,1]);const f=n.computeConv2DInfo(a.shape,i.shape,o,c,u,d,!0,p),m=[{type:"int32",data:[f.padInfo.top,f.padInfo.left]},{type:"int32",data:[f.inHeight,f.inWidth]}],g="channelsLast"===f.dataFormat;let b;return!g&&f.inHeight>16&&f.inWidth>16&&1===f.strideHeight&&1===f.strideWidth&&1===f.dilationWidth&&1===f.dilationHeight&&f.inChannels===f.outChannels?b=new si(f.outShape,f.filterHeight,f.filterWidth):g&&f.outHeight>4&&f.outWidth>4&&f.strideWidth<=2&&f.inChannels===f.outChannels&&1===f.dilationHeight&&1===f.dilationWidth&&f.inChannels%4==0?b=new ai(f):(b=new ii(f),m.push({type:"int32",data:[f.filterHeight]},{type:"int32",data:[f.filterWidth]},{type:"int32",data:[f.strideHeight,f.strideWidth]},{type:"int32",data:[f.dilationHeight,f.dilationWidth]})),r.runWebGPUProgram(b,[a,i],a.dtype,m)}};class ui{constructor(e){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e,e],this.dispatchLayout=In(this.outputShape),this.dispatch=bn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="diag"}getUserCode(){return`\n      ${on("index")} {\n        if (index < uniforms.size) {\n          let coords = getOutputCoords();\n          let value = select(0.0, getX(coords[0]), coords[0] == coords[1]);\n          setOutputAtIndex(index, value);\n        }\n      }\n    `}}const li={kernelName:le,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:s}=t,a=[...s.shape,...s.shape],i=r.sizeFromShape(s.shape),o=sr({inputs:{x:s},backend:n,attrs:{shape:[i]}}),u=new ui(i),l=n.runWebGPUProgram(u,[o],o.dtype),h=sr({inputs:{x:l},backend:n,attrs:{shape:a}});return n.disposeData(o.dataId),n.disposeData(l.dataId),h}};class hi{constructor(e){this.variableNames=["x","w"],this.uniforms="filterDims: vec2<i32>, pad: vec2<i32>, stride: vec2<i32>, dilation: vec2<i32>",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=In(this.outputShape),this.dispatch=bn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="dilation2d"}getUserCode(){return`\n       ${on("index")} {\n         if (index < uniforms.size) {\n           let neg_infinity = -3.4e38;\n           let coords = getOutputCoords();\n           let batch = coords.x;\n           let d1 = coords.w;\n           let outTopLeftCorner = coords.yz * uniforms.stride - uniforms.pad;\n           let hBeg = outTopLeftCorner.x;\n           let wBeg = outTopLeftCorner.y;\n\n           var curVal = neg_infinity;\n           for (var h = 0; h < uniforms.filterDims[0]; h = h + 1) {\n             let hIn = hBeg + h * uniforms.dilation[0];\n\n             if (hIn >= 0 && hIn < uniforms.xShape[1]) {\n               for (var w = 0; w < uniforms.filterDims[1]; w = w + 1) {\n                 let wIn = wBeg + w * uniforms.dilation[1];\n\n                 if (wIn >= 0 && wIn < uniforms.xShape[2]) {\n                   let val = getX(batch, hIn, wIn, d1) + getW(h, w, d1);\n                   if (val > curVal) {\n                     curVal = val;\n                   }\n                 }\n               }\n             }\n           }\n\n           setOutputAtIndex(index, curVal);\n         }\n       }\n     `}}const di={kernelName:he,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:r,attrs:s}=e,{x:a,filter:i}=t,{strides:o,pad:u,dilations:l}=s,h=n.computeDilation2DInfo(a.shape,i.shape,o,u,"NHWC",l),d=[h.padInfo.top,h.padInfo.left],p=[{type:"int32",data:[h.filterHeight,h.filterWidth]},{type:"int32",data:[...d]},{type:"int32",data:[h.strideHeight,h.strideWidth]},{type:"int32",data:[h.dilationHeight,h.dilationWidth]}],c=new hi(h);return r.runWebGPUProgram(c,[a,i],a.dtype,p)}},pi=gr({opType:Tn.MUL,cpuKernelImpl:ms,supportsComplex:!0}),ci={kernelName:de,backendName:"webgpu",kernelFunc:pi};function fi(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;return Ms(s,a,i,"sum",n)}const mi={kernelName:pe,backendName:"webgpu",kernelFunc:fi};const gi={kernelName:ce,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:s,attrs:a}=e,{equation:i}=a,o=t,{allDims:u,summedDims:l,idDims:h}=n.decodeEinsumEquation(i,o.length);n.checkEinsumDimSizes(u.length,h,o);const{path:d,steps:p}=n.getEinsumComputePath(l,h),c=p.length;let f=null,m=u.length;const g=[];for(let e=0;e<c;++e){for(const t of p[e]){const{permutationIndices:e,expandDims:a}=n.getEinsumPermutation(m,h[t]);let i;n.isIdentityPermutation(e)?i=o[t]:(i=Us({inputs:{x:o[t]},backend:s,attrs:{perm:e}}),g.push(i));const u=i.shape.slice();for(let e=0;e<a.length;++e)u.splice(a[e],0,1);r.arraysEqual(i.shape,u)||(i=sr({inputs:{x:i},backend:s,attrs:{shape:u}}),g.push(i)),null===f?f=i:(f=pi({inputs:{a:i,b:f},backend:s}),g.push(f))}e<c-1&&(d[e]>=0&&(f=fi({inputs:{x:f},backend:s,attrs:{axis:d[e]-(u.length-m),keepDims:!1}}),g.push(f)),m--)}for(const e of g)e!==f&&s.disposeData(e.dataId);return f}},bi={kernelName:fe,backendName:"webgpu",kernelFunc:mr({opType:Ln.ELU})},xi={kernelName:me,backendName:"webgpu",kernelFunc:gr({opType:Tn.EQUAL,dtype:"bool",cpuKernelImpl:ts})},wi={kernelName:ge,backendName:"webgpu",kernelFunc:mr({opType:Ln.ERF})},yi=mr({opType:Ln.EXP,cpuKernelImpl:ns,dtype:"float32"}),Ii={kernelName:be,backendName:"webgpu",kernelFunc:yi};function Si(e){const{inputs:t,attrs:n,backend:s}=e,{dim:a}=n,{input:i}=t,o=i.shape.length,u=i.shape.slice();let l=a;return a<0&&(r.assert(-(o+1)<=a,(()=>`Axis must be in the interval [${-(o+1)}, ${o}]`)),l=o+a+1),u.splice(l,0,1),sr({inputs:{x:i},backend:s,attrs:{shape:u}})}const ki={kernelName:xe,backendName:"webgpu",kernelFunc:Si},vi={kernelName:we,backendName:"webgpu",kernelFunc:mr({opType:Ln.EXPM1,cpuKernelImpl:rs})};class Ci{constructor(e,t){this.variableNames=["real","imag"],this.outputShape=[],this.uniforms="exponentMultiplier : f32, denominator: f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=In(this.outputShape),this.dispatch=bn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.component=e,this.shaderKey=`fft_${e}`}getUserCode(){return`\n    fn unaryOpComplex(real: f32, expR: f32, imag: f32, expI: f32) -> f32 {\n      ${"real"===this.component?"return real * expR - imag * expI;":"return real * expI + imag * expR;"}\n    }\n\n    fn mulMatDFT(batch: i32, index: i32) -> f32 {\n      let indexRatio = f32(index) / f32(uniforms.realShape[1]);\n      let exponentMultiplierTimesIndexRatio =\n          uniforms.exponentMultiplier * indexRatio;\n\n      var result = 0.0;\n\n      for (var i = 0; i < uniforms.realShape[1]; i = i + 1) {\n        // x = (-2|2 * PI / N) * index * i;\n        let x = exponentMultiplierTimesIndexRatio * f32(i);\n        let expR = cos(x);\n        let expI = sin(x);\n        let real = getReal(batch, i);\n        let imag = getImag(batch, i);\n\n        result = result +\n            unaryOpComplex(real, expR, imag, expI) / uniforms.denominator;\n      }\n\n      return result;\n    }\n\n    ${on("index")} {\n      if (index < uniforms.size) {\n        let coords = getOutputCoords();\n        setOutputAtIndex(index, mulMatDFT(coords[0], coords[1]));\n      }\n    }\n  `}}function $i(e,t,n){const s=n.tensorMap.get(e.dataId),a=r.sizeFromShape(e.shape),i=e.shape[e.shape.length-1],o=[],u=sr({inputs:{x:e},backend:n,attrs:{shape:[a/i,i]}});o.push(u);const l=u.shape,h=new Ci("real",l),d=new Ci("imag",l),p=[{dataId:s.complexTensorInfos.real.dataId,dtype:s.complexTensorInfos.real.dtype,shape:l},{dataId:s.complexTensorInfos.imag.dataId,dtype:s.complexTensorInfos.imag.dtype,shape:l}],c=[{type:"float32",data:[t?2*Math.PI:-2*Math.PI]},{type:"float32",data:[t?l[1]:1]}],f=n.runWebGPUProgram(h,p,"float32",c);o.push(f);const m=n.runWebGPUProgram(d,p,"float32",c);o.push(m);const g=pr({inputs:{real:f,imag:m},backend:n});o.push(g);const b=sr({inputs:{x:g},backend:n,attrs:{shape:e.shape}});return o.forEach((e=>n.disposeData(e.dataId))),b}const Ri={kernelName:ye,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:r}=t;return $i(r,!1,n)}};class Ai{constructor(e){this.outputShape=[],this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=In(this.outputShape),this.dispatch=bn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="flipLeftRight"}getUserCode(){return`\n      ${on("index")} {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let coordX = uniforms.xShape[2] - coords[2] - 1;\n          let outputValue = getX(coords[0], coords[1], coordX, coords[3]);\n          setOutputAtIndex(index, outputValue);\n        }\n      }\n    `}}const Ti={kernelName:Ie,backendName:"webgpu",kernelFunc:({inputs:e,backend:t})=>{const{image:n}=e,r=t,s=new Ai(n.shape);return r.runWebGPUProgram(s,[n],n.dtype)}},Pi={kernelName:Se,backendName:"webgpu",kernelFunc:mr({opType:Ln.FLOOR,cpuKernelImpl:ss})},Ni={kernelName:ke,backendName:"webgpu",kernelFunc:gr({opType:Tn.INT_DIV,dtype:"int32"})};class zi{constructor(e,t,n=!1){this.isFromPixels=!0,this.outputShape=[0],this.variableNames=[],this.workgroupSize=[256,1,1],this.outputShape=e,this.dispatchLayout=In(this.outputShape),this.dispatch=bn(this.dispatchLayout,this.outputShape,this.workgroupSize,[t,1,1]),this.importVideo=n,this.shaderKey=`fromPixels_${this.importVideo}`}getUserCode(){const e=this.importVideo?"textureLoad(src, vec2<i32>(coords.yx));":"textureLoad(src, vec2<i32>(coords.yx), 0)";return`\n      @binding(1) @group(0) var src: ${this.importVideo?"texture_external":"texture_2d<f32>"};\n      ${on("index")} {\n        let flatIndex = index * uniforms.numChannels;\n        if (flatIndex < uniforms.size) {\n          let coords = getCoordsFromIndex(flatIndex);\n          let values = ${e};\n          for (var i = 0; i < uniforms.numChannels; i = i + 1) {\n            result[flatIndex + i] = i32(floor(255.0 * values[i]));\n          }\n        }\n      }\n  `}}const Ei={kernelName:ve,backendName:"webgpu",kernelFunc:function(e){const{inputs:n,backend:s,attrs:a}=e;let{pixels:i}=n;const{numChannels:o}=a;if(null==i)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");const u="undefined"!=typeof HTMLVideoElement&&i instanceof HTMLVideoElement,l="undefined"!=typeof HTMLImageElement&&i instanceof HTMLImageElement,h="undefined"!=typeof HTMLCanvasElement&&i instanceof HTMLCanvasElement||"undefined"!=typeof OffscreenCanvas&&i instanceof OffscreenCanvas,d="undefined"!=typeof ImageBitmap&&i instanceof ImageBitmap,[p,c]=u?[i.videoWidth,i.videoHeight]:[i.width,i.height],f=[c,p,o],m=u||l;if(d||h||m){let e;{if(m){const e=t().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");null!=Fi&&e===Bi||(Bi=e,Fi=document.createElement("canvas").getContext("2d",{willReadFrequently:Bi})),Fi.canvas.width=p,Fi.canvas.height=c,Fi.drawImage(i,0,0,p,c),i=Fi.canvas}const n=GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING,r="rgba8unorm",a=s.textureManager.acquireTexture(f[1],f[0],r,n);s.queue.copyExternalImageToTexture({source:i},{texture:a},[f[1],f[0]]),e={width:p,height:c,format:r,usage:n,texture:a}}const n=r.sizeFromShape(f),a=r.computeStrides(f),u=new zi(f,o,false),l=[{type:"uint32",data:[n]},{type:"uint32",data:[o]},{type:"uint32",data:[...a]}],h=s.makeTensorInfo([c,p],"int32");s.tensorMap.get(h.dataId).resourceInfo=e;const d=s.runWebGPUProgram(u,[h],"int32",l);return s.disposeData(h.dataId),d}const g=i.data;let b=g;if(null!=o&&4!==o){b=new Uint8Array(i.width*i.height*o);const e=g.length;let t=0;for(let n=0;n<e;n++)n%4<o&&(b[t++]=g[n])}const x=s.makeTensorInfo(f,"int32",new Int32Array(b));return s.uploadToGPU(x.dataId),x}};let Fi,Bi=t().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");class _i{constructor(e,t,r,s,a){this.uniforms="varianceEpsilon : f32,",this.workgroupSize=[128,1,1],this.size=!0,this.variableNames=["x","mean","variance"],n.assertAndGetBroadcastShape(e,t),n.assertAndGetBroadcastShape(e,r),this.outputShape=e,this.dispatchLayout=In(this.outputShape),this.dispatch=bn(this.dispatchLayout,this.outputShape,this.workgroupSize),null!=s&&(n.assertAndGetBroadcastShape(e,s),this.variableNames.push("offset")),null!=a&&(n.assertAndGetBroadcastShape(e,a),this.variableNames.push("scale")),this.offsetShape=s,this.scaleShape=a,this.shaderKey="batchNorm"}getUserCode(){let e="0.0";null!=this.offsetShape&&(e="getOffsetByOutputIndex(index)");let t="1.0";null!=this.scaleShape&&(t="getScaleByOutputIndex(index)");return`\n      ${on("index")} {\n        if (index < uniforms.size)\n        {\n          let xValue = getXByOutputIndex(index);\n          let meanValue = getMeanByOutputIndex(index);\n          let varianValue = getVarianceByOutputIndex(index);\n          let offsetValue = ${e};\n          let scaleValue = ${t};\n          let inv = scaleValue * inverseSqrt(varianValue + f32(uniforms.varianceEpsilon));\n          setOutputAtIndex(index,dot(vec3<f32>(xValue, -meanValue, offsetValue), vec3<f32>(inv, inv, 1.0)));\n        }\n      }\n  `}}const Oi={kernelName:Ce,backendName:"webgpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:r,scale:s,offset:a,mean:i,variance:o}=e,{varianceEpsilon:u}=t,l=n,h=[r,i,o];let d=null;null!=a&&(d=a.shape,h.push(a));let p=null;null!=s&&(p=s.shape,h.push(s));const c=new _i(r.shape,i.shape,o.shape,d,p),f=[{type:"float32",data:[u]}];return l.runWebGPUProgram(c,h,r.dtype,f)}};const Li={kernelName:$e,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:r,attrs:s}=e,{x:a,filter:i,bias:o,preluActivationWeights:u}=t,{strides:l,pad:h,dataFormat:d,dilations:p,dimRoundingMode:c,activation:f,leakyreluAlpha:m}=s,g=n.convertConv2DDataFormat(d);return Oa({x:a,filter:i,convInfo:n.computeConv2DInfo(a.shape,i.shape,l,p,h,c,!1,g),backend:r,bias:o,preluActivationWeights:u,leakyreluAlpha:m,activation:f})}};const Ui={kernelName:Re,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:s,attrs:a}=e,{x:i,filter:o,bias:u,preluActivationWeights:l}=t,{strides:h,pad:d,dilations:p,dimRoundingMode:c,activation:f,leakyreluAlpha:m}=a;let g=p;null==g&&(g=[1,1]),r.assert(n.eitherStridesOrDilationsAreOne(h,g),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${h} and dilations '${g}'`));const b=n.computeConv2DInfo(i.shape,o.shape,h,g,d,c,!0),x=[i,o],w=null!=u,y=null!=l;w&&x.push(u),y&&x.push(l);const I=[{type:"int32",data:[b.padInfo.top,b.padInfo.left]},{type:"int32",data:[b.inHeight,b.inWidth]}];let S;return b.outHeight>4&&b.outWidth>4&&b.strideWidth<=2&&b.inChannels===b.outChannels&&1===b.dilationHeight&&1===b.dilationWidth&&b.inChannels%4==0?S=new ai(b,w,f,y):(S=new ii(b,w,f,y),I.push({type:"int32",data:[b.filterHeight]},{type:"int32",data:[b.filterWidth]},{type:"int32",data:[b.strideHeight,b.strideWidth]},{type:"int32",data:[b.dilationHeight,b.dilationWidth]})),"leakyrelu"===f&&(I.push({type:"float32",data:[m]}),S.uniforms+=" alpha : f32,"),s.runWebGPUProgram(S,x,"float32",I)}};class Di{constructor(e,t){this.variableNames=["A","indices"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=In(this.outputShape),this.dispatch=bn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey=`gathernd_${e}`,this.sliceDim=e,this.uniforms=`sliceDim : i32, strides : ${sn(e)},`}getUserCode(){let e;e=this.sliceDim>1?"uniforms.strides[j]":"uniforms.strides";return`\n      ${on("index")} {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          var flattenIndex = 0;\n          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {\n            let indexTemp = i32(round(getIndices(coords[0], j)));\n            let strideNum = ${e};\n            flattenIndex = flattenIndex + indexTemp * strideNum;\n          }\n\n          setOutputAtIndex(index, getA(flattenIndex, coords[1]));\n        }\n      }\n      `}}const Wi={kernelName:Ae,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:s}=e,{params:a,indices:i}=t,o=i.shape,u=o[o.length-1],l=r.sizeFromShape(a.shape),[h,d,p,c]=n.prepareAndValidate(a,i),f=sr({inputs:{x:i},backend:s,attrs:{shape:[d,u]}}),m=sr({inputs:{x:a},backend:s,attrs:{shape:[r.sizeFromShape(a.shape)/p,p]}});if(s.shouldExecuteOnCPU([a,i])||"string"===a.dtype){const e=s.readSync(i.dataId),t=s.bufferSync(a),n=as(e,t,a.dtype,d,u,p,c,a.shape,l);return s.makeTensorInfo(h,a.dtype,n.values)}const g=new Di(u,[d,p]),b=[{type:"int32",data:[u]},{type:"int32",data:c}],x=s.runWebGPUProgram(g,[m,f],m.dtype,b),w=sr({inputs:{x:x},backend:s,attrs:{shape:h}});return s.disposeData(f.dataId),s.disposeData(m.dataId),s.disposeData(x.dataId),w}};class Mi{constructor(e,t){this.variableNames=["A","indices"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.slice(),this.aShape=e,this.outputShape=t,this.dispatchLayout=In(this.outputShape),this.dispatch=bn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="gather"}getUserCode(){const e=function(e){const t=["resRC.x","resRC.y","resRC.z","resRC.w"],n=[];for(let r=0;r<e.length;r++)2===r?n.push("indexZ"):n.push(`${t[r]}`);return n.join()}(this.aShape);return`\n      ${on("index")} {\n        if (index < uniforms.size) {\n          let resRC = getCoordsFromIndex(index);\n          let indexZ = i32(getIndices(resRC.x, resRC.z));\n          let inBounds = select(0.0, 1.0, indexZ >= 0 && indexZ < uniforms.aShape[2]);\n          setOutputAtIndex(index, inBounds * getA(${e}));\n        }\n      }\n    `}}function Vi(e){const{inputs:t,backend:s,attrs:a}=e,{x:i,indices:u}=t,{axis:l,batchDims:h}=a,d=r.parseAxisParam(l,i.shape)[0],p=n.segment_util.collectGatherOpShapeInfo(i,u,d,h),c=r.sizeFromShape(u.shape),f=[],m=sr({inputs:{x:i},backend:s,attrs:{shape:[p.batchSize,p.outerSize,p.dimSize,p.sliceSize]}}),g=sr({inputs:{x:u},backend:s,attrs:{shape:[p.batchSize,c/p.batchSize]}});f.push(m),f.push(g);const b=[p.batchSize,p.outerSize,c/p.batchSize,p.sliceSize];if(s.shouldExecuteOnCPU([i,u])){const e=s.tensorMap.get(g.dataId).values,t=o(g.shape,g.dtype,e),n=s.tensorMap.get(m.dataId).values,r=o(m.shape,m.dtype,n),a=is(r,t,b);return f.forEach((e=>s.disposeData(e.dataId))),s.makeTensorInfo(p.outputShape,a.dtype,a.values)}const x=new Mi(m.shape,b),w=s.runWebGPUProgram(x,[m,g],m.dtype);f.push(w);const y=sr({inputs:{x:w},backend:s,attrs:{shape:p.outputShape}});return f.forEach((e=>s.disposeData(e.dataId))),y}const Gi={kernelName:Te,backendName:"webgpu",kernelFunc:Vi},Hi={kernelName:Pe,backendName:"webgpu",kernelFunc:gr({opType:Tn.GREATER,cpuKernelImpl:us,dtype:"bool"})},Xi={kernelName:Ne,backendName:"webgpu",kernelFunc:gr({opType:Tn.GREATER_EQUAL,dtype:"bool",cpuKernelImpl:os})};const Ki={kernelName:ze,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:r}=t;return $i(r,!0,n)}},qi={kernelName:Ee,backendName:"webgpu",kernelFunc:mr({opType:Ln.IS_FINITE,dtype:"bool"})},ji={kernelName:Fe,backendName:"webgpu",kernelFunc:mr({opType:Ln.IS_INF,dtype:"bool"})},Yi={kernelName:Be,backendName:"webgpu",kernelFunc:mr({opType:Ln.IS_NAN,dtype:"bool"})};const Qi={kernelName:_e,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{alpha:a}=r,i=[{type:"float32",data:[a]}],o=new fr(s.shape,Ln.LEAKYRELU,"alpha : f32,");return n.runWebGPUProgram(o,[s],"float32",i)}},Zi={kernelName:Oe,backendName:"webgpu",kernelFunc:gr({opType:Tn.LESS,dtype:"bool",cpuKernelImpl:hs})},Ji={kernelName:Le,backendName:"webgpu",kernelFunc:gr({opType:Tn.LESS_EQUAL,dtype:"bool",cpuKernelImpl:ls})};class eo{constructor(e){this.variableNames=[],this.outputShape=[],this.uniforms="start : f32, step : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e],this.dispatchLayout=In(this.outputShape),this.dispatch=bn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="linSpace"}getUserCode(){return`\n      ${on("index")} {\n        if (index < uniforms.size) {\n          setOutputAtIndex(index, uniforms.start + f32(index) * uniforms.step);\n        }\n      }\n    `}}const to={kernelName:Ue,backendName:"webgpu",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:r,stop:s,num:a}=n,i=(s-r)/(a-1),o=new eo(a),u=[{type:"float32",data:[r]},{type:"float32",data:[i]}];return t.runWebGPUProgram(o,[],"float32",u)}},no={kernelName:De,backendName:"webgpu",kernelFunc:mr({opType:Ln.LOG,cpuKernelImpl:ds})},ro={kernelName:We,backendName:"webgpu",kernelFunc:mr({opType:Ln.LOG1P})},so={kernelName:Me,backendName:"webgpu",kernelFunc:gr({opType:Tn.LOGICAL_AND,dtype:"bool"})},ao={kernelName:Ve,backendName:"webgpu",kernelFunc:mr({opType:Ln.LOGICAL_NOT})},io={kernelName:Ge,backendName:"webgpu",kernelFunc:gr({opType:Tn.LOGICAL_OR})},oo="\n  var powValue = 0.0;\n  let basis = uniforms.bias + uniforms.alpha * sum;\n  if (uniforms.beta == 0.5) {\n    powValue = inverseSqrt(basis);\n  } else if (uniforms.beta == 1.0) {\n    powValue = 1.0 / basis;\n  } else {\n    powValue = exp(log(basis) * (-uniforms.beta));\n  }\n";class uo{constructor(e){this.outputShape=[],this.variableNames=["x"],this.uniforms="radius : i32, bias : f32, alpha : f32, beta : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=In(this.outputShape),this.dispatch=bn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="lrn"}getUserCode(){return`\n    ${on("index")} {\n      if (index < uniforms.size) {\n        let coords = getOutputCoords();\n        let b = coords[0];\n        let r = coords[1];\n        let c = coords[2];\n        let d = coords[3];\n\n        let x = getX(b, r, c, d);\n        var sum = 0.0;\n        for (var i = -uniforms.radius; i <= uniforms.radius; i = i + 1) {\n          let idx = d + i;\n          if (idx >= 0 && idx < uniforms.xShape[3]) {\n            let z = getX(b, r, c, idx);\n            sum = sum + z * z;\n          }\n        }\n        ${oo}\n\n        setOutputAtIndex(index, x * powValue);\n      }\n    }\n  `}}class lo{constructor(e,t){this.outputShape=[],this.variableNames=["x"],this.uniforms="radius : i32, bias : f32, alpha : f32, beta : f32,",this.workgroupSize=[256,1,1],this.maxAllowRadius=16,r.assert(t<=this.maxAllowRadius,(()=>`Radius must be less than or equal to ${this.maxAllowRadius}, current radius is ${t}`)),this.outputShape=e,this.elementsPerWorkgroup=this.workgroupSize[0]-2*this.maxAllowRadius,this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=bn(this.dispatchLayout,this.outputShape,[this.elementsPerWorkgroup,this.workgroupSize[1],this.workgroupSize[2]]),this.shaderKey="lrn_shared"}getUserCode(){return`\n    var <workgroup>lrnSub: array<f32, ${this.workgroupSize[0]}>;\n    const elementsPerWorkgroup = ${this.elementsPerWorkgroup};\n    const maxAllowRadius = ${this.maxAllowRadius};\n\n    ${on()} {\n      let localDepth = i32(localId.x);\n      let workgroupDepth = i32(workgroupId.x) * elementsPerWorkgroup;\n      let xDepth = workgroupDepth + localDepth - maxAllowRadius;\n      let b = i32(globalId.z) / uniforms.xShape[1];\n      let r = i32(globalId.z) - b * uniforms.xShape[1];\n      let c = i32(globalId.y);\n      let d = workgroupDepth + localDepth;\n\n      var x = 0.0;\n      if (xDepth >= 0 && xDepth < uniforms.xShape[3]) {\n        x = getX(b, r, c, xDepth);\n      }\n      lrnSub[localDepth] = x;\n      workgroupBarrier();\n\n      if (localDepth < elementsPerWorkgroup && d < uniforms.outShape[3]) {\n        var sum = 0.0;\n        let index = localDepth + maxAllowRadius;\n        for (var i = -uniforms.radius; i <= uniforms.radius; i = i + 1) {\n          let z = lrnSub[index + i];\n          sum = sum + z * z;\n        }\n        ${oo}\n\n        setOutputAtCoords(b, r, c, d, lrnSub[index] * powValue);\n      }\n    } `}}const ho={kernelName:He,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{depthRadius:a,bias:i,alpha:o,beta:u}=r;let l;l=a>16?new uo(s.shape):new lo(s.shape,a);const h=[{type:"int32",data:[a]},{type:"float32",data:[i]},{type:"float32",data:[o]},{type:"float32",data:[u]}];return n.runWebGPUProgram(l,[s],s.dtype,h)}},po={kernelName:Xe,backendName:"webgpu",kernelFunc:gr({opType:Tn.MAX,cpuKernelImpl:cs})};const co={kernelName:Ke,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:r,attrs:s}=e,{x:a}=t,{filterSize:i,strides:o,pad:u,dimRoundingMode:l}=s;return aa(a,n.computePool2DInfo(a.shape,i,o,1,u,l),"max",r)}};const fo={kernelName:qe,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;return Ms(s,a,i,"min",n)}},mo={kernelName:je,backendName:"webgpu",kernelFunc:gr({opType:Tn.MIN,cpuKernelImpl:fs})};class go{constructor(e,t,n){this.uniforms="",this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1])),this.dispatchLayout=In(this.outputShape),this.dispatch=bn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.xShape=e,t.map(((e,t)=>{this.uniforms+=` pad${t} : vec2<i32>,`})),this.offset="reflect"===n?0:1,this.shaderKey=`mirrorPad_${n}`}getUserCode(){const e=this.xShape.length,t=this.xShape.map(((e,t)=>`uniforms.pad${t}[0]`)).join(","),n=this.xShape.map(((t,n)=>`uniforms.pad${n}[0] + uniforms.xShape${e>1?`[${n}]`:""}`)).join(","),r=1===e?"start":"start[i]",s=1===e?"end":"end[i]",a=1===e?"outC":"outC[i]",i=sn(e),o=e>1?["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,e):"coords";return`\n      ${on("index")} {\n        if (index < uniforms.size) {\n          let start = ${i}(${t});\n          let end = ${i}(${n});\n          var outC = getCoordsFromIndex(index);\n          for (var i = 0; i < ${e}; i = i + 1) {\n            if (${a} < ${r}) {\n              ${a} = ${r} * 2 - ${a} - ${this.offset};\n            } else if(${a} >= ${s}) {\n              ${a} = (${s} - 1) * 2 - ${a} + ${this.offset};\n            }\n          }\n          let coords = outC - start;\n          setOutputAtIndex(index, getX(${o}));\n        }\n      }\n    `}}const bo={kernelName:Ye,backendName:"webgpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:r}=e,{paddings:s,mode:a}=t,i=n,o=s.map((e=>({type:"int32",data:[e[0],e[1]]}))),u=new go(r.shape,s,a);return i.runWebGPUProgram(u,[r],r.dtype,o)}},xo={kernelName:Qe,backendName:"webgpu",kernelFunc:gr({opType:Tn.MOD})};const wo={kernelName:Ze,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t;if(n.shouldExecuteOnCPU([r])){const e=n.tensorMap.get(r.dataId),[t,s]=gs(e.values,r.shape,r.dtype);return n.makeTensorInfo(s,r.dtype,t)}const s=new fr(r.shape,Ln.NEG);return n.runWebGPUProgram(s,[r],r.dtype)}};const yo={kernelName:Je,backendName:"webgpu",kernelFunc:function(e){console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:u}=r,l=n.readSync(s.dataId),h=n.readSync(a.dataId),{selectedIndices:d}=et.nonMaxSuppressionV3Impl(l,h,i,o,u);return n.makeTensorInfo([d.length],"int32",new Int32Array(d))}};const Io={kernelName:tt,backendName:"webgpu",kernelFunc:function(e){console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:u,softNmsSigma:l}=r,h=n.readSync(s.dataId),d=n.readSync(a.dataId),p=i,c=o,f=u,m=l,{selectedIndices:g,selectedScores:b}=et.nonMaxSuppressionV5Impl(h,d,p,c,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([b.length],"float32",new Float32Array(b))]}};class So{constructor(e,t){this.variableNames=["x"],this.uniforms="onValue : f32, offValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e,t],this.dispatchLayout=In(this.outputShape),this.dispatch=bn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="onehot"}getUserCode(){return`\n      ${on("index")} {\n        if(index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          setOutputAtIndex(index, mix(uniforms.offValue, uniforms.onValue,\n                                      f32(i32(round(getX(coords.x))) == coords.y)));\n        }\n      }\n    `}}const ko={kernelName:nt,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{indices:a}=t,{dtype:i,depth:o,onValue:u,offValue:l}=s,h=r.sizeFromShape(a.shape),d=new So(h,o),p=sr({inputs:{x:a},backend:n,attrs:{shape:[h]}}),c=[{type:"float32",data:[u]},{type:"float32",data:[l]}],f=n.runWebGPUProgram(d,[p],i,c);n.disposeData(p.dataId);const m=sr({inputs:{x:f},backend:n,attrs:{shape:[...a.shape,o]}});return n.disposeData(f.dataId),m}};function vo(e){const{inputs:t,backend:n}=e,{x:r}=t;if("complex64"===r.dtype){const e=ya({inputs:{input:r},backend:n}),t=vo({inputs:{x:e},backend:n}),s=Aa({inputs:{input:r},backend:n}),a=vo({inputs:{x:s},backend:n}),i=pr({inputs:{real:t,imag:a},backend:n});return n.disposeData(e.dataId),n.disposeData(t.dataId),n.disposeData(s.dataId),n.disposeData(a.dataId),i}return nr({attrs:{shape:r.shape,dtype:r.dtype,value:"string"===r.dtype?"":0},backend:n})}const Co={kernelName:rt,backendName:"webgpu",kernelFunc:vo};const $o={kernelName:st,backendName:"webgpu",kernelFunc:function e(t){const{inputs:n,backend:r}=t,{x:s}=n;if("string"===s.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===s.dtype){const t=ya({inputs:{input:s},backend:r}),n=e({inputs:{x:t},backend:r}),a=Aa({inputs:{input:s},backend:r}),i=vo({inputs:{x:a},backend:r}),o=pr({inputs:{real:n,imag:i},backend:r});return r.disposeData(t.dataId),r.disposeData(n.dataId),r.disposeData(a.dataId),r.disposeData(i.dataId),o}return nr({attrs:{shape:s.shape,dtype:s.dtype,value:1},backend:r})}};const Ro={kernelName:at,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{axis:a}=s;if(1===t.length)return Si({inputs:{input:t[0]},backend:n,attrs:{dim:a}});const i=t[0].shape,o=t[0].dtype;t.forEach((e=>{r.assertShapesMatch(i,e.shape,"All tensors passed to stack must have matching shapes"),r.assert(o===e.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));const u=[],l=Na({inputs:t.map((e=>{const t=Si({inputs:{input:e},backend:n,attrs:{dim:a}});return u.push(t),t})),backend:n,attrs:{axis:a}});return u.forEach((e=>n.disposeData(e.dataId))),l}};class Ao{constructor(e,t){this.variableNames=["x"],this.uniforms="constantValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1])),this.dispatchLayout=In(this.outputShape),this.dispatch=bn(this.dispatchLayout,this.outputShape,this.workgroupSize),t.map(((e,t)=>{this.uniforms+=` pad${t} : vec2<i32>,`})),this.xShape=e,this.shaderKey="pad"}getUserCode(){const e=this.xShape.length,t=sn(e),n=this.xShape.map(((e,t)=>`uniforms.pad${t}[0]`)).join(","),r=this.xShape.map(((t,n)=>`uniforms.pad${n}[0] + uniforms.xShape${e>1?`[${n}]`:""}`)).join(","),s=e>1?`${t}(${n})`:`${n}`,a=e>1?`${t}(${r})`:`${r}`,i=e>1?"any(outC < start)":"outC < start",o=e>1?"any(outC >= end)":"outC >= end",u=e>1?["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,e):"coords";return`\n      ${on("index")} {\n        if (index < uniforms.size) {\n          let start = ${s};\n          let end = ${a};\n          let outC = getCoordsFromIndex(index);\n\n          if (${i} || ${o}) {\n            setOutputAtIndex(index, uniforms.constantValue);\n          } else {\n            let coords = outC - start;\n            setOutputAtIndex(index, getX(${u}));\n          }\n        }\n      }\n    `}}const To=e=>{const{inputs:t,backend:n,attrs:s}=e,{x:a}=t,{paddings:i,constantValue:o}=s;if(i.every((e=>r.arraysEqual(e,[0,0]))))return hr({inputs:{x:a},backend:n});if(0===r.sizeFromShape(a.shape)){return nr({backend:n,attrs:{shape:i.map(((e,t)=>e[0]+a.shape[t]+e[1])),value:o,dtype:a.dtype}})}const u=[{type:"float32",data:[o]}];i.map((e=>u.push({type:"int32",data:[e[0],e[1]]})));const l=new Ao(a.shape,i);return n.runWebGPUProgram(l,[a],a.dtype,u)},Po={kernelName:it,backendName:"webgpu",kernelFunc:To},No={kernelName:ot,backendName:"webgpu",kernelFunc:gr({opType:Tn.POW})};const zo={kernelName:ut,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r,alpha:s}=t,a=new lr(Tn.PRELU,r.shape,s.shape);return n.runWebGPUProgram(a,[r,s],"float32")}};const Eo={kernelName:lt,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;return Ms(s,a,i,"prod",n)}},Fo={kernelName:ht,backendName:"webgpu",kernelFunc:e=>{const{backend:t,attrs:n}=e,{start:r,stop:s,step:a,dtype:i}=n,o=ws(r,s,a,i);return t.makeTensorInfo([o.length],i,o)}},Bo=gr({opType:Tn.DIV}),_o={kernelName:dt,backendName:"webgpu",kernelFunc:Bo},Oo={kernelName:pt,backendName:"webgpu",kernelFunc:mr({opType:Ln.RECIPROCAL})},Lo={kernelName:ct,backendName:"webgpu",kernelFunc:mr({opType:Ln.RELU})},Uo={kernelName:ft,backendName:"webgpu",kernelFunc:mr({opType:Ln.RELU6})};class Do{constructor(e,t,n){this.variableNames=["x"],this.uniforms="adjustHeightWidth : vec2<f32>, halfPixelCenters : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e[0],t,n,e[3]],this.dispatchLayout=In(this.outputShape),this.dispatch=bn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="resizeBilinear"}getUserCode(){return`\n      ${on("index")} {\n        if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n          let b = coords[0];\n          let d = coords[3];\n          let rc = coords.yz;\n\n          let effectiveInSize = vec2<f32>(\n            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],\n            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);\n\n          let effectiveOutSize = vec2<f32>(\n            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],\n            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);\n\n          let effectiveInputOverOutputRatioRC =\n              effectiveInSize / effectiveOutSize;\n\n          // Fractional source index\n          let sourceFracIndexRC =\n            (vec2<f32>(rc) + vec2<f32>(uniforms.halfPixelCenters)) *\n            effectiveInputOverOutputRatioRC - vec2<f32>(uniforms.halfPixelCenters);\n\n          // Compute the four integer indices.\n          let sourceFloorRC = vec2<i32>(sourceFracIndexRC);\n          let sourceCeilRC = vec2<i32>(\n            min(vec2<f32>(uniforms.xShape.yz) - vec2<f32>(1.0), ceil(sourceFracIndexRC)));\n\n          let topLeft = getX(b, sourceFloorRC.x, sourceFloorRC.y, d);\n          let bottomLeft = getX(b, sourceCeilRC.x, sourceFloorRC.y, d);\n          let topRight = getX(b, sourceFloorRC.x, sourceCeilRC.y, d);\n          let bottomRight = getX(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n          let fracRC = sourceFracIndexRC - vec2<f32>(sourceFloorRC);\n\n          let top = topLeft + (topRight - topLeft) * fracRC.y;\n          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n          let newValue = top + (bottom - top) * fracRC.x;\n\n          setOutputAtIndex(index, newValue);\n        }\n      }\n    `}}const Wo={kernelName:mt,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:s}=t,{alignCorners:a,size:i,halfPixelCenters:o}=r,[u,l]=i,h=[{type:"float32",data:[a&&u>1?1:0,a&&l>1?1:0]},{type:"float32",data:[o?.5:0]}],d=new Do(s.shape,u,l);return n.runWebGPUProgram(d,[s],"float32",h)}};class Mo{constructor(e,t,n,r){this.variableNames=["x"],this.uniforms="adjustHeightWidth : vec2<f32>, roundBase : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e[0],t,n,e[3]],this.dispatchLayout=In(this.outputShape),this.dispatch=bn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.halfPixelCenters=r,this.shaderKey=`resizeNearest_${r}`}getUserCode(){let e;e=this.halfPixelCenters?"max((vec2<f32>(rc) + vec2<f32>(0.5)) * effectiveInputOverOutputRatioRC, vec2<f32>(0.0))":"vec2<f32>(rc) * effectiveInputOverOutputRatioRC";return`\n      ${on("index")} {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let b = coords[0];\n          let d = coords[3];\n          let rc = coords.yz;\n\n          let effectiveInSize = vec2<f32>(\n            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],\n            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);\n\n          let effectiveOutSize = vec2<f32>(\n            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],\n            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);\n\n          let effectiveInputOverOutputRatioRC =\n              effectiveInSize / effectiveOutSize;\n\n          // Fractional source index\n          let sourceFracIndexRC = ${e};\n\n          // Compute the coordinators of nearest neighbor point.\n          let inputShapeRC = vec2<f32>(f32(uniforms.xShape.y), f32(uniforms.xShape.z));\n          let sourceNearestRC = vec2<i32>(\n            min(inputShapeRC - 1.0, floor(sourceFracIndexRC + uniforms.roundBase)));\n          let newValue = getX(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n          setOutputAtIndex(index, newValue);\n        }\n      }\n    `}}const Vo={kernelName:gt,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:s}=t,{alignCorners:a,halfPixelCenters:i,size:o}=r,[u,l]=o,h=[{type:"float32",data:[a&&u>1?1:0,a&&l>1?1:0]},{type:"float32",data:[a?.5:0]}],d=new Mo(s.shape,u,l,i);return n.runWebGPUProgram(d,[s],s.dtype,h)}};class Go{constructor(e){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=In(this.outputShape),this.dispatch=bn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms=" axis : vec4<i32>,",this.shaderKey="reverse"}getUserCode(){return`\n      \n      // Using uniform variables as judging conditions, so the function has\n      // coherent execution within all threads.\n      fn getReverseCoords(coords : vec4<i32>) -> vec4<i32> {\n        var reverseCoords = coords;\n        if (uniforms.axis[0] == 1) {\n          reverseCoords[0] = uniforms.xShape[0] - coords[0] - 1;\n        }\n        if (uniforms.axis[1] == 1) {\n          reverseCoords[1] = uniforms.xShape[1] - coords[1] - 1;\n        }\n        if (uniforms.axis[2] == 1) {\n          reverseCoords[2] = uniforms.xShape[2] - coords[2] - 1;\n        }\n        if (uniforms.axis[3] == 1) {\n          reverseCoords[3] = uniforms.xShape[3] - coords[3] - 1;\n        }\n\n        return reverseCoords;\n      }\n    \n      ${on("index")} {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let reverseCoords = getReverseCoords(coords);\n          setOutputAtIndex(index, getX(reverseCoords[0],\n              reverseCoords[1], reverseCoords[2], reverseCoords[3]));\n        }\n      }\n    `}}const Ho={kernelName:bt,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:a}=t,{dims:i}=s,o=a.shape.length;if(0===o)return hr({inputs:{x:a},backend:n});const u=a.shape,l=[1,1,1,1];u.forEach(((e,t)=>{l[t+4-o]=e}));const h=r.parseAxisParam(i,a.shape),d=[0,0,0,0];h.forEach((e=>{d[e+4-o]=1}));const p=[{type:"int32",data:d}],c=sr({inputs:{x:a},backend:n,attrs:{shape:l}}),f=new Go(l),m=n.runWebGPUProgram(f,[c],c.dtype,p);n.disposeData(c.dataId);const g=sr({inputs:{x:m},backend:n,attrs:{shape:u}});return n.disposeData(m.dataId),g}};class Xo{constructor(e,t){this.outputShape=[],this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=In(this.outputShape),this.dispatch=bn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms="centerX : f32, centerY : f32, sinRadians : f32,\n          cosRadians : f32,",this.shaderKey="rotate",this.outputShape=e,"number"==typeof t?(this.uniforms+=" fillValue : f32,",this.fillSnippet="var outputValue = uniforms.fillValue;",this.shaderKey+="_float"):(this.uniforms+=" fillValue : vec3<f32>,",this.fillSnippet="var outputValue = uniforms.fillValue[coords[3]];",this.shaderKey+="_vec3")}getUserCode(){return`\n        ${on("index")} {\n          if (index < uniforms.size) {\n            let coords = getCoordsFromIndex(index);\n            let coordXFloat = (f32(coords[2]) - uniforms.centerX) *\n                uniforms.cosRadians - (f32(coords[1]) - uniforms.centerY) *\n                uniforms.sinRadians;\n            let coordYFloat = (f32(coords[2]) - uniforms.centerX) *\n                uniforms.sinRadians + (f32(coords[1]) - uniforms.centerY) *\n                uniforms.cosRadians;\n            let coordX = i32(round(coordXFloat + uniforms.centerX));\n            let coordY = i32(round(coordYFloat + uniforms.centerY));\n            ${this.fillSnippet}\n            if(coordX >= 0 && coordX < uniforms.xShape[2] && coordY >= 0 &&\n                coordY < uniforms.xShape[1]) {\n              outputValue = getX(coords[0], coordY, coordX, coords[3]);\n            }\n            setOutputAtIndex(index, outputValue);\n          }\n        }\n      `}}const Ko={kernelName:xt,backendName:"webgpu",kernelFunc:({inputs:e,attrs:t,backend:r})=>{const{image:s}=e,{radians:a,fillValue:i,center:o}=t,u=r,l=new Xo(s.shape,i),[h,d]=n.getImageCenter(o,s.shape[1],s.shape[2]),p=[{type:"float32",data:[h]},{type:"float32",data:[d]},{type:"float32",data:[Math.sin(a)]},{type:"float32",data:[Math.cos(a)]}];"number"==typeof i?p.push({type:"float32",data:[Number.parseFloat(i.toFixed(2))]}):p.push({type:"float32",data:i});return u.runWebGPUProgram(l,[s],s.dtype,p)}},qo={kernelName:wt,backendName:"webgpu",kernelFunc:mr({opType:Ln.ROUND})},jo={kernelName:yt,backendName:"webgpu",kernelFunc:mr({opType:Ln.RSQRT,cpuKernelImpl:ys})};class Yo{constructor(e,t,n,r,s,a,i,o=!0){this.variableNames=["updates","indices"],this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=a,this.type=i,this.sumDupeIndices=o,this.dispatchLayout=In(e),this.dispatch=bn(this.dispatchLayout,e,this.workgroupSize),this.sliceDimGreaterThanOne=t>1,this.shaderKey=`scatter_${n}_${r}_${this.sliceDimGreaterThanOne}_${i}_${o}`;const u=sn(s.length);this.uniforms=`sliceDim : i32, strides: ${u}, updatesSize: i32,`,this.updatesRank=r,this.indicesRank=n}getUserCode(){let e="";1===this.indicesRank?e="coords[0]":2===this.indicesRank&&(e="coords[0], j");const t=`getIndices(${e})`,n=this.sliceDimGreaterThanOne?"uniforms.strides[j]":"uniforms.strides";let r="",s="";1===this.dispatchLayout.x.length?(r="flattenedIndex",s="\n      fn getUpdatesCoordsFromFlatIndex(index : i32) -> i32 {\n        return index;\n      }\n      "):2===this.dispatchLayout.x.length&&(r="vec2<i32>(flattenedIndex, coords[1])",s="\n      fn getUpdatesCoordsFromFlatIndex(index : i32) -> vec2<i32> {\n        // N.B. |updates| could be a scalar tensor, conceptually representing a\n        // 2D tensor with all values equal to that. By design, its size must be\n        // the same as |outShape[1]| in one dimension, and |indicesShape[0]|\n        // gives the other.\n        let sliceSize = uniforms.outShape[1];\n        let d0 = index / sliceSize;\n        let d1 = index - d0 * sliceSize;\n        return vec2<i32>(d0, d1);\n      }\n      ");const a=`getUpdates(${Array.from({length:this.updatesRank},((e,t)=>`coords[${t}]`)).join(", ")})`;return`\n    ${s}\n      ${on("index")} {\n        if (index < uniforms.updatesSize) {\n          let coords = getUpdatesCoordsFromFlatIndex(index);\n          var flattenedIndex = 0;\n          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {\n            let indexInside = i32(round(${t}));\n            flattenedIndex = flattenedIndex + indexInside * ${n};\n          }\n          let updateValue =\n              ${fn(this.type,!1)}(${a});\n          let flatIndex = getOutputIndexFromCoords(${r});\n\n          ${this.sumDupeIndices?nn("&result[flatIndex]","updateValue",this.type):"atomicStore(&result[flatIndex], bitcast<i32>(updateValue));"}\n        }\n      }`}}const Qo={kernelName:It,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:s,attrs:a}=e,{indices:i,updates:o}=t,{shape:u}=a,{sliceRank:l,numUpdates:h,sliceSize:d,strides:p,outputSize:c}=n.calculateShapes(o,i,u),f=[c/d,d];if(0===c)return s.makeTensorInfo(u,i.dtype);const m=sr({inputs:{x:i},backend:s,attrs:{shape:[h,l]}}),g=sr({inputs:{x:o},backend:s,attrs:{shape:[h,d]}}),b=g.dtype,x=nr({backend:s,attrs:{shape:f,value:0,dtype:b}}),w=[{type:"int32",data:[l]},{type:"int32",data:p},{type:"int32",data:[r.sizeFromShape(g.shape)]}],y=new Yo(g.shape,l,m.shape.length,g.shape.length,p,f,b),I=s.runWebGPUProgram(y,[g,m],b,w,x),S=sr({inputs:{x:I},backend:s,attrs:{shape:u}});return s.disposeData(m.dataId),s.disposeData(g.dataId),s.disposeData(I.dataId),S}};class Zo{constructor(e,t){this.outputShape=[],this.variableNames=["sortedSequence","values"],this.uniforms="numInputs : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=In(this.outputShape),this.dispatch=bn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.side=t,this.shaderKey=`search_sorted_${t}`}getUserCode(){return`\n      fn findBound(batch: i32, value: f32) -> i32 {\n        var left = i32(0);\n        var right = uniforms.numInputs;\n        while (left < right) {\n          var mid = (left + right) / 2;\n          if (getSortedSequence(batch, mid) ${"left"===this.side?"<":"<="} value) {\n            left = mid + 1;\n          } else {\n            right = mid;\n          }\n        }\n        return right;\n      }\n\n      ${on("index")} {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let value = getValuesByOutputIndex(index);\n          setOutputAtIndexI32(index, findBound(coords[0], value));\n        }\n      }\n    `}}const Jo={kernelName:St,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{sortedSequence:s,values:a}=t,{side:i}=r,o=new Zo([a.shape[0],a.shape[1]],i),u=[{type:"int32",data:[s.shape[1]]}];return n.runWebGPUProgram(o,[s,a],"int32",u)}};class eu{constructor(e,t,n){this.variableNames=["c","a","b"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=In(this.outputShape),this.dispatch=bn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.cRank=e,this.rank=n,this.shaderKey="select"}getUserCode(){let e,t;if(this.rank>4)throw Error(`Where for rank ${this.rank} is not yet supported`);if(1===this.rank)t="resRC",e="resRC";else{const n=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[],s=[];for(let e=0;e<this.outputShape.length;e++)s.push(`${n[e]}`),e<this.cRank&&r.push(`${n[e]}`);e=r.join(),t=s.join()}return`\n      ${on("index")} {\n        if (index < uniforms.size) {\n          let resRC = getCoordsFromIndex(index);\n          let cVal = getC(${e});\n          if (cVal >= 1.0) {\n            setOutputAtIndex(index, getA(${t}));\n          } else {\n            setOutputAtIndex(index, getB(${t}));\n          }\n        }\n      }\n    `}}const tu={kernelName:kt,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{condition:r,t:s,e:a}=t,i=new eu(r.shape.length,s.shape,s.shape.length);return n.runWebGPUProgram(i,[r,s,a],m(s.dtype,a.dtype))}},nu={kernelName:vt,backendName:"webgpu",kernelFunc:mr({opType:Ln.SELU})},ru={kernelName:Ct,backendName:"webgpu",kernelFunc:mr({opType:Ln.SIGMOID})},su={kernelName:$t,backendName:"webgpu",kernelFunc:mr({opType:Ln.SIGN})},au={kernelName:Rt,backendName:"webgpu",kernelFunc:mr({opType:Ln.SIN})},iu={kernelName:At,backendName:"webgpu",kernelFunc:mr({opType:Ln.SINH})},ou=gr({opType:Tn.SUB,cpuKernelImpl:$s,supportsComplex:!0}),uu={kernelName:Tt,backendName:"webgpu",kernelFunc:ou};const lu={kernelName:Pt,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:s,attrs:a}=e,{logits:i}=t,{dim:o}=a,u=r.parseAxisParam([o],i.shape),l=ta({inputs:{x:i},backend:s,attrs:{reductionIndices:u,keepDims:!1}}),h=n.expandShapeToKeepDim(l.shape,u),d=sr({inputs:{x:l},backend:s,attrs:{shape:h}}),p=ou({inputs:{a:i,b:d},backend:s}),c=yi({inputs:{x:p},backend:s}),f=fi({inputs:{x:c},backend:s,attrs:{axis:u,keepDims:!1}}),m=sr({inputs:{x:f},backend:s,attrs:{shape:h}}),g=Bo({inputs:{a:c,b:m},backend:s});return s.disposeData(l.dataId),s.disposeData(d.dataId),s.disposeData(p.dataId),s.disposeData(c.dataId),s.disposeData(f.dataId),s.disposeData(m.dataId),g}},hu={kernelName:Nt,backendName:"webgpu",kernelFunc:mr({opType:Ln.SOFTPLUS})},du={kernelName:zt,backendName:"webgpu",kernelFunc:e=>{const{inputs:t,backend:s,attrs:a}=e,{x:i}=t,{blockShape:o,paddings:u}=a;r.assert(i.shape.length<=4,(()=>"spaceToBatchND for rank > 4 with a WebGPU backend not implemented yet"));const l=o.reduce(((e,t)=>e*t)),h=[[0,0]];h.push(...u);for(let e=1+o.length;e<i.shape.length;++e)h.push([0,0]);const d=[],p=To({inputs:{x:i},backend:s,attrs:{paddings:h,constantValue:0}}),c=n.getReshaped(p.shape,o,l,!1),f=n.getPermuted(c.length,o.length,!1),m=n.getReshapedPermuted(p.shape,o,l,!1),g=sr({inputs:{x:p},backend:s,attrs:{shape:c}}),b=Us({inputs:{x:g},backend:s,attrs:{perm:f}}),x=sr({inputs:{x:b},backend:s,attrs:{shape:m}});return d.push(p),d.push(g),d.push(b),d.forEach((e=>s.disposeData(e.dataId))),x}};class pu{constructor(e,t){this.variableNames=["A"],this.workgroupSize=[64,1,1],this.size=!0;const n=new Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[r]*t[r];this.outputShape=n,this.dispatchLayout=In(this.outputShape),this.dispatch=bn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.rank=this.outputShape.length,this.shaderKey="tile"}getUserCode(){const e=function(e,t=""){if(e>=5)throw Error(`Tile for rank ${e} is not yet supported`);if(1===e)return`(resRC % ${t}aShape)`;const n=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let s=0;s<e;s++)r.push(`(${n[s]} % ${t}aShape[${s}])`);return r.join()}(this.rank,"uniforms.");return`\n      ${on("index")} {\n        if (index < uniforms.size) {\n          let resRC = getCoordsFromIndex(index);\n          setOutputAtIndex(index, getA(${e}));\n        }\n      }\n    `}}function cu(e){const{inputs:t,backend:n,attrs:s}=e,{x:a}=t,{reps:i}=s;if(n.shouldExecuteOnCPU([a])||"string"===a.dtype||a.shape.length>=5){const e=n.readSync(a.dataId),t="string"===a.dtype?e.map((e=>r.decodeString(e))):e,s=o(a.shape,a.dtype,t),u=Rs(s,i);return n.makeTensorInfo(u.shape,u.dtype,u.values)}const u=new pu(a.shape,i);return n.runWebGPUProgram(u,[a],a.dtype)}const fu={kernelName:Et,backendName:"webgpu",kernelFunc:cu};const mu={kernelName:Ft,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:s,attrs:a}=e,{sparseIndices:i,sparseValues:o,defaultValue:u}=t,{outputShape:l}=a,{sliceRank:h,numUpdates:d,sliceSize:p,strides:c,outputSize:f}=n.calculateShapes(o,i,l),m=!1;if("string"===o.dtype){const e=s.bufferSync(i),t=s.bufferSync(o),n=r.decodeString(s.readSync(u.dataId)[0]),a=Is(e,t,l,f,p,d,h,c,n,m);return s.makeTensorInfo(l,a.dtype,a.values)}const g=[f/p,p],b=sr({inputs:{x:i},backend:s,attrs:{shape:[d,h]}}),x=o.shape.length?sr({inputs:{x:o},backend:s,attrs:{shape:[d,p]}}):hr({inputs:{x:o},backend:s}),w=x.dtype,y=s.makeTensorInfo([],w,r.makeZerosTypedArray(1,w)),I=sr({inputs:{x:u},backend:s,attrs:{shape:Array(g.length).fill(1)}}),S=cu({inputs:{x:I},backend:s,attrs:{reps:g}}),k=[{type:"int32",data:[h]},{type:"int32",data:c},{type:"int32",data:[r.sizeFromShape([d,p])]}];switch(d){case 0:break;case 1:{const e=new Yo([d,p],h,b.shape.length,x.shape.length,c,g,w,m);s.runWebGPUProgram(e,[x,b],w,k,S)}break;default:{const e=new Yo([d,p],h,b.shape.length,y.shape.length,c,g,w,m);s.runWebGPUProgram(e,[y,b],w,k,S)}{const e=new Yo([d,p],h,b.shape.length,x.shape.length,c,g,w);s.runWebGPUProgram(e,[x,b],w,k,S)}}const v=sr({inputs:{x:S},backend:s,attrs:{shape:l}});return s.disposeData(b.dataId),s.disposeData(x.dataId),s.disposeData(I.dataId),s.disposeData(y.dataId),s.disposeData(S.dataId),v}};const gu={kernelName:Bt,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:s,attrs:a}=e,{x:i}=t,{numOrSizeSplits:o,axis:u}=a,l=r.parseAxisParam(u,i.shape)[0],h=n.prepareSplitSize(i,o,l),d=i.shape.length,p=new Array(d).fill(0),c=i.shape.slice();return h.map((e=>{const t=[...c];t[l]=e;const n=pa({inputs:{x:i},backend:s,attrs:{begin:p,size:t}});return p[l]+=e,n}))}},bu={kernelName:_t,backendName:"webgpu",kernelFunc:mr({opType:Ln.SQRT})},xu={kernelName:Ot,backendName:"webgpu",kernelFunc:({inputs:e,backend:t})=>{const{x:n}=e,r=t,s=new fr(n.shape,Ln.SQUARE);return r.runWebGPUProgram(s,[n],n.dtype)}},wu={kernelName:Lt,backendName:"webgpu",kernelFunc:gr({opType:Tn.SQUARED_DIFFERENCE})};const yu={kernelName:Ut,backendName:"webgpu",kernelFunc:function({inputs:e,attrs:t,backend:n}){const{x:r}=e,s=new fr(r.shape,Ln.STEP,"stepAlpha : f32,"),a=[{type:"float32",data:[t.alpha]}];return n.runWebGPUProgram(s,[r],r.dtype,a)}};class Iu{constructor(e){this.variableNames=["x"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=In(this.outputShape),this.dispatch=bn(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]);const t=sn(this.outputShape.length);this.uniforms=`begin : ${t},  strides : ${t}, `,this.shaderKey="stridedSlice"}getUserCode(){let e="";if(1===this.outputShape.length)e="coords * uniforms.strides + uniforms.begin";else{let t=0;e=this.outputShape.map(((e,n)=>(t++,1===this.outputShape.length?`coords * uniforms.strides[${n}] + uniforms.begin[${n}]`:`coords[${t-1}] * uniforms.strides[${n}] + uniforms.begin[${n}]`))).join(",")}return`\n       ${on("index")} {\n         if (index < uniforms.size) {\n           let coords = getCoordsFromIndex(index);\n           setOutputAtIndex(index, getX(${e}));\n         }\n       }\n     `}}const Su={kernelName:Dt,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:a}=t,{begin:i,end:u,strides:l,beginMask:h,endMask:d,ellipsisMask:p,newAxisMask:c,shrinkAxisMask:f}=s,{finalShapeSparse:m,finalShape:g,isIdentity:b,sliceDim0:x,isSimpleSlice:y,begin:I,end:S,strides:k}=w.sliceInfo(a.shape,i,u,l,h,d,p,c,f);let v;if(b)v=sr({inputs:{x:a},backend:n,attrs:{shape:g}});else if(x||y){r.assert(a.shape.length>=1,(()=>`Input must have rank at least 1, got: ${a.shape.length}`));const e=w.computeOutShape(I,S,k),t=pa({inputs:{x:a},backend:n,attrs:{begin:I,size:e}});v=sr({inputs:{x:t},backend:n,attrs:{shape:g}}),n.disposeData(t.dataId)}else{if(n.shouldExecuteOnCPU([a])){const e=n.readSync(a.dataId),t=o(a.shape,a.dtype,e),r=vs(m,t,k,I);v=n.makeTensorInfo(g,a.dtype,r.values)}else{const e=new Iu(m),t=[{type:"int32",data:I},{type:"int32",data:k}],r=n.runWebGPUProgram(e,[a],a.dtype,t);v=sr({inputs:{x:r},backend:n,attrs:{shape:g}}),n.disposeData(r.dataId)}}return v}};const ku={kernelName:Wt,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{separator:s,nGramWidths:a,leftPad:i,rightPad:o,padWidth:u,preserveShortSequences:l}=r,{data:h,dataSplits:d}=t,p=n.readSync(h.dataId),c=n.readSync(d.dataId),[f,m]=Cs(p,c,s,a,i,o,u,l);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(d.shape,"int32",m)]}},vu={kernelName:Mt,backendName:"webgpu",kernelFunc:mr({opType:Ln.TAN})},Cu={kernelName:Vt,backendName:"webgpu",kernelFunc:mr({opType:Ln.TANH})};class $u{constructor(e){this.variableNames=["x","indices"],this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=In(this.outputShape),this.dispatch=bn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms="inputSize : i32, firstPass : i32, negativeInf : f32,\n        dir : i32, inc : i32,",this.shaderKey="swap"}getUserCode(){return`\n        ${on("index")} {\n          if (index < uniforms.size) {\n            let outC = getCoordsFromIndex(index);\n            let batch = outC[0];\n            let elemIdx = outC[1];\n            // We compare elements pair-wise within a group of size 2 * inc.\n            // The comparing rule for each group alternates between ascending\n            // and descending. Within each group, we compare each pair at\n            // positions i and i+inc. To decide whether an element at position i\n            // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n            // inc, it is in the first half of the group, we denote it as x0,\n            // otherwise we denote it as x1.\n            // For example, as shown in the Bitonic top K paper referenced\n            // above, Figure5(a) shows that element[1] is in the second half of\n            // the group when group size is 2, but it is in the first half of\n            // the group when group size is 4.\n            let isFirstInPair = elemIdx % (2 * uniforms.inc) < uniforms.inc;\n            var i = 0;\n            if (isFirstInPair) {\n              i = elemIdx;\n            } else {\n              i = elemIdx - uniforms.inc;\n            }\n\n            var i0 = 0;\n            if (uniforms.firstPass == 1) {\n              i0 = i;\n            } else {\n              i0 = i32(getIndices(batch, i));\n            }\n\n            var i1 = 0;\n            if (uniforms.firstPass == 1) {\n              i1 = i + uniforms.inc;\n            } else {\n              i1 = i32(getIndices(batch, i + uniforms.inc));\n            }\n\n            var x0 = f32(0.0);\n            var x1 = f32(0.0);\n            if (i0 < uniforms.inputSize) {\n              x0 = getX(batch, i0);\n            } else {\n              x0 = uniforms.negativeInf;\n            }\n            if (i1 < uniforms.inputSize) {\n              x1 = getX(batch, i1);\n            } else {\n              x1 = uniforms.negativeInf;\n            }\n\n            let reverse = elemIdx % (2 * uniforms.dir) >= uniforms.dir;\n            let isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n            if (reverse == isGreater) {\n              // Elements in opposite order of direction\n              let iTemp = i0;\n              i0 = i1;\n              i1 = iTemp;\n            }\n            if (isFirstInPair) {\n              setOutputAtIndex(index, f32(i0));\n            } else {\n              setOutputAtIndex(index, f32(i1));\n            }\n          }\n        }\n      `}}class Ru{constructor(e){this.variableNames=["x","indices"],this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=In(this.outputShape),this.dispatch=bn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms="inputSize : i32, firstPass : i32, k : i32,",this.shaderKey="merge"}getUserCode(){return`\n        ${on("index")} {\n          if (index < uniforms.size) {\n            let outC = getCoordsFromIndex(index);\n            let batch = outC[0];\n            let elemIdx = outC[1];\n            // The output size is half of the previous size.\n            // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _\n            // (k=4), we only need to output the indices at positions |, the\n            // indices at positions _ can be thrown away, see Figure5(b) After\n            // Phase 2 (Merge phase) in the Bitonic Top K paper referenced\n            // above.\n            // For example, the paper shows we only need to output the orange\n            // bars. The output sequence should look like this | | | | | | | |.\n            // Because the sequence is halved, to map the output index back to\n            // the previous sequence to find the corresponding value, we need\n            // to double the index. When we double the index, we basically\n            // interpolate a position, so 2i looks like\n            // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k\n            // position of each 2k positions by - elemIdx % k. E.g. for output\n            // at index 4,5,6,7, we want to get the corresponding element at\n            // original index 8,9,10,11, for output at index 8,9,10,11,\n            // we want to get the corresponding element at original index\n            // 16,17,18,19, so on and so forth.\n\n            var i = 0;\n            if (elemIdx < uniforms.k) {\n              i = elemIdx;\n            } else {\n              i = elemIdx * 2 - elemIdx % uniforms.k;\n            }\n            var i0 = 0;\n            if (uniforms.firstPass == 1) {\n              i0 = i;\n            } else {\n              i0 = i32(getIndices(batch, i));\n            }\n            var i1 = 0;\n            if (uniforms.firstPass == 1) {\n              i1 = i + uniforms.k;\n            } else {\n              i1 = i32(getIndices(batch, i + uniforms.k));\n            }\n\n            let x0 = getX(batch, i0);\n            var x1 = f32(0.0);\n            if (i1 < uniforms.inputSize) {\n              x1 = getX(batch, i1);\n            } else {\n              x1 = x0;\n            }\n\n            if (x0 >= x1) {\n              setOutputAtIndex(index, f32(i0));\n            } else {\n              setOutputAtIndex(index, f32(i1));\n            }\n          }\n        }\n      `}}function Au(e,t){null!==t&&e.disposeData(t.dataId)}function Tu(e){let t=1;for(;t<e;)t*=2;return t}const Pu={kernelName:Gt,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:a}=t,{k:i,sorted:o}=s,u=a.shape,l=u[u.length-1];if(n.shouldExecuteOnCPU([a])){const e=n.readSync(a.dataId),[t,r]=As(e,u,a.dtype,i,o);return[n.makeTensorInfo(t.shape,t.dtype,t.values),n.makeTensorInfo(r.shape,r.dtype,r.values)]}if(0===i)return u[u.length-1]=0,[n.makeTensorInfo(u,a.dtype,[]),n.makeTensorInfo(u,"int32",[])];if(1===l)return[a,nr({attrs:{shape:u,dtype:"int32",value:0},backend:n})];const h=r.sizeFromShape(u)/l,d=sr({inputs:{x:a},attrs:{shape:[h,l]},backend:n}),p=Tu(i),c=Tu(l);let f=null;const m=()=>null===f?[d,d]:[d,f],g=(e,t,r)=>{const s=m(),a=new $u(r),i=[{type:"int32",data:[l]},{type:"int32",data:[null===f?1:0]},{type:"float32",data:[Number.NEGATIVE_INFINITY]},{type:"int32",data:[e]},{type:"int32",data:[t]}],o=f;f=n.runWebGPUProgram(a,s,"int32",i),Au(n,o)};for(let e=1;e<p;e*=2){const t=2*e;for(let n=e;n>=1;n/=2)g(t,n,[h,c])}for(let e=c;e>p;e/=2){const t=m(),r=new Ru([h,e/2]),s=[{type:"int32",data:[l]},{type:"int32",data:[null===f?1:0]},{type:"int32",data:[p]}],a=f;f=n.runWebGPUProgram(r,t,"int32",s),Au(n,a);const i=p/2,o=2*i;for(let e=i;e>=1;e/=2)g(o,e,f.shape)}let b=f;f=pa({inputs:{x:f},backend:n,attrs:{begin:0,size:[h,i]}}),Au(n,b);let x=Vi({inputs:{x:d,indices:f},backend:n,attrs:{axis:1,batchDims:1}});Au(n,d);const w=u.slice(0,-1);w.push(i),b=f,f=sr({inputs:{x:f},attrs:{shape:w},backend:n}),Au(n,b);const y=x;return x=sr({inputs:{x:x},attrs:{shape:w},backend:n}),Au(n,y),[x,f]}};class Nu{constructor(e){this.variableNames=["Image","Transforms"],this.uniforms="interpolationModeId : i32, fillModeId : i32, fillValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=In(this.outputShape),this.dispatch=bn(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="transform"}getUserCode(){return`\n          fn mapCoord(outCoord : f32, len : f32) -> f32{\n            var inCoord = outCoord;\n            if(uniforms.fillModeId == 2) {\n              if (inCoord < 0.0) {\n                if (len <= 1.0) {\n                  inCoord = 0.0;\n                } else {\n                  let sz2 = 2.0 * len;\n                  if (inCoord < sz2) {\n                    inCoord = sz2 * f32(i32(f32(-inCoord / sz2))) +\n                    inCoord;\n                  }\n                  if (inCoord < -len) {\n                    inCoord = inCoord + sz2;\n                  } else {\n                    inCoord = -inCoord - 1.0;\n                  }\n                }\n              } else if (inCoord > len - 1.0) {\n                if (len <= 1.0) {\n                  inCoord = 0.0;\n                } else {\n                  let sz2 = 2.0 * len;\n                  inCoord = inCoord - sz2 * f32(i32(f32(inCoord / sz2)));\n                  if (inCoord >= len) {\n                    inCoord = sz2 - inCoord - 1.0;\n                  }\n                }\n              }\n              return clamp(inCoord, 0.0, len - 1.0);\n            } else if (uniforms.fillModeId == 3) {\n              if (inCoord < 0.0) {\n                if (len <= 1.0) {\n                  inCoord = 0.0;\n                } else {\n                  let sz = len - 1.0;\n                  inCoord = inCoord + len * (f32(i32(f32(-inCoord / sz))) + 1.0);\n                }\n              } else if (inCoord > len - 1.0) {\n                if (len <= 1.0) {\n                  inCoord = 0.0;\n                } else {\n                  let sz = len - 1.0;\n                  inCoord = inCoord - len * f32(i32(f32(inCoord / sz)));\n                }\n              }\n              return clamp(inCoord, 0.0, len - 1.0);\n            } else if (uniforms.fillModeId == 4) {\n              return clamp(outCoord, 0.0, len - 1.0);\n            }\n            return outCoord;\n          }\n          fn readWithFillValue(batch : i32, coordY : i32, coordX : i32,\n            channel : i32) -> f32 {\n            var outputValue : f32;\n            if (0 <= coordY && coordY < uniforms.imageShape[1] && 0 <= coordX && coordX < uniforms.imageShape[2]) {\n                outputValue = getImage(batch, coordY, coordX, channel);\n            } else {\n              outputValue = uniforms.fillValue;\n            }\n            return outputValue;\n          }\n\n          ${on("index")} {\n            if (index < uniforms.size) {\n              let coords = getCoordsFromIndex(index);\n              var outputValue : f32;\n              let batch = coords[0];\n              let x = coords[2];\n              let y = coords[1];\n              let channel = coords[3];\n              let xf = f32(x);\n              let yf = f32(y);\n              let a1 = getTransforms(batch, 0);\n              let a2 = getTransforms(batch, 1);\n              let a3 = getTransforms(batch, 2);\n              let b1 = getTransforms(batch, 3);\n              let b2 = getTransforms(batch, 4);\n              let b3 = getTransforms(batch, 5);\n              let c1 = getTransforms(batch, 6);\n              let c2 = getTransforms(batch, 7);\n              let projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = uniforms.fillValue;\n              } else {\n                let inX = (a1 * xf + a2 * yf + a3) / projection;\n                let inY = (b1 * xf + b2 * yf + b3) / projection;\n                let mapX = mapCoord(inX, f32(uniforms.imageShape[2]));\n                let mapY = mapCoord(inY, f32(uniforms.imageShape[1]));\n\n                if (uniforms.interpolationModeId == 1) {\n                  let coordY = i32(round(mapY));\n                  let coordX = i32(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  let yFloor = floor(mapY);\n                  let xFloor = floor(mapX);\n                  let yCeil = yFloor + 1.0;\n                  let xCeil = xFloor + 1.0;\n                  let valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, i32(yFloor), i32(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, i32(yFloor), i32(xCeil), channel);\n                  let valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, i32(yCeil), i32(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, i32(yCeil), i32(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutputAtIndex(index, outputValue);\n            }\n          }\n        `}}const zu=[or,Ns,zs,Es,Fs,_s,Vs,Gs,Xs,Ks,qs,js,Ys,Qs,Zs,ia,ua,la,fa,ba,Sa,ka,$a,cr,za,La,Wa,Va,Ga,Ha,Ka,Ja,ei,ti,ri,oi,li,di,gi,bi,xi,wi,Ii,ki,vi,Ri,rr,Ti,Ei,Pi,Ni,Oi,Li,Ui,Wi,Gi,Hi,Xi,dr,Ki,Ta,qi,ji,Yi,Qi,Zi,Ji,to,ro,no,so,ao,io,ho,na,po,co,sa,fo,mo,bo,xo,ci,wo,yo,Io,wa,ko,$o,Ro,Po,No,zo,Eo,Fo,Ia,_o,Oo,Lo,Uo,ar,Wo,Vo,Ho,Ko,qo,jo,Qo,Jo,tu,nu,ru,su,au,iu,ca,yu,Su,ku,lu,hu,du,mu,gu,bu,xu,wu,uu,mi,vu,Cu,fu,Pu,{kernelName:Ht,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{image:s,transforms:a}=t,{interpolation:i,fillMode:o,fillValue:u,outputShape:l}=r,[h,d,p,c]=s.shape,[f,m]=null!=l?l:[d,p],g=new Nu([h,f,m,c]),b="nearest"===i?1:2;let x;switch(o){case"constant":default:x=1;break;case"reflect":x=2;break;case"wrap":x=3;break;case"nearest":x=4}const w=[{type:"int32",data:[b]},{type:"int32",data:[x]},{type:"float32",data:[u]}];return n.runWebGPUProgram(g,[s,a],"float32",w)}},Ds,{kernelName:Xt,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{value:s}=t;let{axis:a}=r;a<0&&(a+=s.shape.length);const i=s,o=i.shape.length,u=s.shape[a],l=new Array(o-1);let h=0;for(let e=0;e<o;e++)e!==a&&(l[h++]=i.shape[e]);const d=[],p=new Array(o).fill(0),c=i.shape.slice();c[a]=1;const f=new Array(u);for(let e=0;e<f.length;e++){p[a]=e;const t=pa({inputs:{x:i},backend:n,attrs:{begin:p,size:c}}),r=sr({inputs:{x:t},backend:n,attrs:{shape:l}});f[e]=r,d.push(t)}return d.forEach((e=>n.disposeData(e.dataId))),f}},Co];for(const e of zu)Kt(e);export{An as WebGPUBackend,$n as webgpu_util};
//# sourceMappingURL=tf-backend-webgpu.fesm.min.js.map
