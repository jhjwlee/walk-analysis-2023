/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
import { atomicAddSnippet } from './shader_util';
import { getCoordsDataType, getMainHeaderString as main, mapToWgslTypes } from './webgpu_program';
import { computeDispatch, flatDispatchLayout } from './webgpu_util';
export class ScatterProgram {
    constructor(flattenXShape, sliceDim, indicesRank, updatesRank, strides, shape, outputDtype, sumDupeIndices = true) {
        this.variableNames = ['updates', 'indices'];
        this.workgroupSize = [64, 1, 1];
        this.atomic = true;
        this.outputShape = shape;
        this.type = outputDtype;
        this.sumDupeIndices = sumDupeIndices;
        this.dispatchLayout = flatDispatchLayout(flattenXShape);
        // Dispatching based on |updates| shape instead of output shape.
        this.dispatch =
            computeDispatch(this.dispatchLayout, flattenXShape, this.workgroupSize);
        this.sliceDimGreaterThanOne = sliceDim > 1;
        this.shaderKey = `scatter_${indicesRank}_${updatesRank}_${this.sliceDimGreaterThanOne}_${outputDtype}_${sumDupeIndices}`;
        const stridesType = getCoordsDataType(strides.length);
        this.uniforms =
            `sliceDim : i32, strides: ${stridesType}, updatesSize: i32,`;
        this.updatesRank = updatesRank;
        this.indicesRank = indicesRank;
    }
    getUserCode() {
        let indicesString = '';
        if (this.indicesRank === 1) {
            indicesString = 'coords[0]';
        }
        else if (this.indicesRank === 2) {
            indicesString = 'coords[0], j';
        }
        const indicesSnippet = `getIndices(${indicesString})`;
        const strideString = this.sliceDimGreaterThanOne ? 'uniforms.strides[j]' :
            'uniforms.strides';
        let outCoordsString = '';
        let getUpdatesCoordsFromFlatIndex = '';
        if (this.dispatchLayout.x.length === 1) {
            outCoordsString = 'flattenedIndex';
            getUpdatesCoordsFromFlatIndex = `
      fn getUpdatesCoordsFromFlatIndex(index : i32) -> i32 {
        return index;
      }
      `;
        }
        else if (this.dispatchLayout.x.length === 2) {
            outCoordsString = 'vec2<i32>(flattenedIndex, coords[1])';
            getUpdatesCoordsFromFlatIndex = `
      fn getUpdatesCoordsFromFlatIndex(index : i32) -> vec2<i32> {
        // N.B. |updates| could be a scalar tensor, conceptually representing a
        // 2D tensor with all values equal to that. By design, its size must be
        // the same as |outShape[1]| in one dimension, and |indicesShape[0]|
        // gives the other.
        let sliceSize = uniforms.outShape[1];
        let d0 = index / sliceSize;
        let d1 = index - d0 * sliceSize;
        return vec2<i32>(d0, d1);
      }
      `;
        }
        const updatesString = Array.from({ length: this.updatesRank }, (_, idx) => `coords[${idx}]`);
        const updatesSnippet = `getUpdates(${updatesString.join(', ')})`;
        const userCode = `
    ${getUpdatesCoordsFromFlatIndex}
      ${main('index')} {
        if (index < uniforms.updatesSize) {
          let coords = getUpdatesCoordsFromFlatIndex(index);
          var flattenedIndex = 0;
          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {
            let indexInside = i32(round(${indicesSnippet}));
            flattenedIndex = flattenedIndex + indexInside * ${strideString};
          }
          let updateValue =
              ${mapToWgslTypes(this.type, false)}(${updatesSnippet});
          let flatIndex = getOutputIndexFromCoords(${outCoordsString});

          ${this.sumDupeIndices ?
            atomicAddSnippet('&result[flatIndex]', 'updateValue', this.type) :
            `atomicStore(&result[flatIndex], bitcast<i32>(updateValue));`}
        }
      }`;
        return userCode;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2NhdHRlcl93ZWJncHUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi90ZmpzLWJhY2tlbmQtd2ViZ3B1L3NyYy9zY2F0dGVyX3dlYmdwdS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7O0dBZUc7QUFHSCxPQUFPLEVBQUMsZ0JBQWdCLEVBQUMsTUFBTSxlQUFlLENBQUM7QUFDL0MsT0FBTyxFQUFDLGlCQUFpQixFQUFFLG1CQUFtQixJQUFJLElBQUksRUFBRSxjQUFjLEVBQWdCLE1BQU0sa0JBQWtCLENBQUM7QUFDL0csT0FBTyxFQUFDLGVBQWUsRUFBRSxrQkFBa0IsRUFBQyxNQUFNLGVBQWUsQ0FBQztBQUVsRSxNQUFNLE9BQU8sY0FBYztJQWV6QixZQUNJLGFBQXVCLEVBQUUsUUFBZ0IsRUFBRSxXQUFtQixFQUM5RCxXQUFtQixFQUFFLE9BQWlCLEVBQUUsS0FBZSxFQUN2RCxXQUFxQixFQUFFLGNBQWMsR0FBRyxJQUFJO1FBakJoRCxrQkFBYSxHQUFHLENBQUMsU0FBUyxFQUFFLFNBQVMsQ0FBQyxDQUFDO1FBT3ZDLGtCQUFhLEdBQTZCLENBQUMsRUFBRSxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUlyRCxXQUFNLEdBQUcsSUFBSSxDQUFDO1FBT1osSUFBSSxDQUFDLFdBQVcsR0FBRyxLQUFLLENBQUM7UUFDekIsSUFBSSxDQUFDLElBQUksR0FBRyxXQUFXLENBQUM7UUFDeEIsSUFBSSxDQUFDLGNBQWMsR0FBRyxjQUFjLENBQUM7UUFDckMsSUFBSSxDQUFDLGNBQWMsR0FBRyxrQkFBa0IsQ0FBQyxhQUFhLENBQUMsQ0FBQztRQUN4RCxnRUFBZ0U7UUFDaEUsSUFBSSxDQUFDLFFBQVE7WUFDVCxlQUFlLENBQUMsSUFBSSxDQUFDLGNBQWMsRUFBRSxhQUFhLEVBQUUsSUFBSSxDQUFDLGFBQWEsQ0FBQyxDQUFDO1FBQzVFLElBQUksQ0FBQyxzQkFBc0IsR0FBRyxRQUFRLEdBQUcsQ0FBQyxDQUFDO1FBQzNDLElBQUksQ0FBQyxTQUFTLEdBQUcsV0FBVyxXQUFXLElBQUksV0FBVyxJQUNsRCxJQUFJLENBQUMsc0JBQXNCLElBQUksV0FBVyxJQUFJLGNBQWMsRUFBRSxDQUFDO1FBQ25FLE1BQU0sV0FBVyxHQUFHLGlCQUFpQixDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUN0RCxJQUFJLENBQUMsUUFBUTtZQUNULDRCQUE0QixXQUFXLHFCQUFxQixDQUFDO1FBQ2pFLElBQUksQ0FBQyxXQUFXLEdBQUcsV0FBVyxDQUFDO1FBQy9CLElBQUksQ0FBQyxXQUFXLEdBQUcsV0FBVyxDQUFDO0lBQ2pDLENBQUM7SUFFRCxXQUFXO1FBQ1QsSUFBSSxhQUFhLEdBQUcsRUFBRSxDQUFDO1FBQ3ZCLElBQUksSUFBSSxDQUFDLFdBQVcsS0FBSyxDQUFDLEVBQUU7WUFDMUIsYUFBYSxHQUFHLFdBQVcsQ0FBQztTQUM3QjthQUFNLElBQUksSUFBSSxDQUFDLFdBQVcsS0FBSyxDQUFDLEVBQUU7WUFDakMsYUFBYSxHQUFHLGNBQWMsQ0FBQztTQUNoQztRQUNELE1BQU0sY0FBYyxHQUFHLGNBQWMsYUFBYSxHQUFHLENBQUM7UUFFdEQsTUFBTSxZQUFZLEdBQUcsSUFBSSxDQUFDLHNCQUFzQixDQUFDLENBQUMsQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDO1lBQ3ZCLGtCQUFrQixDQUFDO1FBRXRFLElBQUksZUFBZSxHQUFHLEVBQUUsQ0FBQztRQUN6QixJQUFJLDZCQUE2QixHQUFHLEVBQUUsQ0FBQztRQUN2QyxJQUFJLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7WUFDdEMsZUFBZSxHQUFHLGdCQUFnQixDQUFDO1lBQ25DLDZCQUE2QixHQUFHOzs7O09BSS9CLENBQUM7U0FDSDthQUFNLElBQUksSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtZQUM3QyxlQUFlLEdBQUcsc0NBQXNDLENBQUM7WUFDekQsNkJBQTZCLEdBQUc7Ozs7Ozs7Ozs7O09BVy9CLENBQUM7U0FDSDtRQUNELE1BQU0sYUFBYSxHQUNmLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLFdBQVcsRUFBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLEdBQUcsRUFBRSxFQUFFLENBQUMsVUFBVSxHQUFHLEdBQUcsQ0FBQyxDQUFDO1FBQ3pFLE1BQU0sY0FBYyxHQUFHLGNBQWMsYUFBYSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDO1FBRWpFLE1BQU0sUUFBUSxHQUFHO01BQ2YsNkJBQTZCO1FBQzNCLElBQUksQ0FBQyxPQUFPLENBQUM7Ozs7OzBDQUtxQixjQUFjOzhEQUNNLFlBQVk7OztnQkFHMUQsY0FBYyxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsS0FBSyxDQUFDLElBQUksY0FBYztxREFDYixlQUFlOztZQUc1RCxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUM7WUFDakIsZ0JBQWdCLENBQ1osb0JBQW9CLEVBQUUsYUFBYSxFQUNuQyxJQUFJLENBQUMsSUFBMkIsQ0FBQyxDQUFDLENBQUM7WUFDdkMsNkRBQTZEOztRQUVqRSxDQUFDO1FBQ0wsT0FBTyxRQUFRLENBQUM7SUFDbEIsQ0FBQztDQUNGIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuXG5pbXBvcnQge0RhdGFUeXBlfSBmcm9tICdAdGVuc29yZmxvdy90ZmpzLWNvcmUnO1xuaW1wb3J0IHthdG9taWNBZGRTbmlwcGV0fSBmcm9tICcuL3NoYWRlcl91dGlsJztcbmltcG9ydCB7Z2V0Q29vcmRzRGF0YVR5cGUsIGdldE1haW5IZWFkZXJTdHJpbmcgYXMgbWFpbiwgbWFwVG9XZ3NsVHlwZXMsIFdlYkdQVVByb2dyYW19IGZyb20gJy4vd2ViZ3B1X3Byb2dyYW0nO1xuaW1wb3J0IHtjb21wdXRlRGlzcGF0Y2gsIGZsYXREaXNwYXRjaExheW91dH0gZnJvbSAnLi93ZWJncHVfdXRpbCc7XG5cbmV4cG9ydCBjbGFzcyBTY2F0dGVyUHJvZ3JhbSBpbXBsZW1lbnRzIFdlYkdQVVByb2dyYW0ge1xuICB2YXJpYWJsZU5hbWVzID0gWyd1cGRhdGVzJywgJ2luZGljZXMnXTtcbiAgdW5pZm9ybXM6IHN0cmluZztcbiAgb3V0cHV0U2hhcGU6IG51bWJlcltdO1xuICBzdW1EdXBlSW5kaWNlczogYm9vbGVhbjtcbiAgc2hhZGVyS2V5OiBzdHJpbmc7XG4gIGRpc3BhdGNoTGF5b3V0OiB7eDogbnVtYmVyW119O1xuICBkaXNwYXRjaDogW251bWJlciwgbnVtYmVyLCBudW1iZXJdO1xuICB3b3JrZ3JvdXBTaXplOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0gPSBbNjQsIDEsIDFdO1xuICB1cGRhdGVzUmFuazogbnVtYmVyO1xuICBpbmRpY2VzUmFuazogbnVtYmVyO1xuICBzbGljZURpbUdyZWF0ZXJUaGFuT25lOiBib29sZWFuO1xuICBhdG9taWMgPSB0cnVlO1xuICB0eXBlOiBEYXRhVHlwZTtcblxuICBjb25zdHJ1Y3RvcihcbiAgICAgIGZsYXR0ZW5YU2hhcGU6IG51bWJlcltdLCBzbGljZURpbTogbnVtYmVyLCBpbmRpY2VzUmFuazogbnVtYmVyLFxuICAgICAgdXBkYXRlc1Jhbms6IG51bWJlciwgc3RyaWRlczogbnVtYmVyW10sIHNoYXBlOiBudW1iZXJbXSxcbiAgICAgIG91dHB1dER0eXBlOiBEYXRhVHlwZSwgc3VtRHVwZUluZGljZXMgPSB0cnVlKSB7XG4gICAgdGhpcy5vdXRwdXRTaGFwZSA9IHNoYXBlO1xuICAgIHRoaXMudHlwZSA9IG91dHB1dER0eXBlO1xuICAgIHRoaXMuc3VtRHVwZUluZGljZXMgPSBzdW1EdXBlSW5kaWNlcztcbiAgICB0aGlzLmRpc3BhdGNoTGF5b3V0ID0gZmxhdERpc3BhdGNoTGF5b3V0KGZsYXR0ZW5YU2hhcGUpO1xuICAgIC8vIERpc3BhdGNoaW5nIGJhc2VkIG9uIHx1cGRhdGVzfCBzaGFwZSBpbnN0ZWFkIG9mIG91dHB1dCBzaGFwZS5cbiAgICB0aGlzLmRpc3BhdGNoID1cbiAgICAgICAgY29tcHV0ZURpc3BhdGNoKHRoaXMuZGlzcGF0Y2hMYXlvdXQsIGZsYXR0ZW5YU2hhcGUsIHRoaXMud29ya2dyb3VwU2l6ZSk7XG4gICAgdGhpcy5zbGljZURpbUdyZWF0ZXJUaGFuT25lID0gc2xpY2VEaW0gPiAxO1xuICAgIHRoaXMuc2hhZGVyS2V5ID0gYHNjYXR0ZXJfJHtpbmRpY2VzUmFua31fJHt1cGRhdGVzUmFua31fJHtcbiAgICAgICAgdGhpcy5zbGljZURpbUdyZWF0ZXJUaGFuT25lfV8ke291dHB1dER0eXBlfV8ke3N1bUR1cGVJbmRpY2VzfWA7XG4gICAgY29uc3Qgc3RyaWRlc1R5cGUgPSBnZXRDb29yZHNEYXRhVHlwZShzdHJpZGVzLmxlbmd0aCk7XG4gICAgdGhpcy51bmlmb3JtcyA9XG4gICAgICAgIGBzbGljZURpbSA6IGkzMiwgc3RyaWRlczogJHtzdHJpZGVzVHlwZX0sIHVwZGF0ZXNTaXplOiBpMzIsYDtcbiAgICB0aGlzLnVwZGF0ZXNSYW5rID0gdXBkYXRlc1Jhbms7XG4gICAgdGhpcy5pbmRpY2VzUmFuayA9IGluZGljZXNSYW5rO1xuICB9XG5cbiAgZ2V0VXNlckNvZGUoKTogc3RyaW5nIHtcbiAgICBsZXQgaW5kaWNlc1N0cmluZyA9ICcnO1xuICAgIGlmICh0aGlzLmluZGljZXNSYW5rID09PSAxKSB7XG4gICAgICBpbmRpY2VzU3RyaW5nID0gJ2Nvb3Jkc1swXSc7XG4gICAgfSBlbHNlIGlmICh0aGlzLmluZGljZXNSYW5rID09PSAyKSB7XG4gICAgICBpbmRpY2VzU3RyaW5nID0gJ2Nvb3Jkc1swXSwgaic7XG4gICAgfVxuICAgIGNvbnN0IGluZGljZXNTbmlwcGV0ID0gYGdldEluZGljZXMoJHtpbmRpY2VzU3RyaW5nfSlgO1xuXG4gICAgY29uc3Qgc3RyaWRlU3RyaW5nID0gdGhpcy5zbGljZURpbUdyZWF0ZXJUaGFuT25lID8gJ3VuaWZvcm1zLnN0cmlkZXNbal0nIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAndW5pZm9ybXMuc3RyaWRlcyc7XG5cbiAgICBsZXQgb3V0Q29vcmRzU3RyaW5nID0gJyc7XG4gICAgbGV0IGdldFVwZGF0ZXNDb29yZHNGcm9tRmxhdEluZGV4ID0gJyc7XG4gICAgaWYgKHRoaXMuZGlzcGF0Y2hMYXlvdXQueC5sZW5ndGggPT09IDEpIHtcbiAgICAgIG91dENvb3Jkc1N0cmluZyA9ICdmbGF0dGVuZWRJbmRleCc7XG4gICAgICBnZXRVcGRhdGVzQ29vcmRzRnJvbUZsYXRJbmRleCA9IGBcbiAgICAgIGZuIGdldFVwZGF0ZXNDb29yZHNGcm9tRmxhdEluZGV4KGluZGV4IDogaTMyKSAtPiBpMzIge1xuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICB9XG4gICAgICBgO1xuICAgIH0gZWxzZSBpZiAodGhpcy5kaXNwYXRjaExheW91dC54Lmxlbmd0aCA9PT0gMikge1xuICAgICAgb3V0Q29vcmRzU3RyaW5nID0gJ3ZlYzI8aTMyPihmbGF0dGVuZWRJbmRleCwgY29vcmRzWzFdKSc7XG4gICAgICBnZXRVcGRhdGVzQ29vcmRzRnJvbUZsYXRJbmRleCA9IGBcbiAgICAgIGZuIGdldFVwZGF0ZXNDb29yZHNGcm9tRmxhdEluZGV4KGluZGV4IDogaTMyKSAtPiB2ZWMyPGkzMj4ge1xuICAgICAgICAvLyBOLkIuIHx1cGRhdGVzfCBjb3VsZCBiZSBhIHNjYWxhciB0ZW5zb3IsIGNvbmNlcHR1YWxseSByZXByZXNlbnRpbmcgYVxuICAgICAgICAvLyAyRCB0ZW5zb3Igd2l0aCBhbGwgdmFsdWVzIGVxdWFsIHRvIHRoYXQuIEJ5IGRlc2lnbiwgaXRzIHNpemUgbXVzdCBiZVxuICAgICAgICAvLyB0aGUgc2FtZSBhcyB8b3V0U2hhcGVbMV18IGluIG9uZSBkaW1lbnNpb24sIGFuZCB8aW5kaWNlc1NoYXBlWzBdfFxuICAgICAgICAvLyBnaXZlcyB0aGUgb3RoZXIuXG4gICAgICAgIGxldCBzbGljZVNpemUgPSB1bmlmb3Jtcy5vdXRTaGFwZVsxXTtcbiAgICAgICAgbGV0IGQwID0gaW5kZXggLyBzbGljZVNpemU7XG4gICAgICAgIGxldCBkMSA9IGluZGV4IC0gZDAgKiBzbGljZVNpemU7XG4gICAgICAgIHJldHVybiB2ZWMyPGkzMj4oZDAsIGQxKTtcbiAgICAgIH1cbiAgICAgIGA7XG4gICAgfVxuICAgIGNvbnN0IHVwZGF0ZXNTdHJpbmcgPVxuICAgICAgICBBcnJheS5mcm9tKHtsZW5ndGg6IHRoaXMudXBkYXRlc1Jhbmt9LCAoXywgaWR4KSA9PiBgY29vcmRzWyR7aWR4fV1gKTtcbiAgICBjb25zdCB1cGRhdGVzU25pcHBldCA9IGBnZXRVcGRhdGVzKCR7dXBkYXRlc1N0cmluZy5qb2luKCcsICcpfSlgO1xuXG4gICAgY29uc3QgdXNlckNvZGUgPSBgXG4gICAgJHtnZXRVcGRhdGVzQ29vcmRzRnJvbUZsYXRJbmRleH1cbiAgICAgICR7bWFpbignaW5kZXgnKX0ge1xuICAgICAgICBpZiAoaW5kZXggPCB1bmlmb3Jtcy51cGRhdGVzU2l6ZSkge1xuICAgICAgICAgIGxldCBjb29yZHMgPSBnZXRVcGRhdGVzQ29vcmRzRnJvbUZsYXRJbmRleChpbmRleCk7XG4gICAgICAgICAgdmFyIGZsYXR0ZW5lZEluZGV4ID0gMDtcbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHVuaWZvcm1zLnNsaWNlRGltOyBqID0gaiArIDEpIHtcbiAgICAgICAgICAgIGxldCBpbmRleEluc2lkZSA9IGkzMihyb3VuZCgke2luZGljZXNTbmlwcGV0fSkpO1xuICAgICAgICAgICAgZmxhdHRlbmVkSW5kZXggPSBmbGF0dGVuZWRJbmRleCArIGluZGV4SW5zaWRlICogJHtzdHJpZGVTdHJpbmd9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgdXBkYXRlVmFsdWUgPVxuICAgICAgICAgICAgICAke21hcFRvV2dzbFR5cGVzKHRoaXMudHlwZSwgZmFsc2UpfSgke3VwZGF0ZXNTbmlwcGV0fSk7XG4gICAgICAgICAgbGV0IGZsYXRJbmRleCA9IGdldE91dHB1dEluZGV4RnJvbUNvb3Jkcygke291dENvb3Jkc1N0cmluZ30pO1xuXG4gICAgICAgICAgJHtcbiAgICAgICAgdGhpcy5zdW1EdXBlSW5kaWNlcyA/XG4gICAgICAgICAgICBhdG9taWNBZGRTbmlwcGV0KFxuICAgICAgICAgICAgICAgICcmcmVzdWx0W2ZsYXRJbmRleF0nLCAndXBkYXRlVmFsdWUnLFxuICAgICAgICAgICAgICAgIHRoaXMudHlwZSBhcyAnZmxvYXQzMicgfCAnaW50MzInKSA6XG4gICAgICAgICAgICBgYXRvbWljU3RvcmUoJnJlc3VsdFtmbGF0SW5kZXhdLCBiaXRjYXN0PGkzMj4odXBkYXRlVmFsdWUpKTtgfVxuICAgICAgICB9XG4gICAgICB9YDtcbiAgICByZXR1cm4gdXNlckNvZGU7XG4gIH1cbn1cbiJdfQ==