/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("@tensorflow/tfjs-core")):"function"==typeof define&&define.amd?define(["exports","@tensorflow/tfjs-core"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).tf=e.tf||{},e.tf)}(this,(function(e,t){"use strict";function n(e){if(e&&e.__esModule)return e;var t=Object.create(null);return e&&Object.keys(e).forEach((function(n){if("default"!==n){var a=Object.getOwnPropertyDescriptor(e,n);Object.defineProperty(t,n,a.get?a:{enumerable:!0,get:function(){return e[n]}})}})),t.default=e,t}var a=n(t),r=function(e,t){return r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n])},r(e,t)};function i(e,t,n,a){return new(n||(n=Promise))((function(r,i){function o(e){try{u(a.next(e))}catch(e){i(e)}}function s(e){try{u(a.throw(e))}catch(e){i(e)}}function u(e){var t;e.done?r(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(o,s)}u((a=a.apply(e,t||[])).next())}))}function o(e,t){var n,a,r,i,o={label:0,sent:function(){if(1&r[0])throw r[1];return r[1]},trys:[],ops:[]};return i={next:s(0),throw:s(1),return:s(2)},"function"==typeof Symbol&&(i[Symbol.iterator]=function(){return this}),i;function s(i){return function(s){return function(i){if(n)throw new TypeError("Generator is already executing.");for(;o;)try{if(n=1,a&&(r=2&i[0]?a.return:i[0]?a.throw||((r=a.return)&&r.call(a),0):a.next)&&!(r=r.call(a,i[1])).done)return r;switch(a=0,r&&(i=[2&i[0],r.value]),i[0]){case 0:case 1:r=i;break;case 4:return o.label++,{value:i[1],done:!1};case 5:o.label++,a=i[1],i=[0];continue;case 7:i=o.ops.pop(),o.trys.pop();continue;default:if(!(r=o.trys,(r=r.length>0&&r[r.length-1])||6!==i[0]&&2!==i[0])){o=0;continue}if(3===i[0]&&(!r||i[1]>r[0]&&i[1]<r[3])){o.label=i[1];break}if(6===i[0]&&o.label<r[1]){o.label=r[1],r=i;break}if(r&&o.label<r[2]){o.label=r[2],o.ops.push(i);break}r[2]&&o.ops.pop(),o.trys.pop();continue}i=t.call(e,o)}catch(e){i=[6,e],a=0}finally{n=r=0}if(5&i[0])throw i[1];return{value:i[0]?i[1]:void 0,done:!0}}([i,s])}}}function s(e){var t="function"==typeof Symbol&&Symbol.iterator,n=t&&e[t],a=0;if(n)return n.call(e);if(e&&"number"==typeof e.length)return{next:function(){return e&&a>=e.length&&(e=void 0),{value:e&&e[a++],done:!e}}};throw new TypeError(t?"Object is not iterable.":"Symbol.iterator is not defined.")}function u(e,t){var n="function"==typeof Symbol&&e[Symbol.iterator];if(!n)return e;var a,r,i=n.call(e),o=[];try{for(;(void 0===t||t-- >0)&&!(a=i.next()).done;)o.push(a.value)}catch(e){r={error:e}}finally{try{a&&!a.done&&(n=i.return)&&n.call(i)}finally{if(r)throw r.error}}return o}function c(e,t,n){if(n||2===arguments.length)for(var a,r=0,i=t.length;r<i;r++)!a&&r in t||(a||(a=Array.prototype.slice.call(t,0,r)),a[r]=t[r]);return e.concat(a||Array.prototype.slice.call(t))}var d=t.env();d.registerFlag("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE",(function(){return 15})),d.registerFlag("WEBGPU_CPU_FORWARD",(function(){return!0})),d.registerFlag("WEBGPU_MATMUL_PROGRAM_TYPE",(function(){return-1})),d.registerFlag("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE",(function(){return!1})),d.registerFlag("WEBGPU_USE_LOW_POWER_GPU",(function(){return!1})),d.registerFlag("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD",(function(){return 1e3})),d.registerFlag("WEBGPU_USE_PROFILE_TOOL",(function(){return!1})),d.registerFlag("WEBGPU_IMPORT_EXTERNAL_TEXTURE",(function(){return!0})),d.registerFlag("WEBGPU_USE_NAIVE_CONV2D_DEBUG",(function(){return!1})),d.registerFlag("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL",(function(){return 0})),d.registerFlag("WEBGPU_CONV_SEPARATE_IM2COL_SHADER",(function(){return!1}));var l=function(){function e(e){e&&(this.vendor=e.vendor,this.architecture=e.architecture,this.intelGPUGeneration=this.getIntelGPUGeneration())}return e.prototype.getIntelGPUGeneration=function(){if(this.isIntel()){if(this.architecture.startsWith("gen"))return Number(this.architecture.match(/\d+/));if(this.architecture.startsWith("xe"))return 12}return 0},e.prototype.isIntel=function(){return"intel"===this.vendor},e}(),h=function(){function e(e){this.device=e,this.numUsedBuffers=0,this.numFreeBuffers=0,this.freeBuffers=new Map,this.usedBuffers=new Map,this.numBytesUsed=0,this.numBytesAllocated=0}return e.prototype.acquireUploadBuffer=function(e,t){return this.acquireBuffer(e,t,!0)},e.prototype.acquireBuffer=function(e,t,n){void 0===n&&(n=!1);var a=p(e,t);if(this.freeBuffers.has(a)||this.freeBuffers.set(a,[]),this.usedBuffers.has(a)||this.usedBuffers.set(a,[]),this.numBytesUsed+=e,this.numUsedBuffers++,this.freeBuffers.get(a).length>0){this.numFreeBuffers--;var r=this.freeBuffers.get(a).shift();return this.usedBuffers.get(a).push(r),r}this.numBytesAllocated+=e;var i=this.device.createBuffer({size:e,usage:t,mappedAtCreation:n});return this.usedBuffers.get(a).push(i),i},e.prototype.releaseBuffer=function(e,t,n){if(0!==this.freeBuffers.size){var a=p(t,n);this.freeBuffers.has(a)||this.freeBuffers.set(a,[]),this.freeBuffers.get(a).push(e),this.numFreeBuffers++,this.numUsedBuffers--;var r=this.usedBuffers.get(a),i=r.indexOf(e);if(i<0)throw new Error("Cannot release a buffer that was never provided by this buffer manager");r.splice(i,1),this.numBytesUsed-=t}},e.prototype.releaseUploadBuffer=function(e,t,n){var a=this;e.mapAsync(GPUMapMode.WRITE).then((function(){a.releaseBuffer(e,t,n)}),(function(e){}))},e.prototype.getNumUsedBuffers=function(){return this.numUsedBuffers},e.prototype.getNumFreeBuffers=function(){return this.numFreeBuffers},e.prototype.dispose=function(){this.freeBuffers.forEach((function(e,t){e.forEach((function(e){e.destroy()}))})),this.usedBuffers.forEach((function(e,t){e.forEach((function(e){e.destroy()}))})),this.freeBuffers=new Map,this.usedBuffers=new Map,this.numUsedBuffers=0,this.numFreeBuffers=0,this.numBytesUsed=0,this.numBytesAllocated=0},e}();function p(e,t){return"".concat(e,"_").concat(t)}var f=function(){function e(e){this.device=e,this.numUsedTextures=0,this.numFreeTextures=0,this.freeTextures=new Map,this.usedTextures=new Map,this.numBytesUsed=0,this.numBytesAllocated=0}return e.prototype.acquireTexture=function(e,t,n,a){var r=e*t*g(n),i=m(e,t,n,a);if(this.freeTextures.has(i)||this.freeTextures.set(i,[]),this.usedTextures.has(i)||this.usedTextures.set(i,[]),this.numBytesUsed+=r,this.numUsedTextures++,this.freeTextures.get(i).length>0){this.numFreeTextures--;var o=this.freeTextures.get(i).shift();return this.usedTextures.get(i).push(o),o}this.numBytesAllocated+=r;var s=this.device.createTexture({size:[e,t],format:n,usage:a});return this.usedTextures.get(i).push(s),s},e.prototype.releaseTexture=function(e,t,n,a,r){if(0!==this.freeTextures.size){var i=m(t,n,a,r);this.freeTextures.has(i)||this.freeTextures.set(i,[]),this.freeTextures.get(i).push(e),this.numFreeTextures++,this.numUsedTextures--;var o=this.usedTextures.get(i),s=o.indexOf(e);if(s<0)throw new Error("Cannot release a texture that was never provided by this texture manager");o.splice(s,1);var u=t*n*g(a);this.numBytesUsed-=u}},e.prototype.getNumUsedTextures=function(){return this.numUsedTextures},e.prototype.getNumFreeTextures=function(){return this.numFreeTextures},e.prototype.dispose=function(){this.freeTextures.forEach((function(e,t){e.forEach((function(e){e.destroy()}))})),this.usedTextures.forEach((function(e,t){e.forEach((function(e){e.destroy()}))})),this.freeTextures=new Map,this.usedTextures=new Map,this.numUsedTextures=0,this.numFreeTextures=0,this.numBytesUsed=0,this.numBytesAllocated=0},e}();function m(e,t,n,a){return"".concat(e,"_").concat(t,"_").concat(n,"_").concat(a)}function g(e){if("rgba8unorm"===e)return 16;throw new Error("".concat(e," is not supported!"))}function v(e,t){if(Math.max.apply(Math,c([],u(e),!1))>3)throw new Error("Cannot symbolically compute strides for rank > 4 tensor.");var n=e.length,a=e.map((function(e){return"".concat(t,"[").concat(e,"]")})),r=new Array(n-1);r[n-2]=a[n-1];for(var i=n-3;i>=0;--i)r[i]="(".concat(r[i+1]," * ").concat(a[i+1],")");return r}var b=function(e,t,n){return"int32"===n?"atomicAdd(".concat(e,", bitcast<i32>(").concat(t,"));"):"\n          {\n            var oldValue = 0;\n            loop {\n              let newValueF32 = bitcast<f32>(oldValue) + (".concat(t,");\n              let newValue = bitcast<i32>(newValueF32);\n              let res = atomicCompareExchangeWeak(").concat(e,", oldValue, newValue);\n              if res.exchanged {\n                break;\n              }\n              oldValue = res.old_value;\n            }\n          }")},x=function(e,n,a,r){var i=function(e,n,a){var r=[],i=a.workgroupSize[0]*a.workgroupSize[1]*a.workgroupSize[2];if(r.push("\n\n      var<private> localId: vec3<u32>;\n      var<private> localIndex: u32;\n      var<private> globalId: vec3<u32>;\n      var<private> numWorkgroups: vec3<u32>;\n      var<private> workgroupId: vec3<u32>;\n\n      // Only used when the y/z dimension of workgroup size is 1.\n      fn getGlobalIndex() -> i32 {\n        ".concat(N(a)?"  return i32(globalId.x);":"  return i32((workgroupId.z * numWorkgroups.x * numWorkgroups.y +\n                workgroupId.y * numWorkgroups.x + workgroupId.x) * ".concat(i,"u +\n                localIndex);\n        "),"\n      }\n    ")),a.isFromPixels){r.push("\n        struct Uniform {\n          size            : i32,\n          numChannels     : i32,\n          outShapeStrides : vec2<i32>,\n        };\n\n        @group(0) @binding(0) var<storage, read_write> result: array<".concat(P(n.dtype,a.isVec4),">;\n        @group(0) @binding(2) var<uniform> uniforms: Uniform;\n      "));var o=T(a);return[I,r.join("\n"),A(n.shape),a.getUserCode(),S(o,a)].join("\n")}var s="struct Uniforms { NAN : f32, INFINITY : f32, ";a.variableNames.forEach((function(t,n){var a=y(e[n].shape.length);s+="".concat(t.charAt(0).toLowerCase()+t.slice(1),"Shape : ").concat(a,", ")}));var u=y(n.shape.length);s+="outShape : ".concat(u,", ");var c=y(n.shape.length-1);s+="\n         outShapeStrides: ".concat(c,", "),a.size&&(s+="size : i32, ");a.uniforms&&(s+=a.uniforms);s=function(e){var t=/(\w+)\s*:\s*vec(5|6)/g;e=e.replace(t,(function(e){return"@align(16) "+e}));var n=/vec(5|6)\s*,\s*(\w+)/g;return e=e.replace(n,(function(e,t,n){return"vec".concat(t,", @align(16) ").concat(n)}))}(s+="};"),r.push(s),a.atomic?r.push("\n      @group(0) @binding(0) var<storage, read_write> result: array<atomic<i32>>;\n    "):r.push("\n      @group(0) @binding(0) var<storage, read_write> result: array<".concat(P(n.dtype,a.isVec4),">;\n    "));a.variableNames.forEach((function(t,n){r.push("\n      @group(0) @binding(".concat(1+n,") var<storage, read> ").concat(t,": array<").concat(a.variableTypes?a.variableTypes[n]:P(e[n].dtype,a.isVec4),">;\n        "))})),""!==s&&r.push("\n      @group(0) @binding(".concat(1+a.variableNames.length,") var<uniform> uniforms: Uniforms;\n      "));var d=function(e,t){var n=t.x,a=t.y,r=void 0===a?[]:a,i=t.z,o=void 0===i?[]:i,s=e.length,u=n.length+r.length+o.length;if(u!==s)return"";if(n.length===s){var c=y(s);return"fn getOutputCoords() -> ".concat(c,"{\n    let globalIndex = getGlobalIndex();\n    return getCoordsFromIndex(globalIndex);\n  }\n  ")}for(var d="",l=[n,r,o],h=0;h<l.length;h++){var p=l[h];if(0!==p.length)if(1===p.length)d+="let d".concat(p[0]," = i32(globalId[").concat(h,"]);");else{var f=v(p,"uniforms.outShape");d+="var index".concat(h," = i32(globalId[").concat(h,"]);");for(var m=0;m<f.length;m++)d+="let d".concat(p[m]," = index").concat(h," / ").concat(f[m],";"),m===f.length-1?d+="let d".concat(p[m+1]," = ")+"index".concat(h," - d").concat(p[m]," * ").concat(f[m],";"):d+="index".concat(h," = index").concat(h," - d").concat(p[m]," * ").concat(f[m],";")}}var g=[];for(h=0;h<u;h++)g.push("d".concat(h));var b=y(u),x="fn getOutputCoords() -> ".concat(b," {\n  ").concat(d,"\n");0===g.length?x+="return ".concat(b,"(0); }"):x+="return ".concat(b,"(").concat(g.join(","),"); }");return x}(n.shape,a.dispatchLayout),l=[I,r.join("\n")+C,A(n.shape),d,R(n.shape.length)];a.atomic||l.push(function(e,t,n){var a,r=e.length,i=P(t,n);a=n?"fn setOutputAtIndex(flatIndex : i32, value : vec4<f32>) {\n      result[flatIndex] = ".concat(i,"(value);\n    }\n    fn setOutputAtIndexI32(flatIndex : i32, value : vec4<i32>) {\n      result[flatIndex] = ").concat(i,"(value);\n    }"):"fn setOutputAtIndex(flatIndex : i32, value : f32) {\n      result[flatIndex] = ".concat(i,"(value);\n    }\n    fn setOutputAtIndexI32(flatIndex : i32, value : i32) {\n      result[flatIndex] = ").concat(i,"(value);\n    }");if(r>=2){var o=["d0","d1","d2","d3","d4","d5"].slice(0,r),s=y(r);a+=n?"\n      fn setOutputAtCoords(".concat(o.map((function(e){return"".concat(e," : i32")})).join(", "),", value : vec4<f32>) {\n        let flatIndex = getOutputIndexFromCoords(").concat(s,"(").concat(o.join(", "),"));\n        setOutputAtIndex(flatIndex / 4, value);\n      }\n      fn setOutputAtCoordsI32(").concat(o.map((function(e){return"".concat(e," : i32")})).join(", "),", value : vec4<i32>) {\n        let flatIndex = getOutputIndexFromCoords(").concat(s,"(").concat(o.join(", "),"));\n        setOutputAtIndexI32(flatIndex / 4, value);\n      }\n    "):"\n      fn setOutputAtCoords(".concat(o.map((function(e){return"".concat(e," : i32")})).join(", "),", value : f32) {\n        let flatIndex = getOutputIndexFromCoords(").concat(s,"(").concat(o.join(", "),"));\n        setOutputAtIndex(flatIndex, value);\n      }\n      fn setOutputAtCoordsI32(").concat(o.map((function(e){return"".concat(e," : i32")})).join(", "),", value : i32) {\n        let flatIndex = getOutputIndexFromCoords(").concat(s,"(").concat(o.join(", "),"));\n        setOutputAtIndexI32(flatIndex, value);\n      }\n    ")}return a}(n.shape,n.dtype,a.isVec4));var h=e.map((function(e,r){return function(e,n,a,r){var i=function(e,t){var n=e.name,a=e.shape.length,r=y(a),i="get"+n.charAt(0).toUpperCase()+n.slice(1),o=["d0","d1","d2","d3","d4","d5"].slice(0,a),s=o.map((function(e){return"".concat(e," : i32")})).join(", ");if(a<1)return t?"\n        fn ".concat(i,"() -> vec4<f32> {\n          return vec4<f32>(").concat(n,"[0]);\n        }\n      "):"\n      fn ".concat(i,"() ->f32 {\n        return f32(").concat(n,"[0]);\n      }\n    ");var u="uniforms.".concat(n.charAt(0).toLowerCase()+n.slice(1),"Shape"),c="".concat(a,"D");0===a&&(c="1D");if(t)return"\n      fn ".concat(i,"(").concat(s,") -> vec4<f32> {\n        return vec4<f32>(").concat(n,"[getIndexFromCoords").concat(c,"(").concat(r,"(").concat(o.join(","),"),\n          ").concat(u,") / 4]);\n      }\n      ");return"\n    fn ".concat(i,"(").concat(s,") -> f32 {\n      return f32(").concat(n,"[getIndexFromCoords").concat(c,"(").concat(r,"(").concat(o.join(","),"),\n        ").concat(u,")]);\n    }\n   ")}(e,a);e.shape.length<=n.length&&(i+=function(e,n,a,r){var i=e.name,o=i.charAt(0).toUpperCase()+i.slice(1),s="get"+o+"ByOutput",u=e.shape.length,c=n.length,d=y(c);if(t.util.arraysEqual(e.shape,n)&&r)return a?"\n      fn ".concat(s,"Index(globalIndex : i32) -> vec4<f32> {\n        return vec4<f32>(").concat(i,"[globalIndex]);\n      }\n\n      fn ").concat(s,"Coords(coords : ").concat(d,") -> vec4<f32> {\n        return vec4<f32>(").concat(i,"[").concat(c>1?"getOutputIndexFromCoords(coords)":"coords"," / 4]);\n      }\n      "):"\n    fn ".concat(s,"Index(globalIndex : i32) -> f32 {\n      return f32(").concat(i,"[globalIndex]);\n    }\n\n    fn ").concat(s,"Coords(coords : ").concat(d,") -> f32 {\n      return f32(").concat(i,"[").concat(c>1?"getOutputIndexFromCoords(coords)":"coords","]);\n    }\n    ");var l=t.backend_util.getBroadcastDims(e.shape,n),h=c-u,p="";if(0===u)return a?"\n    fn ".concat(s,"Index(globalIndex : i32) -> vec4<f32> {\n      return get").concat(o,"();\n    }\n\n    fn ").concat(s,"Coords(coords : ").concat(d,") -> vec4<f32> {\n      return get").concat(o,"();\n    }\n  "):"\n    fn ".concat(s,"Index(globalIndex : i32) -> f32{\n      return get").concat(o,"();\n    }\n\n    fn ").concat(s,"Coords(coords : ").concat(d,") -> f32{\n      return get").concat(o,"();\n    }\n  ");p=c<2&&l.length>=1?"coords = 0;":l.map((function(e){return"coords.".concat(w(e+h)," = 0;")})).join("\n");var f="";if(c<2&&u>0)f="coords";else if(c>1){var m=y(u),g=e.shape.map((function(e,t){return"coords.".concat(w(t+h))})).join(", ");f="".concat(m,"(").concat(g,")")}else f="coords";var v="uniforms.".concat(i.charAt(0).toLowerCase()+i.slice(1),"Shape"),b="".concat(u,"D");if(a)return"\n    fn ".concat(s,"Index(globalIndex : i32) -> vec4<f32> {\n      var coords = getCoordsFromIndex(globalIndex);\n      ").concat(p,"\n      return ").concat(i,"[getIndexFromCoords").concat(b,"(").concat(f,", ").concat(v,") / 4];\n    }\n\n    fn ").concat(s,"Coords(coordsIn : ").concat(d,") -> vec4<f32> {\n      var coords = coordsIn;\n      ").concat(p,"\n      return ").concat(i,"[getIndexFromCoords").concat(b,"(").concat(f,", ").concat(v,") / 4];\n    }\n  ");return"\n  fn ".concat(s,"Index(globalIndex : i32) -> f32 {\n    var coords = getCoordsFromIndex(globalIndex);\n    ").concat(p,"\n    return f32(").concat(i,"[getIndexFromCoords").concat(b,"(").concat(f,", ").concat(v,")]);\n  }\n\n  fn ").concat(s,"Coords(coordsIn : ").concat(d,") -> f32 {\n    var coords = coordsIn;\n    ").concat(p,"\n    return f32(").concat(i,"[getIndexFromCoords").concat(b,"(").concat(f,", ").concat(v,")]);\n  }\n")}(e,n,a,r));return i}(e,n.shape,a.variableTypes?"vec4<f32>"===a.variableTypes[r]:a.isVec4,a.dispatchLayout.x.length===n.shape.length)})).join("\n");l.push(h),l.push(a.getUserCode());var p=T(a);return l.push(S(p,a)),l.join("\n")}(a,{dtype:r.dtype,shape:r.shape},n),o=e.createShaderModule({code:i,label:n.constructor.name});return e.createComputePipeline({compute:{module:o,entryPoint:"_start"},label:n.constructor.name,layout:"auto"})};function y(e){if(e<=1)return"i32";if(2===e)return"vec2<i32>";if(3===e)return"vec3<i32>";if(4===e)return"vec4<i32>";if(5===e)return"vec5";if(6===e)return"vec6";throw Error("GPU for rank ".concat(e," is not yet supported"))}function w(e){if(0===e)return"x";if(1===e)return"y";if(2===e)return"z";if(3===e)return"w";if(4===e)return"u";if(5===e)return"v";throw Error("Index ".concat(e," is not yet supported"))}function k(){for(var e,t=[],n=0;n<arguments.length;n++)t[n]=arguments[n];switch(t.length){case 0:e="\n        fn main()\n      ";break;case 1:e="\n        fn main(".concat(t[0]," : i32)\n      ");break;default:throw Error("Unreachable")}return e}function S(e,t){var n;return n="\n     ".concat(function(e){return"\n  @compute @workgroup_size(".concat(e.workgroupSize[0],", ").concat(e.workgroupSize[1],", ").concat(e.workgroupSize[2],")\n")}(t),"\n      fn _start(@builtin(local_invocation_id) LocalId : vec3<u32>,\n                @builtin(global_invocation_id) GlobalId : vec3<u32>,\n                @builtin(local_invocation_index) LocalIndex: u32,\n                @builtin(workgroup_id) WorkgroupId : vec3<u32>,\n                @builtin(num_workgroups) NumWorkgroups : vec3<u32>) {\n        localId = LocalId;\n        localIndex = LocalIndex;\n        globalId = GlobalId;\n        numWorkgroups = NumWorkgroups;\n        workgroupId = WorkgroupId;\n        ").concat(e?"main(getGlobalIndex());":"main();",";\n      }\n    "),n}var I="\n  struct vec5 {x: i32, y: i32, z: i32, w: i32, u: i32};\n  struct vec6 {x: i32, y: i32, z: i32, w: i32, u: i32, v: i32};\n\n  // Checks whether coordinates lie within the bounds of the shape.\n  fn coordsInBounds2D(coord : vec2<i32>, shape : vec2<i32>) -> bool {\n    return all(coord >= vec2<i32>(0)) && all(coord < shape);\n  }\n  fn coordsInBounds3D(coord : vec3<i32>, shape : vec3<i32>) -> bool {\n    return all(coord >= vec3<i32>(0)) && all(coord < shape);\n  }\n  fn coordsInBounds4D(coord : vec4<i32>, shape : vec4<i32>) -> bool {\n    return all(coord >= vec4<i32>(0)) && all(coord < shape);\n  }\n\n  fn getIndexFromCoords1D(coord : i32, shape : i32) -> i32 {\n    return coord;\n  }\n  fn getIndexFromCoords2D(coords : vec2<i32>, shape : vec2<i32>) -> i32 {\n    return dot(coords, vec2<i32>(shape.y, 1));\n  }\n  fn getIndexFromCoords3D(coords : vec3<i32>, shape : vec3<i32>) -> i32 {\n    return dot(coords, vec3<i32>(shape.y * shape.z, shape.z, 1));\n  }\n  fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {\n    return dot(coords, vec4<i32>(\n        shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));\n  }\n  fn getIndexFromCoords5D(coords : vec5, shape : vec5) -> i32 {\n    let shapeStrides: vec5 = vec5(shape.y * shape.z * shape.w * shape.u, shape.z * shape.w * shape.u, shape.w * shape.u, shape.u, 1);\n    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u;\n  }\n  fn getIndexFromCoords6D(coords : vec6, shape : vec6) -> i32 {\n    let shapeStrides: vec6 = vec6(shape.y * shape.z * shape.w * shape.u * shape.v, shape.z * shape.w * shape.u * shape.v, shape.w * shape.u * shape.v, shape.u * shape.v, shape.v, 1);\n    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u + coords.v*shapeStrides.v;\n  }\n\n  fn idiv(a: i32, b: i32, sign: f32) -> i32 {\n    var res: i32 = a / b;\n    let modulo: i32 = a % b;\n    if (sign < 0. && modulo != 0) {\n      res = res - 1;\n    }\n    return res;\n  }\n\n  // NaN defination in IEEE 754-1985 is :\n  //   - sign = either 0 or 1.\n  //   - biased exponent = all 1 bits.\n  //   - fraction = anything except all 0 bits (since all 0 bits represents infinity).\n  // https://en.wikipedia.org/wiki/IEEE_754-1985#Representation_of_non-numbers\n  fn isnan(val: f32) -> bool {\n    let floatToUint: u32 = bitcast<u32>(val);\n    return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n  }\n  fn isnanVec4(val : vec4<f32>) -> vec4<bool> {\n    let floatToUint: vec4<u32> = bitcast<vec4<u32>>(val);\n    return (floatToUint & vec4<u32>(0x7fffffffu)) > vec4<u32>(0x7f800000u);\n  }\n",C="\n  fn isinf(val: f32) -> bool {\n    return abs(val) == uniforms.INFINITY;\n  }\n";function A(e){var n=e.length;if(n<=1)return"fn getCoordsFromIndex(index : i32) -> i32 { return index; }";for(var a,r=t.util.computeStrides(e),i=y(n),o=[],s=0;s<n;s++)o.push("d".concat(s));return 1===r.length?"    fn getCoordsFromIndex(index : i32) -> vec2<i32> {\n      let d0 = index / uniforms.outShapeStrides; let d1 = index - d0 * uniforms.outShapeStrides;\n      return vec2<i32>(d0, d1);\n    }":(a="var index2 = index;"+r.map((function(e,t){var n="let ".concat(o[t]," = index2 / uniforms.outShapeStrides.").concat(w(t)),a=t===r.length-1?"let ".concat(o[t+1]," = index2 - ").concat(o[t]," * uniforms.outShapeStrides.").concat(w(t)):"index2 = index2 - ".concat(o[t]," * uniforms.outShapeStrides.").concat(w(t));return"".concat(n,"; ").concat(a,";")})).join(""),"\n    fn getCoordsFromIndex(index : i32) -> ".concat(i," {\n      ").concat(a,"\n      return ").concat(i,"(").concat(o.join(","),");\n    }\n  "))}function R(e){var n="";switch(e){case 0:case 1:n+="\n        fn getOutputIndexFromCoords(coords : i32) -> i32 {\n          return coords;\n        }\n        ";break;case 2:n+="\n        fn getOutputIndexFromCoords(coords : vec2<i32>) -> i32 {\n          return dot(coords, vec2<i32>(uniforms.outShapeStrides, 1));\n        }\n        ";break;case 3:n+="\n        fn getOutputIndexFromCoords(coords : vec3<i32>) -> i32 {\n          return dot(coords, vec3<i32>(uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, 1));\n        }\n        ";break;case 4:n+="\n        fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {\n          return dot(coords, vec4<i32>(\n            uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, uniforms.outShapeStrides.z, 1));\n        }\n        ";break;case 5:n+="\n        fn getOutputIndexFromCoords(coords : vec5) -> i32 {\n          return coords.x * uniforms.outShapeStrides.x +\n              coords.y * uniforms.outShapeStrides.y +\n              coords.z * uniforms.outShapeStrides.z +\n              coords.w * uniforms.outShapeStrides.w +\n              coords.u;\n        }\n        ";break;case 6:n+="\n        fn getOutputIndexFromCoords(coords : vec6) -> i32 {\n          return coords.x * uniforms.outShapeStrides.x +\n              coords.y * uniforms.outShapeStrides.y +\n              coords.z * uniforms.outShapeStrides.z +\n              coords.w * uniforms.outShapeStrides.w +\n              coords.u * uniforms.outShapeStrides.u +\n              coords.v;\n        }\n        ";break;default:t.util.assert(!1,(function(){return"Unsupported ".concat(e,"D shape")}))}return n}function N(e){return 1===e.dispatch[1]&&1===e.dispatch[2]}function P(e,t){return"float32"===e?t?"vec4<f32>":"f32":"int32"===e||"bool"===e?t?"vec4<i32>":"i32":e}function T(e){return(!e.dispatchLayout.hasOwnProperty("y")||0===e.dispatchLayout.y.length)&&(!e.dispatchLayout.hasOwnProperty("z")||0===e.dispatchLayout.z.length)}var z,_=function(e){for(var t=1,n=0;n<e.length;n++)t*=e[n];return t};function F(e,t,n,a){void 0===n&&(n=[1,1,1]),void 0===a&&(a=[1,1,1]);var r=u([Math.ceil(_(e.x.map((function(e){return t[e]})))/(n[0]*a[0])),e.y?Math.ceil(_(e.y.map((function(e){return t[e]})))/(n[1]*a[1])):1,e.z?Math.ceil(_(e.z.map((function(e){return t[e]})))/(n[2]*a[2])):1],3);return[r[0],r[1],r[2]]}function B(e,t,n,a){void 0===a&&(a=!1);var r=[8,8,1],i=[4,4,1];return a||(e<=8&&(i[1]=1),t<=16&&n<=16&&(r[0]=4)),{workgroupSize:r,elementsPerThread:i}}function E(e,t,n){if(void 0===n&&(n=!1),n)return[8,8,1];var a=_(e.x.map((function(e){return t[e]}))),r=_(e.y.map((function(e){return t[e]})));return a<=4?[4,16,1]:r<=4?[16,4,1]:[16,16,1]}function L(e,t,n){if(void 0===n&&(n=!1),n)return[4,4,1];var a=_(e.x.map((function(e){return t[e]}))),r=_(e.y.map((function(e){return t[e]})));return a<=4?[1,2,1]:r<=4?[2,1,1]:[2,2,1]}function U(e){return{x:e.map((function(e,t){return t}))}}function O(e){if("float32"===e||"int32"===e||"bool"===e||"string"===e)return 4;if("complex64"===e)return 8;throw new Error("Unknown dtype ".concat(e))}function D(){return("undefined"!=typeof window||"undefined"!=typeof WorkerGlobalScope)&&!!navigator.gpu}function W(e,n){Array.isArray(e)||(e=[e]),e.forEach((function(e){null!=e&&t.util.assert("complex64"!==e.dtype,(function(){return"".concat(n," does not support complex64 tensors ")+"in the WebGPU backend."}))}))}!function(e){e[e.MatMulReduceProgram=0]="MatMulReduceProgram",e[e.MatMulSplitKProgram=1]="MatMulSplitKProgram",e[e.MatMulSmallOutputSizeProgram=2]="MatMulSmallOutputSizeProgram",e[e.MatMulPackedProgram=3]="MatMulPackedProgram",e[e.MatMulMax=4]="MatMulMax"}(z||(z={}));var M,V={__proto__:null,tilesFitEvenlyIntoShape:function(e,t){if(e.length!==t.length)throw new Error("Cannot compute whether rank ".concat(e.length)+" tiles fit evenly into rank ".concat(t.length," shape")+" - ranks must match.");return t.every((function(t,n){return t%e[n]==0}))},computeDispatch:F,computeWorkgroupInfoForMatMul:B,computeWorkgroupSizeForConv2d:E,computeWorkPerThreadForConv2d:L,flatDispatchLayout:U,GPUBytesPerElement:O,isWebGPUSupported:D,assertNotComplex:W,get MatMulProgramType(){return z}},G=t.env().getNumber("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD"),H=function(e){function n(n,a){var r=e.call(this)||this;if(r.commandQueueOwnedIds=new WeakSet,r.dispatchNumberInEncoder=0,r.disposed=!1,r.downloadWaitMs=0,r.tensorDataPendingDisposal=[],r.stagingPendingDisposal=[],r.uniformPendingDisposal=[],r.uploadWaitMs=0,!D())throw new Error("WebGPU is not supported on this device");return r.pipelineCache={},r.device=n,r.queue=n.queue,r.currentCommandEncoder=null,r.currentComputePass=null,r.supportTimeQuery=n.features.has("timestamp-query-inside-passes"),r.adapterInfo=new l(a),r.thresholdToIncreaseWorkgroups=r.adapterInfo.intelGPUGeneration>=12?16:8,r.bufferManager=new h(r.device),r.textureManager=new f(r.device),r.tensorMap=new t.DataStorage(r,t.engine()),r.supportTimeQuery&&(r.querySet=r.device.createQuerySet({type:"timestamp",count:2})),t.env().getBool("WEBGPU_USE_PROFILE_TOOL")&&(r.dummyCanvas=document.createElement("canvas"),r.dummyCanvas.width=1,r.dummyCanvas.height=1,r.dummyContext=r.dummyCanvas.getContext("webgpu"),r.dummyContext.configure({device:n,format:"bgra8unorm"}),document.body.appendChild(r.dummyCanvas)),r}return function(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Class extends value "+String(t)+" is not a constructor or null");function n(){this.constructor=e}r(e,t),e.prototype=null===t?Object.create(t):(n.prototype=t.prototype,new n)}(n,e),n.prototype.nextDataId=function(){return n.nextDataId++},n.prototype.floatPrecision=function(){return 32},n.prototype.defaultGpuBufferUsage=function(){return GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST},n.prototype.disposeData=function(e,t){if(void 0===t&&(t=!1),this.tensorDataPendingDisposal.indexOf(e)>=0)return!1;if(!this.tensorMap.has(e))return!0;var n=this.tensorMap.get(e);if(this.decRef(e),!t&&n.refCount>0)return!1;if(this.commandQueueOwnedIds.has(e))return this.tensorDataPendingDisposal.push(e),!1;var a=this.tensorMap.get(e).complexTensorInfos;return null!=a&&(this.disposeData(a.real.dataId,t),this.disposeData(a.imag.dataId,t)),this.releaseResource(e),this.tensorMap.delete(e),!0},n.prototype.memory=function(){return{numBytesInGPU:this.bufferManager.numBytesUsed,numBytesAllocatedInGPU:this.bufferManager.numBytesAllocated,unreliable:!1}},n.prototype.releaseResource=function(e){var t=this.tensorMap.get(e);if(t&&t.resourceInfo)if(t.external)t.resourceInfo=null;else{if("texture"in t.resourceInfo){var n=t.resourceInfo;n.texture instanceof GPUTexture&&this.textureManager.releaseTexture(n.texture,n.width,n.height,n.format,n.usage),n.texture=null}else{var a=t.resourceInfo;this.bufferManager.releaseBuffer(a.buffer,a.size,a.usage),a.buffer=null}t.resourceInfo=null}},n.prototype.refCount=function(e){return this.tensorMap.has(e)?this.tensorMap.get(e).refCount:0},n.prototype.incRef=function(e){this.tensorMap.get(e).refCount++},n.prototype.decRef=function(e){this.tensorMap.has(e)&&this.tensorMap.get(e).refCount--},n.prototype.write=function(e,t,n){if("complex64"===n&&null!=e)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");var a={id:this.nextDataId()};return this.tensorMap.set(a,{dtype:n,shape:t,values:e,refCount:1}),a},n.prototype.move=function(e,t,n,a,r){if("complex64"===a)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.tensorMap.set(e,{dtype:a,shape:n,values:t,refCount:r})},n.prototype.submitQueue=function(){var e=this;this.ensureComputePassEnded(),this.queue.submit([this.currentCommandEncoder.finish()]),this.currentCommandEncoder=null,this.dispatchNumberInEncoder=0,this.commandQueueOwnedIds=new WeakSet,this.tensorDataPendingDisposal.forEach((function(t){e.releaseResource(t),e.tensorMap.delete(t)})),this.uniformPendingDisposal.forEach((function(t){return e.bufferManager.releaseBuffer(t.buffer,t.size,t.usage)})),this.stagingPendingDisposal.forEach((function(t){return e.bufferManager.releaseUploadBuffer(t.buffer,t.size,t.usage)})),this.tensorDataPendingDisposal=[],this.uniformPendingDisposal=[],this.stagingPendingDisposal=[]},n.prototype.ensureCommandEncoderReady=function(){this.currentCommandEncoder||(this.currentCommandEncoder=this.device.createCommandEncoder())},n.prototype.ensureComputePassEnded=function(){this.currentComputePass&&(this.currentComputePass.end(),this.currentComputePass=null)},n.prototype.getComputePass=function(){return this.currentComputePass||(this.currentComputePass=this.currentCommandEncoder.beginComputePass()),this.currentComputePass},n.prototype.getBufferData=function(e,n){return i(this,void 0,void 0,(function(){var a,r;return o(this,(function(i){switch(i.label){case 0:return a=this.bufferManager.acquireBuffer(n,GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ),this.ensureCommandEncoderReady(),this.ensureComputePassEnded(),this.currentCommandEncoder.copyBufferToBuffer(e,0,a,0,n),this.submitQueue(),[4,a.mapAsync(GPUMapMode.READ)];case 1:return i.sent(),r=a.getMappedRange().slice(0),a.unmap(),null!=a&&this.bufferManager.releaseBuffer(a,n,GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ),t.env().getBool("WEBGPU_USE_PROFILE_TOOL")&&(t.util.assert(void 0!==this.dummyContext,(function(){return"Fail to get context for profiling tool"})),this.dummyContext.getCurrentTexture()),[2,r]}}))}))},n.prototype.convertAndCacheOnCPU=function(e,t){var n=this.tensorMap.get(e);return this.releaseResource(e),n.values=t,n.values},n.prototype.readSync=function(e){var t=this.tensorMap.get(e).values;if(null==t)throw new Error("WebGPU readSync is only available for CPU-resident tensors.");return t},n.prototype.read=function(e){return i(this,void 0,void 0,(function(){var n,a,r,i,s,u,c,d;return o(this,(function(o){switch(o.label){case 0:if(!this.tensorMap.has(e))throw new Error("Tensor ".concat(e," was not registered!"));return n=this.tensorMap.get(e),null!=(a=n.values)?[2,this.convertAndCacheOnCPU(e,a)]:"complex64"!==n.dtype?[3,2]:[4,Promise.all([this.read(n.complexTensorInfos.real.dataId),this.read(n.complexTensorInfos.imag.dataId)])];case 1:return i=o.sent(),s=i[0],u=i[1],r=t.backend_util.mergeRealAndImagArrays(s,u),[3,4];case 2:return c=n.resourceInfo,[4,this.getBufferData(c.buffer,c.size)];case 3:d=o.sent(),r=t.util.convertBackendValuesAndArrayBuffer(d,n.dtype),o.label=4;case 4:return this.convertAndCacheOnCPU(e,r),[2,r]}}))}))},n.prototype.copyBuffer=function(e,t,n){var a=this.bufferManager.acquireBuffer(t,n);return this.ensureCommandEncoderReady(),this.ensureComputePassEnded(),this.currentCommandEncoder.copyBufferToBuffer(e,0,a,0,t),this.submitQueue(),a},n.prototype.createTensorFromGPUData=function(e,n,a){var r=e.buffer;if("complex64"===a)throw new Error("Cannot write to a complex64 dtype. ");var i={id:this.nextDataId()};this.tensorMap.set(i,{dtype:a,shape:n,values:null,refCount:1,external:e.zeroCopy});var o=this.tensorMap.get(i),s=O(o.dtype)*t.util.sizeFromShape(o.shape);if(e.buffer.size<s)throw new Error("GPUBuffer size(".concat(e.buffer.size,") is smaller than tensor size(").concat(s,")!"));if((e.buffer.usage&(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC))!=(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC))throw new Error("GPUBuffer.usage should include GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC!");return!0!==e.zeroCopy&&(r=this.copyBuffer(r,s,r.usage)),o.resourceInfo={size:r.size,usage:r.usage,buffer:r},t.engine().makeTensorFromDataId(i,n,a,this)},n.prototype.readToGPU=function(e){var n=this.tensorMap.get(e),a=n.values,r=n.dtype,i=n.shape,o=n.resourceInfo;if("complex64"===r)throw new Error("Does not support reading buffer for complex64 dtype.");if(null==o)throw null!=a?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");var s=o.size,u=this.bufferManager.acquireBuffer(s,o.usage);this.ensureCommandEncoderReady(),this.ensureComputePassEnded(),this.currentCommandEncoder.copyBufferToBuffer(o.buffer,0,u,0,s),this.submitQueue();var c=this.makeTensorInfo(i,r),d=t.engine().makeTensorFromTensorInfo(c);return this.tensorMap.get(c.dataId).resourceInfo={size:s,usage:this.defaultGpuBufferUsage(),buffer:u},{tensorRef:d,buffer:u,bufSize:s}},n.prototype.bufferSync=function(e){var n=this.readSync(e.dataId);if("string"===e.dtype)try{var a=n.map((function(e){return t.util.decodeString(e)}));return t.buffer(e.shape,e.dtype,a)}catch(e){throw new Error("Failed to decode encoded string bytes into utf-8")}return t.buffer(e.shape,e.dtype,n)},n.prototype.time=function(e){return i(this,void 0,void 0,(function(){var n,a,r,i,s,u,c;return o(this,(function(o){switch(o.label){case 0:return this.supportTimeQuery||console.warn("This device doesn't support timestamp-query-inside-passes extension. Start Chrome browser with flag --disable-dawn-features=disallow_unsafe_apis then try again. Otherwise, zero will be shown for the kernel time when profiling mode is enabled. Using performance.now is not workable for webgpu since it doesn't support synchronous data read from GPU."),n=this.activeTimers,a=[],r=!1,null==this.programTimersStack?(this.programTimersStack=a,r=!0):this.activeTimers.push(a),this.activeTimers=a,e(),i=t.util.flatten(this.activeTimers.map((function(e){return e.query}))).filter((function(e){return null!=e})),s=t.util.flatten(this.activeTimers.map((function(e){return e.name}))).filter((function(e){return null!=e})),this.activeTimers=n,r&&(this.programTimersStack=null),u={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null},[4,Promise.all(i)];case 1:return c=o.sent(),u.kernelMs=t.util.sum(c),u.getExtraProfileInfo=function(){return c.map((function(e,t){return{name:s[t],ms:e}})).map((function(e){return"".concat(e.name,": ").concat(e.ms)})).join(", ")},this.uploadWaitMs=0,this.downloadWaitMs=0,[2,u]}}))}))},n.prototype.makeTensorInfo=function(e,n,a){return"string"===n&&null!=a&&a.length>0&&t.util.isString(a[0])&&(a=a.map((function(e){return t.util.encodeString(e)}))),{dataId:this.write(a,e,n),shape:e,dtype:n}},n.prototype.tensorToBinding=function(e){if(!e)return null;var t=this.tensorMap.get(e.dataId);if("texture"in t.resourceInfo){var n=t.resourceInfo;return n.texture instanceof GPUExternalTexture?n.texture:n.texture.createView()}var a=t.resourceInfo;return{offset:0,size:a.size,buffer:a.buffer}},n.prototype.getQueryTime=function(e){return i(this,void 0,void 0,(function(){return o(this,(function(t){return this.supportTimeQuery?[2,this.getTimeFromQuerySet(e)]:[2,0]}))}))},n.prototype.uploadToGPU=function(e){var n=this.tensorMap.get(e);if(!n.resourceInfo){var a=O(n.dtype)*t.util.sizeFromShape(n.shape),r=this.bufferManager.acquireBuffer(a,this.defaultGpuBufferUsage());if(n.resourceInfo={size:a,usage:this.defaultGpuBufferUsage(),buffer:r},n.values){var i=this.bufferManager.acquireUploadBuffer(a,GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC),o=i.getMappedRange();"int32"===n.dtype||"bool"===n.dtype?new Int32Array(o).set(n.values):new Float32Array(o).set(n.values),i.unmap(),this.ensureCommandEncoderReady(),this.ensureComputePassEnded(),this.currentCommandEncoder.copyBufferToBuffer(i,0,r,0,a);var s={size:a,usage:GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC,buffer:i};this.stagingPendingDisposal.push(s)}}},n.prototype.makeUniforms=function(e){var n=0,a=0,r=[],i=1;e.forEach((function(e){var o;switch(0===e.data.length&&(e.data=[1]),e.data.length){case 1:o=4;break;case 2:o=8;break;case 3:case 4:case 5:case 6:o=16;break;default:t.util.assert(!1,(function(){return"Unsupported ".concat(e.data.length,"D shape")}))}5!==a&&6!==a||(o=16),o>i&&(i=o),n=Math.ceil(n/o)*o,a=e.data.length,r.push(n),n+=4*e.data.length})),n=Math.ceil(n/i)*i;var o=new ArrayBuffer(n);e.forEach((function(e,t){var n=r[t];"int32"===e.type?new Int32Array(o,n,e.data.length).set(e.data):"uint32"===e.type?new Uint32Array(o,n,e.data.length).set(e.data):new Float32Array(o,n,e.data.length).set(e.data)}));var s=this.bufferManager.acquireBuffer(n,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);this.queue.writeBuffer(s,0,o,0,n);var u={size:n,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM,buffer:s};return this.uniformPendingDisposal.push(u),{offset:0,size:n,buffer:s}},n.prototype.runWebGPUProgram=function(e,n,a,r,i){var o=this;if(i||(i=this.makeTensorInfo(e.outputShape,a)),0===t.util.sizeFromShape(i.shape))return this.tensorMap.get(i.dataId).values=t.util.getTypedArrayFromDType(i.dtype,0),i;this.uploadToGPU(i.dataId),e.dispatch=function(e,n){var a=e.limits.maxComputeWorkgroupsPerDimension,r=n.dispatchLayout,i=n.dispatch;if(i.every((function(e){return e<=a})))return i;t.util.assert(i[0]>a&&void 0===r.y&&void 0===r.z,(function(){return"Dispatch size exceeds WebGPU limits in Y or Z dimension."}));var o=Math.ceil(Math.sqrt(i[0]));return o>a?(o=Math.ceil(Math.cbrt(i[0])),t.util.assert(o<=a,(function(){return"Total dispatch size exceeds WebGPU maximum."})),[o,o,o]):[o,o,1]}(this.device,e);var s=[],d=[];if(!e.isFromPixels){s.push({type:"float32",data:[NaN]},{type:"float32",data:[1/0]}),d=n.concat(i).map((function(e){return e.shape}));var l="int32";d.map((function(e){s.push({type:l,data:e})}));var h=t.util.computeStrides(i.shape);if(s.push({type:l,data:h}),e.size){var p=t.util.sizeFromShape(e.outputShape);s.push({type:l,data:[e.isVec4?p/4:p]})}}var f,m=n.map((function(t,n){if("complex64"===t.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");return o.uploadToGPU(t.dataId),{dtype:o.tensorMap.get(t.dataId).dtype,shape:t.shape,name:e.variableNames[n]}})),g=function(e,n,a,r){var i=e.shaderKey;if(e.isFromPixels)return i;var o=a.map((function(e){return e.dtype})).concat(r.dtype),s=a.map((function(e){return t.backend_util.getBroadcastDims(e.shape,r.shape)})),u=a.map((function(e){return t.util.arraysEqual(e.shape,r.shape)})).join("_"),c=s.map((function(e){return e.join("_")})).join(";"),d=N(e)?"flatDispatch":"";return i+"_"+(e.workgroupSize?e.workgroupSize.join(","):"")+n.map((function(e){return e.length})).join(",")+o.join(",")+e.variableNames.join(",")+c+u+d}(e,d,m,i);g in this.pipelineCache?f=this.pipelineCache[g]:(f=x(this.device,e,m,i),this.pipelineCache[g]=f),r&&(s=c(c([],u(s),!1),u(r),!1));var v=c(c([this.tensorToBinding(i)],u(n.map((function(e){return o.tensorToBinding(e)}))),!1),[this.makeUniforms(s)],!1),b=this.device.createBindGroup({layout:f.getBindGroupLayout(0),entries:v.map((function(e,t){return{binding:t,resource:e}}))});this.ensureCommandEncoderReady();var y=this.getComputePass(),w=null!=this.activeTimers;return w&&this.supportTimeQuery&&y.writeTimestamp(this.querySet,0),y.setPipeline(f),y.setBindGroup(0,b),y.dispatchWorkgroups(e.dispatch[0],e.dispatch[1],e.dispatch[2]),w&&this.supportTimeQuery&&y.writeTimestamp(this.querySet,1),this.dispatchNumberInEncoder++,n.forEach((function(e){o.commandQueueOwnedIds.add(e.dataId)})),this.commandQueueOwnedIds.add(i.dataId),t.env().get("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE")<=this.dispatchNumberInEncoder&&this.submitQueue(),w&&this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(this.querySet)}),i},n.prototype.getTimeFromQuerySet=function(e){return i(this,void 0,void 0,(function(){var t,n,a,r;return o(this,(function(i){switch(i.label){case 0:return t=this.bufferManager.acquireBuffer(16,GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE),n=this.bufferManager.acquireBuffer(16,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST),this.ensureCommandEncoderReady(),this.ensureComputePassEnded(),this.currentCommandEncoder.resolveQuerySet(e,0,2,t,0),this.currentCommandEncoder.copyBufferToBuffer(t,0,n,0,16),this.submitQueue(),[4,n.mapAsync(GPUMapMode.READ)];case 1:return i.sent(),a=new BigUint64Array(n.getMappedRange()),r=Number(a[1]-a[0]),n.unmap(),this.bufferManager.releaseBuffer(n,16,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST),this.bufferManager.releaseBuffer(t,16,GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE),[2,r/1e6]}}))}))},n.prototype.shouldExecuteOnCPU=function(e,n){var a=this;return void 0===n&&(n=G),t.env().getBool("WEBGPU_CPU_FORWARD")&&e.every((function(e){return null==a.tensorMap.get(e.dataId).resourceInfo&&t.util.sizeFromShape(e.shape)<n}))},n.prototype.numDataIds=function(){return this.tensorMap.numDataIds()-this.tensorDataPendingDisposal.length},n.prototype.dispose=function(){this.disposed||(this.bufferManager.dispose(),this.textureManager.dispose(),this.disposed=!0)},n}(t.KernelBackend);H.nextDataId=0,D()&&t.registerBackend("webgpu",(function(){return i(void 0,void 0,void 0,(function(){var e,n,a,r,i,s;return o(this,(function(o){switch(o.label){case 0:return t.env().set("CHECK_COMPUTATION_FOR_ERRORS",!1),e={powerPreference:t.env().get("WEBGPU_USE_LOW_POWER_GPU")?"low-power":"high-performance"},[4,navigator.gpu.requestAdapter(e)];case 1:return n=o.sent(),a={},n.features.has("timestamp-query-inside-passes")&&(a.requiredFeatures=["timestamp-query-inside-passes"]),r=n.limits,a.requiredLimits={maxComputeWorkgroupStorageSize:r.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:r.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:r.maxStorageBufferBindingSize},[4,n.requestDevice(a)];case 2:return i=o.sent(),[4,n.requestAdapterInfo()];case 3:return s=o.sent(),[2,new H(i,s)]}}))}))}),3),function(e){e[e.ADD=0]="ADD",e[e.ATAN2=1]="ATAN2",e[e.COMPLEX_MULTIPLY_IMAG=2]="COMPLEX_MULTIPLY_IMAG",e[e.COMPLEX_MULTIPLY_REAL=3]="COMPLEX_MULTIPLY_REAL",e[e.DIV=4]="DIV",e[e.EQUAL=5]="EQUAL",e[e.GREATER=6]="GREATER",e[e.GREATER_EQUAL=7]="GREATER_EQUAL",e[e.INT_DIV=8]="INT_DIV",e[e.LESS=9]="LESS",e[e.LESS_EQUAL=10]="LESS_EQUAL",e[e.LOGICAL_AND=11]="LOGICAL_AND",e[e.LOGICAL_OR=12]="LOGICAL_OR",e[e.MAX=13]="MAX",e[e.MIN=14]="MIN",e[e.MOD=15]="MOD",e[e.MUL=16]="MUL",e[e.NOT_EQUAL=17]="NOT_EQUAL",e[e.POW=18]="POW",e[e.PRELU=19]="PRELU",e[e.SQUARED_DIFFERENCE=20]="SQUARED_DIFFERENCE",e[e.SUB=21]="SUB"}(M||(M={}));var K,X="\n  if (isnan(a)) { return a; }\n  if (isnan(b)) { return b; }\n  ",j="\n  resultTemp = select(\n      resultTemp, vec4<f32>(valueForNaN),\n      vec4<bool>(isNaN) | isnanVec4(a) | isnanVec4(b));\n  ",q="\n  ".concat(X,"\n  if (b == 0.) {\n    return uniforms.NAN;\n  }\n  var resultTemp = a % b;\n  if ((a < 0. && b < 0.) || (a >= 0. && b > 0.)) {\n    return resultTemp;\n  } else {\n    return (resultTemp + b) % b;\n  }\n"),Y="\n  let isNaN = !vec4<bool>(b);\n  let valueForNaN = uniforms.NAN;\n  var resultTemp = vec4<f32>(a % b);\n  ".concat(j,"\n\n  if (!((a[0] < 0. && b[0] < 0.) || (a[0] >= 0. && b[0] > 0.))) {\n    resultTemp[0] = (resultTemp[0] + b[0]) % b[0];\n  }\n  if (!((a[1] < 0. && b[1] < 0.) || (a[1] >= 0. && b[1] > 0.))) {\n    resultTemp[1] = (resultTemp[1] + b[1]) % b[1];\n  }\n  if (!((a[2] < 0. && b[2] < 0.) || (a[2] >= 0. && b[2] > 0.))) {\n    resultTemp[2] = (resultTemp[2] + b[2]) % b[2];\n  }\n  if (!((a[3] < 0. && b[3] < 0.) || (a[3] >= 0. && b[3] > 0.))) {\n    resultTemp[3] = (resultTemp[3] + b[3]) % b[3];\n  }\n\n  return resultTemp;\n"),Q="\n  var resultTemp = vec4<f32>(a != b);\n  let valueForNaN = 1.0;\n  ".concat(j,"\n\n  return resultTemp;\n"),Z="\n  let isModRound1Bool = vec4<i32>(round(abs(b) % vec4<f32>(2.0))) == vec4<i32>(1);\n  let isModRound1 = vec4<f32>(isModRound1Bool);\n  let multiplier = sign(a) * isModRound1 + (vec4<f32>(1.0) - isModRound1);\n  var resultTemp = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  let isExpZero = b == vec4<f32>(0.0);\n  if (isExpZero.r) {\n    resultTemp.r = 1.0;\n  }\n  if (isExpZero.g) {\n    resultTemp.g = 1.0;\n  }\n  if (isExpZero.b) {\n    resultTemp.b = 1.0;\n  }\n  if (isExpZero.a) {\n    resultTemp.a = 1.0;\n  }\n  let isNaN = (a < vec4<f32>(0.0)) & (floor(b) < b);\n  let valueForNaN = uniforms.NAN;\n  ".concat(j,"\n  return resultTemp;\n");function J(e,t,n){void 0===n&&(n="uniforms.NAN");var a=t?j:X;return t?"\n    let valueForNaN = ".concat(n,";\n    var resultTemp = vec4<f32>(").concat(e,"(a, b));\n    ")+a+"\n    return resultTemp;\n  ":a+"\n    return ".concat(e,"(a, b);\n  ")}function $(e,t){switch(e){case M.ADD:return"return a + b;";case M.ATAN2:return J("atan2",t);case M.COMPLEX_MULTIPLY_IMAG:return"return areal * bimag + aimag * breal;";case M.COMPLEX_MULTIPLY_REAL:return"return areal * breal - aimag * bimag;";case M.DIV:return"return a / b;";case M.EQUAL:return t?"return vec4<f32>(a == b);":"return f32(a == b);";case M.GREATER:return t?"return vec4<f32>(a > b);":"return f32(a > b);";case M.GREATER_EQUAL:return t?"return vec4<f32>(a >= b);":"return f32(a >= b);";case M.INT_DIV:return t?"\n  let ia = vec4<i32>(round(a));\n  let ib = vec4<i32>(round(b));\n  let cond = ib != vec4<i32>(0);\n  var resultTemp = vec4<i32>(0);\n  let s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    resultTemp[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    resultTemp[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    resultTemp[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    resultTemp[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4<f32>(resultTemp);\n":"\n  let s = sign(a) * sign(b);\n  let ia = i32(round(a));\n  let ib = i32(round(b));\n  return f32(idiv(ia, ib, s));\n";case M.LESS:return t?"return vec4<f32>(a < b);":"return f32(a < b);";case M.LESS_EQUAL:return t?"return vec4<f32>(a <= b);":"return f32(a <= b);";case M.LOGICAL_AND:return t?"return (vec4<f32>(a >= vec4<f32>(1.0)) *\n  vec4<f32>(b >= vec4<f32>(1.0)));":"return f32(a >= 1.0 && b >= 1.0);";case M.LOGICAL_OR:return t?"return min(vec4<f32>(a >= vec4<f32>(1.0)) +\n  vec4<f32>(b >= vec4<f32>(1.0)), vec4<f32>(1.0));":"return f32(a >= 1.0 || b >= 1.0);";case M.MAX:return J("max",t);case M.MIN:return J("min",t);case M.MOD:return t?Y:q;case M.MUL:return"return a * b;";case M.NOT_EQUAL:return t?Q:"\n  if (isnan(a) || isnan(b)) {\n    return 1.0;\n  }\n  return f32(a != b);\n";case M.POW:return t?Z:"\n  if(a < 0.0 && floor(b) < b) {\n    return uniforms.NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  if (round(abs(b) % 2.0) != 1.0) {\n    return pow(abs(a), b);\n  }\n  return sign(a) * pow(abs(a), b);\n";case M.PRELU:return t?"\n  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));\n  return (aLessThanZero * (b * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);\n":"if (a < 0.0) { return b * a; }  return a;";case M.SQUARED_DIFFERENCE:return"return (a - b) * (a - b);";case M.SUB:return"return a - b;";default:throw new Error("BinaryType ".concat(e," is not implemented!"))}}!function(e){e[e.ABS=0]="ABS",e[e.ACOS=1]="ACOS",e[e.ACOSH=2]="ACOSH",e[e.ASIN=3]="ASIN",e[e.ASINH=4]="ASINH",e[e.ATAN=5]="ATAN",e[e.ATANH=6]="ATANH",e[e.CEIL=7]="CEIL",e[e.COS=8]="COS",e[e.COSH=9]="COSH",e[e.ELU=10]="ELU",e[e.ERF=11]="ERF",e[e.EXP=12]="EXP",e[e.EXPM1=13]="EXPM1",e[e.FLOOR=14]="FLOOR",e[e.IS_FINITE=15]="IS_FINITE",e[e.IS_INF=16]="IS_INF",e[e.IS_NAN=17]="IS_NAN",e[e.LINEAR=18]="LINEAR",e[e.LOG=19]="LOG",e[e.LOG1P=20]="LOG1P",e[e.LOGICAL_NOT=21]="LOGICAL_NOT",e[e.NEG=22]="NEG",e[e.RELU=23]="RELU",e[e.RELU6=24]="RELU6",e[e.LEAKYRELU=25]="LEAKYRELU",e[e.RECIPROCAL=26]="RECIPROCAL",e[e.ROUND=27]="ROUND",e[e.RSQRT=28]="RSQRT",e[e.SELU=29]="SELU",e[e.SIGMOID=30]="SIGMOID",e[e.SIGN=31]="SIGN",e[e.SIN=32]="SIN",e[e.SINH=33]="SINH",e[e.SOFTPLUS=34]="SOFTPLUS",e[e.SQRT=35]="SQRT",e[e.SQUARE=36]="SQUARE",e[e.STEP=37]="STEP",e[e.TAN=38]="TAN",e[e.TANH=39]="TANH",e[e.TO_INT=40]="TO_INT"}(K||(K={}));var ee='\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  let p = '.concat(t.backend_util.ERF_P,";\n  let a1 = ").concat(t.backend_util.ERF_A1,";\n  let a2 = ").concat(t.backend_util.ERF_A2,";\n  let a3 = ").concat(t.backend_util.ERF_A3,";\n  let a4 = ").concat(t.backend_util.ERF_A4,";\n  let a5 = ").concat(t.backend_util.ERF_A5,";\n\n  let sign = sign(a);\n  let absA = abs(a);\n  let t = 1.0 / (1.0 + p * absA);\n  return sign * (1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * exp(-absA * absA));\n"),te="\n  if (a >= 0.0) {\n    return ".concat(t.backend_util.SELU_SCALE," * a;\n  } else {\n    return ").concat(t.backend_util.SELU_SCALEALPHA," * (exp(a) - 1.0);\n  }\n");function ne(e,t){switch(e){case K.ABS:return"return abs(a);";case K.ACOS:return"\n  if (abs(a) > 1.) {\n    return uniforms.NAN;\n  }\n  return acos(a);\n";case K.ACOSH:return"\n  if (a < 1.) {\n    return uniforms.NAN;\n  }\n  return acosh(a);\n";case K.ASIN:return"\n  if (abs(a) > 1.) {\n    return uniforms.NAN;\n  }\n  return asin(a);\n";case K.ASINH:return"return asinh(a);";case K.ATAN:return"\n  if (isnan(a)) {\n    return uniforms.NAN;\n  }\n  return atan(a);\n";case K.ATANH:return"\n  if (abs(a) > 1.) {\n    return uniforms.NAN;\n  }\n  if (a == 1.) {\n    return uniforms.INFINITY;\n  }\n  if (a == -1.) {\n    return -uniforms.INFINITY;\n  }\n  return atanh(a);\n";case K.COS:return"return cos(a);";case K.COSH:return"\n  let e2x = exp(-a);\n  return (e2x + 1.0 / e2x) / 2.0;\n";case K.CEIL:return"return ceil(a);";case K.ELU:return t?"\n  var resFloat = exp(a) - vec4<f32>(1.0);\n  if (a.r >= 0.0) {\n    resFloat.r = a.r;\n  }\n  if (a.g >= 0.0) {\n    resFloat.g = a.g;\n  }\n  if (a.b >= 0.0) {\n    resFloat.b = a.b;\n  }\n  if (a.a >= 0.0) {\n    resFloat.a = a.a;\n  }\n  return resFloat;\n":"if (a >= 0.0) { return a; }  return (exp(a) - 1.0);";case K.ERF:return ee;case K.EXP:return"return exp(a);";case K.EXPM1:return"return exp(a) - 1.0;";case K.FLOOR:return"return floor(a);";case K.IS_FINITE:return"return f32(!isnan(a) && !isinf(a));";case K.IS_INF:return"return f32(isinf(a));";case K.IS_NAN:return"return f32(isnan(a));";case K.LINEAR:return"return a;";case K.LOG:return"if (a < 0.0) { return uniforms.NAN; }\n  return log(a);";case K.LOG1P:return"\n  if (isnan(a)) { return a; }\n  return log(1.0 + a);\n";case K.LOGICAL_NOT:return"return f32(!(a >= 1.0));";case K.NEG:return"return -a;";case K.LEAKYRELU:return t?"\n  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));\n  return (aLessThanZero * (uniforms.alpha * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);\n":"if (a < 0.0) { return uniforms.alpha * a; } return a;";case K.RECIPROCAL:return"return 1.0 / a;";case K.RELU:return t?"\n  return select(a, vec4<f32>(0.0), a < vec4<f32>(0.0));\n":"return select(a, 0.0, a < 0.0);";case K.RELU6:return t?"return clamp(a, vec4<f32>(0.0, 0.0, 0.0, 0.0), vec4<f32>(6.0, 6.0, 6.0, 6.0));":"return clamp(a, 0.0, 6.0);";case K.ROUND:return"return round(a);";case K.RSQRT:return"return inverseSqrt(a);";case K.SELU:return te;case K.SIGMOID:return"return 1.0 / (1.0 + exp(-1.0 * a));";case K.SIGN:return"return sign(a);";case K.SIN:return"return sin(a);";case K.SINH:return"\n  let e2x = exp(a);\n  return (e2x - 1.0 / e2x) / 2.0;\n";case K.SOFTPLUS:return"\n  let epsilon = 1.1920928955078125e-7;\n  let threshold = log(epsilon) + 2.0;\n\n  let too_large = a > -threshold;\n  let too_small = a < threshold;\n  let exp_a = exp(a);\n\n  if (too_large) {\n    return a;\n  } else if (too_small) {\n    return exp_a;\n  } else {\n    return log(exp_a + 1.0);\n  }\n";case K.SQRT:return"return sqrt(a);";case K.SQUARE:return"return a * a;";case K.STEP:return"\n  if (isnan(a)) {\n    return a;\n  }\n\n  return select(uniforms.stepAlpha, 1.0, a > 0.0);\n";case K.TAN:return"return tan(a);";case K.TANH:return"\n  let e2x = exp(-2.0 * abs(a));\n  return sign(a) * (1.0 - e2x) / (1.0 + e2x);\n";case K.TO_INT:return"return f32(i32((a)));";default:throw new Error("BinaryType ".concat(e," is not implemented!"))}}var ae=function(e){switch(e){case 1:return"f32";case 2:return"vec2<f32>";case 3:return"vec3<f32>";case 4:return"vec4<f32>";default:throw new Error("".concat(e,"-component is not supported."))}};function re(e,t,n,a){if(void 0===t&&(t=!1),void 0===n&&(n=!1),void 0===a&&(a=3),null===e)return"";var r="";if("linear"===e)r=ne(K.LINEAR);else if("relu"===e)r=ne(K.RELU,n);else if("elu"===e)r=ne(K.ELU,n);else if("relu6"===e)r=ne(K.RELU6,n);else if("prelu"===e)r=$(M.PRELU,n);else if("sigmoid"===e)r=ne(K.SIGMOID,n);else{if("leakyrelu"!==e)throw new Error("Activation ".concat(e," has not been implemented for the WebGPU backend."));r=ne(K.LEAKYRELU,n)}var i=ae(n?4:1);return t?"\n      fn activation(a : ".concat(i,", coords : vec").concat(a,"<i32>) -> ").concat(i," {\n        let b = getPreluActivationWeightsByOutputCoords(coords);\n        ").concat(r,"\n      }"):"\n      fn activation(a : ".concat(i,", coords : vec").concat(a,"<i32>) -> ").concat(i," {\n        ").concat(r,"\n      }")}function ie(e,t){return"\n      ".concat(e?"value = value + getBiasByOutputCoords(coords);":"","\n      ").concat(t?"value = activation(value, coords);":"","\n      ")}function oe(e,n,a,r,i,o){void 0===a&&(a=!1),void 0===i&&(i=!1),void 0===o&&(o=1),t.util.assert(e&&1===o||!e,(function(){return"transposeA ".concat(e," is not compatible with component size ").concat(o)}));var s="\n      ".concat(e?"value = getA(batch, col, row);":"value = getA(batch, row, col);","\n\n    "),u=n?"value = getB(batch, col, row);":"value = getB(batch, row, col);";return"\n  fn mm_readA(batch: i32, row: i32, colIn: i32) -> ".concat(ae(o)," {\n    var value = ").concat(ae(o),"(0.0);\n    let col = colIn * ").concat(o,";\n    ").concat(a&&i?s:"\n    ".concat(e?"if(row < uniforms.dimAOuter && col < uniforms.dimInner)":"if(row < uniforms.aShape[1] && col < uniforms.aShape[2])","\n    {\n      ").concat(s,"\n    }\n    "),"\n    return value;\n  }\n\n  fn mm_readB(batch: i32, row: i32, colIn: i32) -> ").concat(ae(o)," {\n    let col = colIn * ").concat(o,";\n    var value = ").concat(ae(o),"(0.0);\n    ").concat(u,"\n    return value;\n  }\n  ")}function se(e,t,n,a,r,i,o,s){return void 0===r&&(r=!1),void 0===i&&(i=!1),void 0===o&&(o=!1),void 0===s&&(s=1),"\n  ".concat(oe(n,a,r,0,o,s),"\n  fn mm_write(batch: i32, row: i32, colIn: i32, valueIn: ").concat(ae(s),") {\n    let col = colIn * ").concat(s,";\n    ").concat(r&&i?"":"if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)","\n    {\n      var value = valueIn;\n      let coords = vec3<i32>(batch, row, col);\n      ").concat(ie(e,t),"\n      setOutputAtCoords(coords[0], coords[1], coords[2], value);\n    }\n  }\n  ")}function ue(e,n,a,r,i,o,s,u){void 0===a&&(a=!1),void 0===r&&(r=32),void 0===i&&(i=!1),void 0===o&&(o=32),void 0===s&&(s=!1),void 0===u&&(u=!1);var c=n[1]*e[1],d=n[0]*e[0],l=a?c:r,h=a?r:c,p=l/n[0],f=r/n[1],m=e[1];return t.util.assert((a&&4===p&&4===e[1]||!a&&(3===p||4===p))&&l%n[0]==0&&r%n[1]==0&&4===e[0],(function(){return"If transposeA ".concat(a," is true, innerElementSize ").concat(p," and workPerThread[1] ").concat(e[1]," must be 4.\n          Otherwise, innerElementSize ").concat(p," must be 3 or 4.\n      tileAWidth ").concat(l," must be divisible by workgroupSize[0]").concat(n[0],". tileInner ").concat(r," must be divisible by workgroupSize[1] ").concat(n[1],". colPerThread ").concat(e[0]," must be 4.")})),"\n  var<workgroup> mm_Asub : array<array<vec".concat(p,"<f32>, ").concat(l/p,">, ").concat(h,">;\n  var<workgroup> mm_Bsub : array<array<vec4<f32>, ").concat(d/e[0],">, ").concat(r,">;\n\n  ").concat(k()," {\n    let localRow = i32(localId.y);\n    let tileRow = ").concat(s?"0":"localRow * ".concat(m),";\n    let tileCol = i32(localId.x);\n\n    let globalRow = ").concat(s?"0":"i32(globalId.y) * ".concat(m),";\n    let globalCol = i32(globalId.x);\n    let batch = ").concat(i?"0":"i32(globalId.z)",";\n    let batchA = ").concat(i||!u?"batch":"batch % uniforms.aShape[0]",";\n    let batchB = ").concat(i||!u?"batch":"batch % uniforms.bShape[0]",";\n    let globalRowStart = i32(workgroupId.y) * ").concat(c,";\n\n    let numTiles = ").concat(i?"".concat(Math.ceil(o/r)):"(uniforms.dimInner - 1) / ".concat(r," + 1"),";\n    var kStart = ").concat(i?"i32(globalId.z) * ".concat(o):"0",";\n\n    var acc: array<vec4<f32>, ").concat(m,">;\n\n    // Loop over shared dimension.\n    let tileRowB = localRow * ").concat(f,";\n    for (var t = 0; t < numTiles; t++) {\n        // Load one tile of A into local memory.\n        for (var innerRow = 0; innerRow < ").concat(m,"; innerRow++) {\n            let inputRow = tileRow + innerRow;\n            let inputCol = tileCol;\n            ").concat(function(e,t){return e?"\n        mm_Asub[inputRow][inputCol] = mm_readA(batchA,\n          kStart + inputRow,\n          globalRowStart / ".concat(t," + inputCol);\n        "):"\n        mm_Asub[inputRow][inputCol] = mm_readA(batchA,\n          globalRow + innerRow,\n          kStart / ".concat(t," + inputCol);\n        ")}(a,p),"\n        }\n\n        // Load one tile of B into local memory.\n        for (var innerRow = 0; innerRow < ").concat(f,"; innerRow++) {\n            let inputRow = tileRowB + innerRow;\n            let inputCol = tileCol;\n            mm_Bsub[inputRow][inputCol] = mm_readB(batchB, kStart + inputRow, globalCol);\n        }\n        kStart = kStart + ").concat(r,";\n        workgroupBarrier();\n\n        // Compute acc values for a single thread.\n        for (var k = 0; k < ").concat(r/p,"; k++) {\n            let BCached0 = mm_Bsub[k * ").concat(p,"][tileCol];\n            let BCached1 = mm_Bsub[k * ").concat(p," + 1][tileCol];\n            let BCached2 = mm_Bsub[k * ").concat(p," + 2][tileCol];\n            ").concat(3===p?"":"let BCached3 = mm_Bsub[k * ".concat(p," + 3][tileCol];"),"\n\n            ").concat(function(e,t,n){return e?"\n        let ACached0 = mm_Asub[k * ".concat(t,"][localRow];\n        let ACached1 = mm_Asub[k * ").concat(t," + 1][localRow];\n        let ACached2 = mm_Asub[k * ").concat(t," + 2][localRow];\n        ").concat(3===t?"":"let ACached3 = mm_Asub[k * ".concat(t," + 3][localRow];"),"\n        for (var i = 0; i < ").concat(n,"; i++) {\n          acc[i] = BCached0 * ACached0[i] + acc[i];\n          acc[i] = BCached1 * ACached1[i] + acc[i];\n          acc[i] = BCached2 * ACached2[i] + acc[i];\n          ").concat(3===t?"":"acc[i] = BCached3 * ACached3[i] + acc[i];","\n        }"):"\n        for (var i = 0; i < ".concat(n,"; i++) {\n          let ACached = mm_Asub[tileRow + i][k];\n          acc[i] = BCached0 * ACached.x + acc[i];\n          acc[i] = BCached1 * ACached.y + acc[i];\n          acc[i] = BCached2 * ACached.z + acc[i];\n          ").concat(3===t?"":"acc[i] = BCached3 * ACached.w + acc[i];","\n        }")}(a,p,m),"\n        }\n\n        workgroupBarrier();\n    }\n\n    for (var innerRow = 0; innerRow < ").concat(m,"; innerRow++) {\n        mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);\n    }\n  }")}var ce=function(e){return e?"\n        mm_Asub[inputRow][inputCol] = mm_readA(batchA,\n          kStart + inputRow,\n          globalRowStart + inputCol);\n        ":"\n        mm_Asub[inputRow][inputCol] = mm_readA(batchA,\n          globalRowStart + inputRow,\n          kStart + inputCol);\n        "};function de(e,n,a,r,i,o,s,u){void 0===a&&(a=!1),void 0===r&&(r=32),void 0===i&&(i=!1),void 0===o&&(o=32),void 0===s&&(s=!1),void 0===u&&(u=!1);var c=e[1]*n[1],d=e[0]*n[0],l=a?c:r,h=a?r:c;t.util.assert(h%n[1]==0&&l%n[0]==0&&r%n[1]==0,(function(){return"tileAHight ".concat(h," must be divisible by workgroupSize[1]").concat(n[1],", tileAWidth ").concat(l," must be divisible by workgroupSize[0]").concat(n[0],", tileInner ").concat(r," must be divisible by workgroupSize[1]").concat(n[1])}));var p=h/n[1],f=l/n[0],m=r/n[1],g=e[1],v=e[0],b=s?"\n      let localRow = i32(localId.y);\n      let localCol = i32(localId.x);\n      let globalRowStart = i32(workgroupId.y) * ".concat(c,";\n      let globalColStart = i32(workgroupId.x) * ").concat(d,";\n\n      // Loop over shared dimension.\n      for (var t = 0; t < numTiles; t++) {\n        // Load one tile of A into local memory.\n        for (var inputRow = localRow; inputRow < ").concat(h,"; inputRow = inputRow + ").concat(n[1],") {\n          for (var inputCol = localCol; inputCol < ").concat(l,"; inputCol = inputCol + ").concat(n[0],") {\n            ").concat(ce(a),"\n          }\n        }\n        // Load one tile of B into local memory.\n        for (var inputRow = localRow; inputRow < ").concat(r,"; inputRow = inputRow + ").concat(n[1],") {\n              for (var inputCol = localCol; inputCol < ").concat(d,"; inputCol = inputCol + ").concat(n[0],") {\n            mm_Bsub[inputRow][inputCol] = mm_readB(batchB,\n              kStart + inputRow,\n              globalColStart + inputCol);\n          }\n        }\n        kStart = kStart + ").concat(r,";\n        workgroupBarrier();\n\n        // Compute acc values for a single thread.\n        var BCached : array<f32, ").concat(v,">;\n        for (var k = 0; k < ").concat(r,"; k++) {\n          for (var inner = 0; inner < ").concat(v,"; inner++) {\n            BCached[inner] = mm_Bsub[k][localCol + inner * ").concat(n[0],"];\n          }\n          for (var innerRow = 0; innerRow < ").concat(g,"; innerRow++) {\n            let ACached = ").concat(a?"mm_Asub[k][localRow + innerRow * ".concat(n[1],"];"):"mm_Asub[localRow + innerRow * ".concat(n[1],"][k];"),"\n            for (var innerCol = 0; innerCol < ").concat(v,"; innerCol++) {\n              acc[innerRow][innerCol] = acc[innerRow][innerCol] +\n                  ACached * BCached[innerCol];\n            }\n          }\n        }\n        workgroupBarrier();\n      }\n      for (var innerRow = 0; innerRow < ").concat(g,"; innerRow++) {\n        let gRow = globalRowStart + localRow + innerRow * ").concat(n[1],";\n        for (var innerCol = 0; innerCol < ").concat(v,"; innerCol++) {\n          let gCol = globalColStart + localCol + innerCol * ").concat(n[0],";\n          mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);\n        }\n      }\n      "):"\n  let tileRow = i32(localId.y) * ".concat(g,";\n  let tileCol = i32(localId.x) * ").concat(v,";\n\n  let globalRow = i32(globalId.y) * ").concat(g,";\n  let globalCol = i32(globalId.x) * ").concat(v,";\n  let globalRowStart = i32(workgroupId.y) * ").concat(c,";\n\n  let tileRowA = i32(localId.y) * ").concat(p,";\n  let tileColA = i32(localId.x) * ").concat(f,";\n  let tileRowB = i32(localId.y) * ").concat(m,";\n  // Loop over shared dimension.\n  for (var t = 0; t < numTiles; t++) {\n    // Load one tile of A into local memory.\n    for (var innerRow = 0; innerRow < ").concat(p,"; innerRow++) {\n      for (var innerCol = 0; innerCol < ").concat(f,"; innerCol++) {\n        let inputRow = tileRowA + innerRow;\n        let inputCol = tileColA + innerCol;\n        ").concat(ce(a),"\n      }\n    }\n\n    // Load one tile of B into local memory.\n    for (var innerRow = 0; innerRow < ").concat(m,"; innerRow++) {\n      for (var innerCol = 0; innerCol < ").concat(v,"; innerCol++) {\n        let inputRow = tileRowB + innerRow;\n        let inputCol = tileCol + innerCol;\n        mm_Bsub[inputRow][inputCol] = mm_readB(batchB,\n          kStart + inputRow,\n          globalCol + innerCol);\n      }\n    }\n    kStart = kStart + ").concat(r,";\n    workgroupBarrier();\n\n    // Compute acc values for a single thread.\n    var BCached : array<f32, ").concat(v,">;\n    for (var k = 0; k < ").concat(r,"; k++) {\n      for (var inner = 0; inner < ").concat(v,"; inner++) {\n        BCached[inner] = mm_Bsub[k][tileCol + inner];\n      }\n\n      for (var innerRow = 0; innerRow < ").concat(g,"; innerRow++) {\n        ").concat(function(e){return e?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];"}(a),"\n        for (var innerCol = 0; innerCol < ").concat(v,"; innerCol++) {\n          acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];\n        }\n      }\n    }\n\n    workgroupBarrier();\n  }\n\n  for (var innerRow = 0; innerRow < ").concat(g,"; innerRow++) {\n    for (var innerCol = 0; innerCol < ").concat(v,"; innerCol++) {\n      mm_write(batch, globalRow + innerRow, globalCol + innerCol,\n          acc[innerRow][innerCol]);\n    }\n  }\n  ");return"\n    var<workgroup> mm_Asub : array<array<f32, ".concat(l,">, ").concat(h,">;\n    var<workgroup> mm_Bsub : array<array<f32, ").concat(d,">, ").concat(r,">;\n\n    ").concat(k()," {\n      let batch = ").concat(i?"0":"i32(globalId.z)",";\n      let batchA = ").concat(i||!u?"batch":"batch % uniforms.aShape[0]",";\n      let batchB = ").concat(i||!u?"batch":"batch % uniforms.bShape[0]",";\n      let numTiles = ").concat(i?"".concat(Math.ceil(o/r)):"(uniforms.dimInner - 1) / ".concat(r," + 1"),";\n      var kStart = ").concat(i?"i32(globalId.z) * ".concat(o):"0",";\n\n      var acc : array<array<f32, ").concat(v,">, ").concat(g,">;\n\n      // Without this initialization strange values show up in acc.\n      for (var innerRow = 0; innerRow < ").concat(g,"; innerRow++) {\n        for (var innerCol = 0; innerCol < ").concat(v,"; innerCol++) {\n          acc[innerRow][innerCol] = 0.0;\n        }\n      }\n      ").concat(b,"\n    }\n  ")}var le=function(){function e(e,t,n,a,r,i,o,s){var c;void 0===n&&(n=!1),void 0===a&&(a=!1),void 0===r&&(r=null),void 0===i&&(i=null),void 0===o&&(o=null),void 0===s&&(s=!1),this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=t,this.dispatchLayout={x:[2],y:[1],z:[0]};var d=n?e[1]:e[2];if(this.isVec4=(d%4==0&&!n||t[1]%4==0&&n)&&t[2]%4==0&&!a,this.isVectorA=1===t[1]&&!n,!this.isVec4&&this.isVectorA)this.elementsPerThread=[1,1,1],this.workgroupSize=[32,1,1];else{var l=B(t[1],d,t[2],n);this.workgroupSize=l.workgroupSize,this.elementsPerThread=l.elementsPerThread}this.dispatch=F(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread);var h=null!=r,p=null!=o;h&&this.variableNames.push("bias"),p&&this.variableNames.push("preluActivationWeights"),this.sequentialAccessByThreads=s,this.transposeA=n,this.transposeB=a,this.addBias=h,this.activation=i,this.hasPreluActivationWeights=p,c=u(this.getShapeFit(t[1],t[2],d),3),this.fitAOuter=c[0],this.fitBOuter=c[1],this.fitInner=c[2],this.shaderKey="matMulPacked_".concat(this.elementsPerThread,"_").concat(n,"_").concat(a,"_").concat(this.activation,"_").concat(this.fitAOuter,"_").concat(this.fitBOuter,"_").concat(this.fitInner,"_").concat(this.isVec4,"_").concat(this.isVectorA,"_").concat(this.sequentialAccessByThreads)}return e.prototype.getShapeFit=function(e,t,n){var a=this.workgroupSize[1]*this.elementsPerThread[1],r=this.workgroupSize[0]*this.elementsPerThread[0];return!this.isVec4&&this.isVectorA?this.tileInner=4*this.workgroupSize[0]:this.tileInner=r,[e%a==0,t%r==0,n%this.tileInner==0]},e.prototype.getUserCode=function(){var e="\n      ".concat(re(this.activation,this.hasPreluActivationWeights,this.isVec4),"\n      ").concat(se(this.addBias,this.activation,!1,this.transposeB,this.fitAOuter,this.fitBOuter,this.fitInner,this.isVec4?4:1),"\n      ").concat(this.isVec4?ue(this.elementsPerThread,this.workgroupSize,this.transposeA,this.tileInner,!1,null,this.isVectorA,!0):this.isVectorA?function(e,n){void 0===n&&(n=!1),t.util.assert(1===e[1]&&1===e[2],(function(){return"A linear work group size is required. But got ".concat(e,".")}));var a=4*e[0];return"\n    var<workgroup> mm_Asub : array<vec4<f32>, ".concat(e[0],">;\n\n    ").concat(k()," {\n      let tileCol = i32(localId.x);\n      let globalCol = i32(globalId.x);\n      let globalRow = i32(globalId.y);\n\n      let numTiles = (uniforms.dimInner - 1) / ").concat(a," + 1;\n      let batch = i32(globalId.z);\n      let batchA = batch % uniforms.aShape[0];\n      let batchB = batch % uniforms.bShape[0];\n      // Without this initialization strange values show up in acc.\n      var acc = 0.0;\n\n      // Loop over shared dimension.\n      for (var t = 0; t < numTiles; t++) {\n        // Load one tile of A into local memory.\n        let colA = t * ").concat(a," + tileCol * 4;\n        mm_Asub[tileCol] = vec4<f32>(").concat(function(e){return e?"\n      mm_readA(batchA, colA, globalRow),\n      mm_readA(batchA, colA + 1, globalRow),\n      mm_readA(batchA, colA + 2, globalRow),\n      mm_readA(batchA, colA + 3, globalRow)\n  ":"\n      mm_readA(batchA, globalRow, colA),\n      mm_readA(batchA, globalRow, colA + 1),\n      mm_readA(batchA, globalRow, colA + 2),\n      mm_readA(batchA, globalRow, colA + 3)\n  "}(n),");\n        workgroupBarrier();\n\n        // Compute acc values for a single thread.\n        for (var k = 0; k < ").concat(a/4,"; k++) {\n          let rowB = t * ").concat(a," + k * 4;\n          let BCached = vec4<f32>(mm_readB(batchB, rowB, globalCol),\n                              mm_readB(batchB, rowB + 1, globalCol),\n                              mm_readB(batchB, rowB + 2, globalCol),\n                              mm_readB(batchB, rowB + 3, globalCol));\n\n          let ACached = mm_Asub[k];\n          acc = acc + dot(ACached, BCached);\n        }\n\n        workgroupBarrier();\n      }\n\n      mm_write(batch, globalRow, globalCol, acc);\n    }\n  ")}(this.workgroupSize,this.transposeA):de(this.elementsPerThread,this.workgroupSize,this.transposeA,this.tileInner,!1,null,this.sequentialAccessByThreads,!0),"\n    ");return e},e}();var he=function(){function e(e,t,n,a,r,i){void 0===t&&(t=!1),void 0===n&&(n=!1),void 0===a&&(a=null),void 0===r&&(r=null),void 0===i&&(i=null),this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[256,1,1],this.outputShape=e,this.dispatchLayout={x:[],y:[1,2],z:[0]},this.dispatch=F(this.dispatchLayout,this.outputShape,this.workgroupSize);var o=null!=a,s=null!=i;o&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),this.transposeA=t,this.transposeB=n,this.addBias=o,this.activation=r,this.hasPreluActivationWeights=s,this.shaderKey="matMulReduce_".concat(this.activation,"_").concat(t,"_").concat(n)}return e.prototype.getUserCode=function(){var e;return"\n      ".concat(re(this.activation,this.hasPreluActivationWeights),"\n      ").concat(se(this.addBias,this.activation,this.transposeA,this.transposeB),"\n      ").concat((e=this.workgroupSize[0],"\n    var<workgroup> sumValues : array<f32, ".concat(e,">;\n    ").concat(k()," {\n      let coords = getOutputCoords();\n      let batch = coords[0];\n      let batchA = batch % uniforms.aShape[0];\n      let batchB = batch % uniforms.bShape[0];\n      let row = coords[1];\n      let col = coords[2];\n      var sum = 0.0;\n      let Length = uniforms.dimInner;\n      for (var k = i32(localId.x); k < Length; k = k + ").concat(e,") {\n        let dataA = mm_readA(batchA, row, k);\n        let dataB = mm_readB(batchB, k, col);\n        sum = sum + dataA * dataB;\n      }\n      sumValues[localId.x] = sum;\n      workgroupBarrier();\n\n      for(var currentSize = ").concat(e/2,"u; currentSize > 1u;\n          currentSize = currentSize / 2u) {\n        if (localId.x < currentSize)\n        {\n          sumValues[localId.x] = sumValues[localId.x] + sumValues[localId.x + currentSize];\n        }\n        workgroupBarrier();\n      }\n\n      if (localId.x == 0u) {\n        sum = sumValues[0] + sumValues[1];\n        mm_write(batch, row, col, sum);\n      }\n    }\n  ")),"\n    ")},e}();var pe=function(){function e(e,t,n,a,r,i,o,s){void 0===a&&(a=!1),void 0===r&&(r=!1),void 0===i&&(i=null),void 0===o&&(o=null),void 0===s&&(s=null),this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[16,8,1],this.outputShape=n,this.dispatchLayout={x:[2],y:[1],z:[0]},this.dispatch=[Math.ceil(n[2]/this.workgroupSize[0]),Math.ceil(n[1]/this.workgroupSize[1]),n[0]];var u=null!=i;u&&this.variableNames.push("bias");var c=null!=s;c&&this.variableNames.push("preluActivationWeights"),this.transposeA=a,this.transposeB=r,this.addBias=u,this.activation=o,this.hasPreluActivationWeights=c,this.shaderKey="matMulSmallOutputSize_".concat(this.activation,"_").concat(a,"_").concat(r)}return e.prototype.getUserCode=function(){var e,t,n,a;return"\n      ".concat(re(this.activation,this.hasPreluActivationWeights),"\n      ").concat(se(this.addBias,this.activation,this.transposeA,this.transposeB),"\n      ").concat((e=this.workgroupSize,t=e[1],n=e[0],"\n  var<workgroup> mm_Asub : array<array<f32, ".concat(a=t>n?t:n,">, ").concat(t,">;\n  var<workgroup> mm_Bsub : array<array<f32, ").concat(n,">, ").concat(a,">;\n\n  // If the output size is small for matrix multiplication, avoid to use vec4\n  // and handle some elements per thread to optimally utilize the ALU.\n  // Read data from global memory to registers firstly, then store them into\n  // shared memory, so it is instruction-Level parallelism for arithmetic\n  // operations and others handle IO operations between barrier api, makes ALU\n  // and load/store units work simultaneously, could improves the performance.\n  ").concat(k()," {\n    let tileRow = i32(localId.y);\n    let tileCol = i32(localId.x);\n    let globalRow = i32(globalId.y);\n    let globalCol = i32(globalId.x);\n    let batch = i32(globalId.z);\n    let batchA = batch % uniforms.aShape[0];\n    let batchB = batch % uniforms.bShape[0];\n\n    // uniforms.dimInner should be greater than 0.\n    let numTiles = (uniforms.dimInner - 1) / ").concat(a," + 1;\n    var acc = 0.0;\n\n    var globalColA = tileCol;\n    var globalRowB = 0;\n    var regA = mm_readA(batchA, globalRow, globalColA);\n    var regB0 = mm_readB(batchB, globalRowB + 2 * tileRow, globalCol);\n    var regB1 = mm_readB(batchB, globalRowB + 2 * tileRow + 1, globalCol);\n    globalColA = globalColA + ").concat(a,";\n    globalRowB = globalRowB + ").concat(a,";\n\n    for (var t = 0; t < numTiles; t = t + 1) {\n      mm_Asub[tileRow][tileCol] = regA;\n      mm_Bsub[2 * tileRow][tileCol] = regB0;\n      mm_Bsub[2 * tileRow + 1][tileCol] = regB1;\n\n      workgroupBarrier();\n\n      regA = mm_readA(batchA, globalRow, globalColA);\n      regB0 = mm_readB(batchB, globalRowB + 2 * tileRow, globalCol);\n      regB1 = mm_readB(batchB, globalRowB + 2 * tileRow + 1, globalCol);\n      globalColA = globalColA + ").concat(a,";\n      globalRowB = globalRowB + ").concat(a,";\n\n      for (var k = 0; k < ").concat(a,"; k = k + 1) {\n        acc = acc + mm_Asub[tileRow][k] * mm_Bsub[k][tileCol];\n      }\n      workgroupBarrier();\n    }\n\n    mm_write(batch, globalRow, globalCol, acc);\n  }\n  ")),"\n    ")},e}(),fe=function(){function e(e,n,a,r){void 0===a&&(a=!1),void 0===r&&(r=!1),this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[8,8,1],this.atomic=!0,this.isVec4=!1,this.splitedDimInner=128,t.util.assert(1===e[0],(function(){return"MatMulSplitKProgram only supports batch = 1."})),this.outputShape=e,this.dispatchLayout={x:[2],y:[1],z:[0,3]},this.isVec4=(a&&this.outputShape[1]%4==0||!a&&n%4==0)&&this.outputShape[2]%4==0,this.elementsPerThread=[4,4,this.splitedDimInner],this.isVec4||(this.outputShape[1]<16&&(this.elementsPerThread[1]=1),this.outputShape[2]<16&&(this.elementsPerThread[0]=1)),this.dispatch=F(this.dispatchLayout,[this.outputShape[0],this.outputShape[1],this.outputShape[2],n],this.workgroupSize,this.elementsPerThread),this.transposeA=a,this.transposeB=r,this.shaderKey="matMulSplitK_".concat(a,"_").concat(r,"_").concat(this.elementsPerThread,"_").concat(this.isVec4)}return e.prototype.getUserCode=function(){var e=this.isVec4?4:1;return"\n      ".concat(oe(!1,this.transposeB,!1,0,!1,e),"\n      fn mm_write(batch: i32, row : i32, colIn : i32, value : ").concat(ae(e),") {\n        let col = colIn * ").concat(e,";\n        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {\n          let coords = vec3<i32>(batch, row, col);\n          let flatIndex = getOutputIndexFromCoords(coords);\n          // The problem is that we should initialize output to zero before using.\n          // Otherwise, the original value will be added to the result.\n          for (var i = 0; i < ").concat(e,"; i = i + 1) {\n            ").concat(b("&result[flatIndex + i]","".concat(e>1?"value[i]":"value"),"float32"),"\n          }\n        }\n      }\n      ").concat(this.isVec4?ue(this.elementsPerThread,this.workgroupSize,this.transposeA,32,!0,this.splitedDimInner):de(this.elementsPerThread,this.workgroupSize,this.transposeA,32,!0,this.splitedDimInner),"\n    ")},e}(),me=function(){function e(e,t,n,a){void 0===t&&(t=null),void 0===n&&(n=null),void 0===a&&(a=null),this.uniforms="",this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=U(this.outputShape),this.dispatch=F(this.dispatchLayout,this.outputShape,this.workgroupSize),this.addBias=null!=t,this.hasPreluActivationWeights=null!=a,this.activation=n,this.addBias&&this.variableNames.push("bias"),this.hasPreluActivationWeights&&this.variableNames.push("preluActivationWeights"),this.shaderKey="biasActivation_".concat(n)}return e.prototype.getUserCode=function(){return"\n    ".concat(re(this.activation,this.hasPreluActivationWeights),"\n    ").concat(k("index")," {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        var value = getXByOutputIndex(index);\n        ").concat(ie(this.addBias,this.activation),"\n        setOutputAtIndex(index, value);\n      }\n    }\n    ")},e}(),ge=function(){function e(e){this.variableNames=[],this.outputShape=[],this.uniforms="value : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=U(this.outputShape),this.dispatch=F(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="fill"}return e.prototype.getUserCode=function(){return"\n    ".concat(k("index")," {\n      if (index < uniforms.size) {\n        setOutputAtIndex(index, uniforms.value);\n      }\n    }\n  ")},e}();function ve(e){var n=e.backend,a=e.attrs,r=a.shape,i=a.value,o=a.dtype;if("string"===(o=o||t.util.inferDtype(i))){var s=t.util.getArrayFromDType(o,t.util.sizeFromShape(r));return s.fill(i),n.makeTensorInfo(r,o,s)}var u=new ge(r),c=[{type:"float32",data:[i]}];return n.runWebGPUProgram(u,[],o,c)}var be={kernelName:t.Fill,backendName:"webgpu",kernelFunc:ve};function xe(e){var n=e.inputs,a=e.attrs,r=n.x,i=a.shape,o=t.util.sizeFromShape(r.shape),s=t.util.inferFromImplicitShape(i,o),u=t.util.sizeFromShape(s);return t.util.assert(o===u,(function(){return"The new shape (".concat(s,") has ").concat(u," elements and the old ")+"shape (".concat(r.shape,") has ").concat(o," elements. The new shape and old ")+"shape must have the same number of elements."})),e.backend.incRef(r.dataId),{dataId:r.dataId,shape:s,dtype:r.dtype}}var ye={kernelName:t.Reshape,backendName:"webgpu",kernelFunc:xe};function we(e){var n,a,r,i,o=e.a,u=e.b,c=e.transposeA,d=e.transposeB,l=e.backend,h=e.bias,p=void 0===h?null:h,f=e.preluActivationWeights,m=void 0===f?null:f,g=e.leakyreluAlpha,v=void 0===g?0:g,b=e.activation,x=void 0===b?null:b,y=o.shape.length,w=u.shape.length,k=c?o.shape[y-2]:o.shape[y-1],S=d?u.shape[w-1]:u.shape[w-2],I=c?o.shape[y-1]:o.shape[y-2],C=d?u.shape[w-2]:u.shape[w-1],A=o.shape.slice(0,-2),R=u.shape.slice(0,-2),N=t.util.sizeFromShape(A),P=t.util.sizeFromShape(R),T=t.broadcast_util.assertAndGetBroadcastShape(o.shape.slice(0,-2),u.shape.slice(0,-2)).concat([I,C]);t.util.assert(k===S,(function(){return"Error in matMul: inner shapes (".concat(k,") and (")+"".concat(S,") of Tensors with shapes ").concat(o.shape," and ")+"".concat(u.shape," and transposeA=").concat(c)+" and transposeB=".concat(d," must match.")}));var _,F,B=c?[N,k,I]:[N,I,k],E=d?[P,C,S]:[P,S,C],L=xe({inputs:{x:o},backend:l,attrs:{shape:B}}),U=xe({inputs:{x:u},backend:l,attrs:{shape:E}}),O=[L,U],D=Math.max(N,P),W=[L,U],M=[{type:"int32",data:[I]},{type:"int32",data:[C]},{type:"int32",data:[k]}],V=[D,I,C],G=t.env().get("WEBGPU_MATMUL_PROGRAM_TYPE");if(G<0){var H=t.env().getNumber("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL"),K=H>0?H:l.thresholdToIncreaseWorkgroups,X=D*Math.ceil(I/32)*Math.ceil(C/32);G=X<=K||I<=8&&X<=2*K?D*I*C<=128?z.MatMulReduceProgram:1===D&&S>=2e3?z.MatMulSplitKProgram:z.MatMulSmallOutputSizeProgram:z.MatMulPackedProgram}switch(G){case z.MatMulReduceProgram:_=new he(V,c,d,p,x,m);break;case z.MatMulSplitKProgram:if(F=ve({backend:l,attrs:{shape:V,value:0,dtype:o.dtype}}),_=new fe(V,S,c,d),p||x){F=l.runWebGPUProgram(_,W,o.dtype,M,F);var j=new me(F.shape,p,x,m),q=null,Y=[F];p&&Y.push(p),m&&Y.push(m),"leakyrelu"===x&&(q=[{type:"float32",data:[v]}],j.uniforms+=" alpha : f32,");var Q=l.runWebGPUProgram(j,Y,F.dtype,q);O.push(F);var Z=xe({inputs:{x:Q},backend:l,attrs:{shape:T}});O.push(Q);try{for(var J=s(O),$=J.next();!$.done;$=J.next()){var ee=$.value;l.disposeData(ee.dataId)}}catch(e){n={error:e}}finally{try{$&&!$.done&&(a=J.return)&&a.call(J)}finally{if(n)throw n.error}}return Z}break;case z.MatMulSmallOutputSizeProgram:_=new pe(B,E,V,c,d,p,x,m);break;case z.MatMulPackedProgram:var te=l.adapterInfo.isIntel();_=new le(B,V,c,d,p,x,m,te);break;default:throw new Error("Unsupported MatMulProgramType ".concat(G,"."))}p&&W.push(p),m&&W.push(m),"leakyrelu"===x&&(M.push({type:"float32",data:[v]}),_.uniforms+=" alpha : f32,");var ne=xe({inputs:{x:F=l.runWebGPUProgram(_,W,o.dtype,M,F)},backend:l,attrs:{shape:T}});O.push(F);try{for(var ae=s(O),re=ae.next();!re.done;re=ae.next()){ee=re.value;l.disposeData(ee.dataId)}}catch(e){r={error:e}}finally{try{re&&!re.done&&(i=ae.return)&&i.call(ae)}finally{if(r)throw r.error}}return ne}var ke={kernelName:t._FusedMatMul,backendName:"webgpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,a=e.attrs,r=t.a,i=t.b,o=t.bias,s=t.preluActivationWeights,u=a.transposeA,c=a.transposeB,d=a.activation;return we({a:r,b:i,transposeA:u,transposeB:c,backend:n,bias:o,preluActivationWeights:s,leakyreluAlpha:a.leakyreluAlpha,activation:d})}},Se=function(){function e(e,n,a){this.variableNames=["AReal","AImag","BReal","BImag"],this.workgroupSize=[128,1,1],this.size=!0,this.outputShape=t.backend_util.assertAndGetBroadcastShape(n,a),this.dispatchLayout=U(this.outputShape),this.dispatch=F(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="binaryOpComplex_".concat(e),this.op=e}return e.prototype.getUserCode=function(){var e=$(this.op,!1);return"\n      fn binaryOpComplex(\n          areal : f32, aimag : f32, breal : f32, bimag : f32) -> f32 {\n        ".concat(e,"\n      }\n\n      ").concat(k("index")," {\n        if(index < uniforms.size) {\n          let areal = getARealByOutputIndex(index);\n          let aimag = getAImagByOutputIndex(index);\n          let breal = getBRealByOutputIndex(index);\n          let bimag = getBImagByOutputIndex(index);\n          setOutputAtIndex(index, binaryOpComplex(areal, aimag, breal, bimag));\n        }\n      }\n    ")},e}(),Ie=function(){function e(e,n,a){this.size=!0,this.variableNames=["A","B"],this.outputShape=t.backend_util.assertAndGetBroadcastShape(n,a),this.dispatchLayout=U(this.outputShape),this.op=e,this.useSharedMemoryWithA=n.length<=1&&a.length>1&&n[0]<128,this.useSharedMemoryWithB=a.length<=1&&n.length>1&&a[0]<128,this.useSharedMemoryWithA||this.useSharedMemoryWithB?(this.isVec4=!1,this.lastDimensionSize=this.useSharedMemoryWithB?a[0]:n[0],this.shaderKey="binary_".concat(this.type,"_").concat(e,"_").concat(this.lastDimensionSize,"_").concat(this.useSharedMemoryWithB),this.type="shared",this.workgroupSize=[256,1,1],this.workPerThread=1):(t.util.arraysEqual(n,a)&&t.util.sizeFromShape(n)%4==0?(this.isVec4=!0,this.type="vec4",this.workPerThread=4):(this.isVec4=!1,this.type="plain",this.workPerThread=1),this.shaderKey="binary_".concat(this.type,"_").concat(e),this.workgroupSize=[128,1,1]),this.dispatch=F(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1])}return e.prototype.getUserCode=function(){var e,t=this.isVec4?"vec4<f32>":"f32",n="\n    fn binaryOperation(a : ".concat(t,", b : ").concat(t,") -> ").concat(t," {\n      let isNaN = false;\n      {\n        ").concat($(this.op,this.isVec4),"\n      }\n    };\n    ");if("shared"===this.type){var a=this.lastDimensionSize>1?"coords[".concat(this.outputShape.length-1,"]"):"0",r=this.useSharedMemoryWithB?"let a = getAByOutputIndex(index);\n          let b = sharedBuf[".concat(a,"];"):"let a = sharedBuf[".concat(a,"];\n          let b = getBByOutputIndex(index);");e="\n        ".concat(n,"\n        var<workgroup> sharedBuf : array<f32, ").concat(this.lastDimensionSize,">;\n        ").concat(k("index")," {\n          // Fill in the shared memory buffer.\n          let localIndex = i32(localId.x);\n          if(localIndex < ").concat(this.lastDimensionSize,") {\n            sharedBuf[localIndex] = f32(").concat(this.useSharedMemoryWithB?"B":"A","[localIndex]);\n          }\n          workgroupBarrier();\n\n          if(index < uniforms.size) {\n            let coords = getCoordsFromIndex(index);\n            ").concat(r,"\n            setOutputAtIndex(index, binaryOperation(a, b));\n          }\n        }\n        ")}else e="\n       ".concat(n,"\n       ").concat(k("index")," {\n         if (index < uniforms.size) {\n           let a = getAByOutputIndex(index);\n           let b = getBByOutputIndex(index);\n           setOutputAtIndex(index, binaryOperation(a, b));\n         }\n       }\n       ");return e},e}();function Ce(e){var t=e.inputs.x;return e.backend.incRef(t.dataId),{dataId:t.dataId,shape:t.shape,dtype:t.dtype}}var Ae={kernelName:t.Identity,backendName:"webgpu",kernelFunc:Ce};function Re(e){var t=e.inputs,n=e.backend,a=t.real,r=t.imag,i=n.makeTensorInfo(a.shape,"complex64"),o=n.tensorMap.get(i.dataId),s=Ce({inputs:{x:a},backend:n}),u=Ce({inputs:{x:r},backend:n});return o.complexTensorInfos={real:s,imag:u},i}var Ne={kernelName:t.Complex,backendName:"webgpu",kernelFunc:Re},Pe=function(){function e(e,t,n){void 0===n&&(n=""),this.variableNames=["A"],this.size=!0;this.workgroupSize=[128,1,1],this.outputShape=e,this.dispatchLayout=U(this.outputShape),this.dispatch=F(this.dispatchLayout,this.outputShape,this.workgroupSize),this.op=t,""!==n&&(this.uniforms=n),this.shaderKey="unary_".concat(t)}return e.prototype.getUserCode=function(){return"\n      fn unaryOperation(a : f32) -> f32 {\n        ".concat(ne(this.op,!1),"\n      }\n      ").concat(k("index")," {\n        if (index < uniforms.size) {\n          let a = getAByOutputIndex(index);\n          setOutputAtIndex(index, unaryOperation(a));\n        }\n      }\n      ")},e}();function Te(e){var t=e.opType,n=e.cpuKernelImpl,a=e.dtype;return function(e){var r=e.inputs,i=e.backend,o=r.x,s=i,u=a||o.dtype;if(s.shouldExecuteOnCPU([o])&&null!=n){var c=s.tensorMap.get(o.dataId),d=n(c.values,u);return s.makeTensorInfo(o.shape,u,d)}var l=new Pe(o.shape,t);return s.runWebGPUProgram(l,[o],u)}}function ze(e){var n=e.opType,a=e.cpuKernelImpl,r=e.supportsComplex,i=void 0!==r&&r,o=e.dtype;return function(e){var r,s=e.inputs,c=e.backend,d=s.a,l=s.b,h=c;if(i&&"complex64"===d.dtype){var p=h.tensorMap.get(d.dataId),f=h.tensorMap.get(l.dataId),m=void 0,g=void 0;if(n!==M.MUL)r=u([[p.complexTensorInfos.real,f.complexTensorInfos.real],[p.complexTensorInfos.imag,f.complexTensorInfos.imag]].map((function(e){var a=u(e,2),r=a[0],i=a[1],o={dataId:r.dataId,dtype:r.dtype,shape:d.shape},s={dataId:i.dataId,dtype:i.dtype,shape:l.shape},c=new Ie(n,d.shape,l.shape);return h.runWebGPUProgram(c,[o,s],t.upcastType(r.dtype,i.dtype))})),2),m=r[0],g=r[1];else{var v=new Se(M.COMPLEX_MULTIPLY_REAL,d.shape,l.shape),b=new Se(M.COMPLEX_MULTIPLY_IMAG,d.shape,l.shape),x=[{dataId:p.complexTensorInfos.real.dataId,dtype:p.complexTensorInfos.real.dtype,shape:d.shape},{dataId:p.complexTensorInfos.imag.dataId,dtype:p.complexTensorInfos.imag.dtype,shape:d.shape},{dataId:f.complexTensorInfos.real.dataId,dtype:f.complexTensorInfos.real.dtype,shape:l.shape},{dataId:f.complexTensorInfos.imag.dataId,dtype:f.complexTensorInfos.imag.dtype,shape:l.shape}];m=h.runWebGPUProgram(v,x,"float32"),g=h.runWebGPUProgram(b,x,"float32")}var y=Re({inputs:{real:m,imag:g},backend:h});return h.disposeData(m.dataId),h.disposeData(g.dataId),y}var w=o||t.upcastType(d.dtype,l.dtype);if(("string"===d.dtype||"string"===l.dtype||h.shouldExecuteOnCPU([d,l]))&&null!=a){p=h.tensorMap.get(d.dataId).values,f=h.tensorMap.get(l.dataId).values;var k="string"===d.dtype?t.backend_util.fromUint8ToStringArray(p):p,S="string"===d.dtype?t.backend_util.fromUint8ToStringArray(f):f,I=u(a(d.shape,l.shape,k,S,w),2),C=I[0],A=I[1];return h.makeTensorInfo(A,w,C)}var R=new Ie(n,d.shape,l.shape);return h.runWebGPUProgram(R,[d,l],w)}}function _e(e){return function(n,a,r,i,o){var s=t.backend_util.assertAndGetBroadcastShape(n,a),u=s.length,c=t.util.computeStrides(s),d=t.util.sizeFromShape(s),l=t.util.getTypedArrayFromDType(o,d),h=n.length,p=a.length,f=t.util.computeStrides(n),m=t.util.computeStrides(a),g=t.backend_util.getBroadcastDims(n,s),v=t.backend_util.getBroadcastDims(a,s);if(g.length+v.length===0)for(var b=0;b<l.length;++b)l[b]=e(r[b%r.length],i[b%i.length]);else{var x=function(n){var a=t.util.indexToLoc(n,u,c),o=a.slice(-h);g.forEach((function(e){return o[e]=0}));var s=t.util.locToIndex(o,h,f),d=a.slice(-p);v.forEach((function(e){return d[e]=0}));var b=t.util.locToIndex(d,p,m);l[n]=e(r[s],i[b])};for(b=0;b<l.length;++b)x(b)}return[l,s]}}var Fe=_e((function(e,t){return e+t}));function Be(e){return function(n,a,r){for(var i=t.util.getTypedArrayFromDType(a,n.length),o=0;o<n.length;++o)i[o]=e(n[o],r);return i}}var Ee=Be((function(e){return Math.ceil(e)}));var Le=_e((function(e,t){return e===t?1:0})),Ue=Be((function(e){return Math.exp(e)})),Oe=Be((function(e){return Math.expm1(e)})),De=Be((function(e){return Math.floor(e)}));var We=_e((function(e,t){return e>t?1:0})),Me=_e((function(e,t){return e>=t?1:0})),Ve=_e((function(e,t){return e<t?1:0})),Ge=_e((function(e,t){return e<=t?1:0})),He=Be((function(e){return Math.log(e)}));var Ke=_e((function(e,t){return Math.max(e,t)})),Xe=_e((function(e,t){return Math.min(e,t)})),je=_e((function(e,t){return e*t}));var qe=_e((function(e,t){return e!==t?1:0}));t.backend_util.RowPartitionType;var Ye=Be((function(e){return 1/Math.sqrt(e)}));var Qe=function(){function e(e,n,a,r,i,o){this.separator=t.util.encodeString(e),this.nGramWidths=n,this.leftPad=t.util.encodeString(a),this.rightPad=t.util.encodeString(r),this.padWidth=i,this.preserveShort=o}return e.prototype.getPadWidth=function(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)},e.prototype.getNumNGrams=function(e,t){var n=this.getPadWidth(t);return Math.max(0,e+2*n-t+1)},e.prototype.createNGrams=function(e,t,n,a,r,i){for(var o=function(o){var u=s.getPadWidth(i),c=Math.max(0,u-o),d=Math.max(0,u-(r-(o+1))),l=i-(c+d),h=t+(c>0?0:o-u),p=0;p+=c*s.leftPad.length;for(var f=0;f<l;++f)p+=e[h+f].length;p+=d*s.rightPad.length,p+=(c+d+l-1)*s.separator.length,n[a+o]=new Uint8Array(p);var m=n[a+o],g=0,v=function(e){return e.forEach((function(e){return m[g++]=e}))};for(f=0;f<c;++f)v(s.leftPad),v(s.separator);for(f=0;f<l-1;++f)v(e[h+f]),v(s.separator);if(l>0){v(e[h+l-1]);for(f=0;f<d;++f)v(s.separator),v(s.rightPad)}else{for(f=0;f<d-1;++f)v(s.rightPad),v(s.separator);v(s.rightPad)}},s=this,u=0;u<r;++u)o(u)},e.prototype.compute=function(e,n){var a=this,r=e.length,i=n.length;if(i>0){var o=n[0];if(0!==o)throw new Error("First split value must be 0, got ".concat(o));for(var s=1;s<i;++s){var u=n[s]>=o;if(!(u=u&&n[s]<=r))throw new Error("Invalid split value ".concat(n[s],", must be in [").concat(o,", ").concat(r,"]"));o=n[s]}if(o!==r)throw new Error("Last split value must be data size. Expected ".concat(r,", got ").concat(o))}var c=i-1,d=t.util.getArrayFromDType("int32",i);if(0===r||0===i){var l=new Array(r);for(s=0;s<=c;++s)d[s]=0;return[l,d]}d[0]=0;var h=function(e){var t=n[e]-n[e-1],r=0;p.nGramWidths.forEach((function(e){r+=a.getNumNGrams(t,e)})),p.preserveShort&&t>0&&0===r&&(r=1),d[e]=d[e-1]+r},p=this;for(s=1;s<=c;++s)h(s);var f=new Array(d[c]),m=function(t){var r=n[t],i=d[t];if(g.nGramWidths.forEach((function(o){var s=n[t+1]-n[t],u=a.getNumNGrams(s,o);a.createNGrams(e,r,f,i,u,o),i+=u})),g.preserveShort&&i===d[t]){var o=n[t+1]-n[t];if(0===o)return"continue";var s=o+2*g.padWidth;g.createNGrams(e,r,f,i,1,s)}},g=this;for(s=0;s<c;++s)m(s);return[f,d]},e}();var Ze=_e((function(e,t){return e-t}));var Je=function(e,t){var n=t.value-e.value;return 0===n?e.index-t.index:n};function $e(e,n,a,r){for(void 0===a&&(a=0),void 0===r&&(r=e.length-1);r>a;){if(r-a>600){var i=r-a+1,o=n-a+1,s=Math.log(i),u=.5*Math.exp(2*s/3),c=.5*Math.sqrt(s*u*(i-u)/i)*Math.sign(o-i/2);$e(e,n,Math.max(a,Math.floor(n-o*u/i+c)),Math.min(r,Math.floor(n+(i-o)*u/i+c)))}var d=e[n],l=a,h=r;for(t.util.swap(e,a,n),Je(e[r],d)>0&&t.util.swap(e,a,r);l<h;){for(t.util.swap(e,l,h),l++,h--;Je(e[l],d)<0;)l+=1;for(;Je(e[h],d)>0;)h-=1}0===Je(e[a],d)?t.util.swap(e,a,h):(h+=1,t.util.swap(e,h,r)),h<=n&&(a=h+1),n<=h&&(r=h-1)}}var et=Fe,tt=function(e,n,a,r){if("int32"===r)return[n,"int32",Int32Array.from(e)];if("bool"===r){var i=t.util.toTypedArray([0],a),o=u(_e((function(e,t){return e!==t?1:0}))(n,[],e,i,"bool"),2),s=o[0];return[o[1],"bool",s]}throw new Error("Error in Cast: failed to cast ".concat(a," to ").concat(r))},nt=Ee,at=function(e,n,a,r){var i=t.util.getArrayFromDType(a,t.util.sizeFromShape(n));if(r&&"string"!==a){var o=0;e.forEach((function(e){var n=t.util.sizeFromShape(e.shape);i.set(e.vals,o),o+=n}))}else{var s=0;e.forEach((function(e){for(var r="string"===a?t.backend_util.fromUint8ToStringArray(e.vals):e.vals,o=0,u=0;u<e.shape[0];++u)for(var c=u*n[1]+s,d=0;d<e.shape[1];++d)i[c+d]=r[o++];s+=e.shape[1]}))}return i},rt=Le,it=Ue,ot=Oe,st=De,ut=function(e,n,a,r,i,o,s,d,l){for(var h=t.buffer([r,o],a),p=0;p<r;p++){for(var f=[],m=0,g=0;g<i;g++){var v=e[p*i+g];m+=v*s[g],f.push(v)}if(m<0||m>=l/o)throw new Error("Invalid indices: ".concat(f," does not index into ").concat(d));for(var b=0;b<o;b++)h.values[p*o+b]=n.get.apply(n,c([],u(n.indexToLoc(m*o+b)),!1))}return h},ct=function(e,n,a){for(var r=t.buffer(a,e.dtype),i=0;i<r.size;++i){var o=r.indexToLoc(i).slice(),s=o[0],u=o[2],c=n.locToIndex([s,u]);o[2]=n.values[c];var d=e.locToIndex(o);0<=d&&d<e.values.length&&(r.values[i]=e.values[d])}return r},dt=Me,lt=We,ht=Ge,pt=Ve,ft=He,mt=function(e,n,a,r){for(var i=t.util.getTypedArrayFromDType(r,t.util.sizeFromShape(a)),o=0;o<i.length;++o){for(var s=o*n,u=e[s],c=0;c<n;++c){var d=e[s+c];(Number.isNaN(d)||d>u)&&(u=d)}i[o]=u}return i},gt=Ke,vt=Xe,bt=je,xt=function(e,n,a){var r=t.util.createScalarValue(-1,a);return je([],n,r,e,a)},yt=qe,wt=function(e,n,a,r){for(var i=u(t.backend_util.computeOutAndReduceShapes(e,r),2),o=i[0],s=i[1],c=t.upcastType(n,"int32"),d=t.util.makeZerosTypedArray(t.util.sizeFromShape(o),c),l=t.util.sizeFromShape(s),h=0;h<d.length;++h){for(var p=h*l,f=1,m=0;m<l;++m)f*=a[p+m];d[h]=f}return{outVals:d,outShape:o,outDtype:c}},kt=function(e,n,a,r){if(e===n||e<n&&a<0||n<e&&a>1)return t.util.makeZerosTypedArray(0,r);var i=Math.abs(Math.ceil((n-e)/a)),o=t.util.makeZerosTypedArray(i,r);n<e&&1===a&&(a=-1),o[0]=e;for(var s=1;s<o.length;s++)o[s]=o[s-1]+a;return o},St=Ye,It=function(e,n,a,r,i,o,s,u,c,d){var l=[r/i,i],h=e.values,p=n.values;if(0===r)return t.buffer(a,n.dtype);var f=t.buffer(l,n.dtype);"string"==typeof c||"number"==typeof c?f.values.fill(c):"boolean"==typeof c&&f.values.fill(+c);for(var m=0;m<o;m++){for(var g=[],v=0,b=0;b<s;b++){var x=h[m*s+b];g.push(x),v+=x*u[b]}if(v<0||v>=r/i)throw new Error("Invalid indices: ".concat(g," does not index into ").concat(a));for(var y=0;y<i;y++)d?f.values[v*i+y]+=p[m*i+y]:f.values[v*i+y]=0===n.rank?p[0]:p[m*i+y]}return f},Ct=function(e){for(var t=new Float32Array(e.length),n=0;n<e.length;++n)t[n]=Math.abs(e[n]);return t},At=function(e,n,a,r,i){var o=t.slice_util.isSliceContinous(r,n,a),s=t.util.sizeFromShape(a),d=t.util.computeStrides(r);if(o){var l=t.slice_util.computeFlatOffset(n,d);return"string"===i?e.slice(l,l+s):e.subarray(l,l+s)}for(var h="string"===i?t.backend_util.fromUint8ToStringArray(e):e,p=t.buffer(r,i,h),f=t.buffer(a,i),m=0;m<f.size;++m){var g=f.indexToLoc(m),v=g.map((function(e,t){return e+n[t]}));f.set.apply(f,c([p.get.apply(p,c([],u(v),!1))],u(g),!1))}return"string"===i?t.backend_util.fromStringArrayToUint8(f.values):f.values},Rt=function(e,n,a,r){for(var i=t.buffer(e,n.dtype),o=0;o<i.size;o++){for(var s=i.indexToLoc(o),d=new Array(s.length),l=0;l<d.length;l++)d[l]=s[l]*a[l]+r[l];i.set.apply(i,c([n.get.apply(n,c([],u(d),!1))],u(s),!1))}return i},Nt=function(e,t,n,a,r,i,o,s){return new Qe(n,a,r,i,o,s).compute(e,t)},Pt=Ze,Tt=function(e,n){for(var a=new Array(e.rank),r=0;r<a.length;r++)a[r]=e.shape[r]*n[r];var i=t.buffer(a,e.dtype);for(r=0;r<i.values.length;++r){for(var o=i.indexToLoc(r),s=new Array(e.rank),u=0;u<s.length;u++)s[u]=o[u]%e.shape[u];var c=e.locToIndex(s);i.values[r]=e.values[c]}return i},zt=function(e,n,a,r,i){for(var o=n[n.length-1],s=u([e.length/o,o],2),c=s[0],d=s[1],l=t.util.getTypedArrayFromDType(a,c*r),h=t.util.getTypedArrayFromDType("int32",c*r),p=function(t){var n=t*d,a=e.subarray(n,n+d),o=new Array(a.length);a.forEach((function(e,t){return o[t]={value:e,index:t}})),r<o.length&&($e(o,r),o=o.slice(0,r)),i&&o.sort(Je);for(var s=t*r,u=l.subarray(s,s+r),c=h.subarray(s,s+r),p=0;p<r;p++)u[p]=o[p].value,c[p]=o[p].index},f=0;f<c;f++)p(f);var m=n.slice();return m[m.length-1]=r,[t.buffer(m,a,l),t.buffer(m,"int32",h)]},_t=function(e,n,a,r,i){for(var o=n.length,s=t.util.sizeFromShape(n),u=t.util.computeStrides(n),c=t.util.computeStrides(i),d=t.util.getTypedArrayFromDType(a,t.util.sizeFromShape(i)),l=0;l<s;++l){for(var h=t.util.indexToLoc(l,o,u),p=new Array(h.length),f=0;f<p.length;f++)p[f]=h[r[f]];d[t.util.locToIndex(p,o,c)]=e[l]}return d},Ft=Te({opType:K.ABS,cpuKernelImpl:Ct}),Bt={kernelName:t.Abs,backendName:"webgpu",kernelFunc:Ft},Et=Te({opType:K.ACOS}),Lt={kernelName:t.Acos,backendName:"webgpu",kernelFunc:Et},Ut=Te({opType:K.ACOSH}),Ot={kernelName:t.Acosh,backendName:"webgpu",kernelFunc:Ut},Dt=ze({opType:M.ADD,cpuKernelImpl:et,supportsComplex:!0}),Wt={kernelName:t.Add,backendName:"webgpu",kernelFunc:Dt},Mt=function(){function e(e){this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e[0],this.variableNames=e.map((function(e,t){return"T".concat(t)})),this.dispatchLayout=U(this.outputShape),this.dispatch=F(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.shaderKey="addN"}return e.prototype.getUserCode=function(){var e=[];this.variableNames.forEach((function(t){e.push("let v".concat(t," = get").concat(t,"ByOutputCoords(coords);"))}));var t=this.variableNames.map((function(e){return"v".concat(e)})).join(" + ");return"\n      ".concat(k("index")," {\n        for (var i = 0; i < ").concat(this.workPerThread,"; i = i + 1) {\n          let flatIndex = index * ").concat(this.workPerThread," + i;\n          if (flatIndex < uniforms.size) {\n            let coords = getCoordsFromIndex(flatIndex);\n            ").concat(e.join("\n        "),"\n            setOutputAtIndex(flatIndex, ").concat(t,");\n          }\n        }\n      }\n    ")},e}();var Vt={kernelName:t.AddN,backendName:"webgpu",kernelFunc:function(e){var n=e.inputs,a=e.backend,r=n;if(1===r.length)return Ce({inputs:{x:r[0]},backend:a});var i=r.map((function(e){return e.dtype})).reduce((function(e,n){return t.upcastType(e,n)})),o=r.map((function(e){return e.shape})),s=new Mt(o);return a.runWebGPUProgram(s,r,i)}},Gt=function(){function e(e,t){this.variableNames=["A"],this.workgroupSize=[16,16,1];for(var n=new Array(e.length),a=0;a<n.length;a++)n[a]=e[t[a]];this.outputShape=n,this.dispatchLayout={x:[0],y:[1]},this.dispatch=F(this.dispatchLayout,this.outputShape,this.workgroupSize,[1,1,1]),this.shaderKey="transposeShared"}return e.prototype.getUserCode=function(){var e=this;t.util.assert(this.workgroupSize[0]===this.workgroupSize[1],(function(){return"Must be a square tile, current tile shape is ".concat(e.workgroupSize[0]," x ").concat(e.workgroupSize[1])}));var n=this.workgroupSize[0];return"\n      var<workgroup> tile : array<array<f32, ".concat(this.workgroupSize[0]+1,">, ").concat(this.workgroupSize[0],">;\n      ").concat(k()," {\n        var x = i32(workgroupId.x) * ").concat(n," + i32(localId.x);\n        var y = i32(workgroupId.y) * ").concat(n," + i32(localId.y);\n        let width = uniforms.outShape[0];\n        let height = uniforms.outShape[1];\n        if (x < width && y < height) {\n          tile[localId.y][localId.x] = f32(A[y * width + x]);\n        }\n        workgroupBarrier();\n\n        x = i32(workgroupId.y) * ").concat(n," + i32(localId.x);\n        y = i32(workgroupId.x) * ").concat(n," + i32(localId.y);\n        if (x < height && y < width) {\n          setOutputAtIndex((y * height + x), tile[localId.x]\n            [localId.y]);\n        }\n      }\n    ")},e}(),Ht=function(){function e(e,t){this.variableNames=["A"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0;for(var n=new Array(e.length),a=0;a<n.length;a++)n[a]=e[t[a]];this.outputShape=n,this.dispatchLayout=U(this.outputShape),this.dispatch=F(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.newDim=t,this.shaderKey="transpose_".concat(t)}return e.prototype.getUserCode=function(){var e=y(this.outputShape.length),t=function(e){var t=e.length;if(t>6)throw Error("Transpose for rank ".concat(t," is not yet supported"));for(var n=new Array(t),a=0;a<e.length;a++)n[e[a]]="resRC.".concat(w(a));return n.join()}(this.newDim);return"\n      ".concat(k("index")," {\n        for(var i = 0; i < ").concat(this.workPerThread,"; i = i + 1) {\n          let flatIndex = index * ").concat(this.workPerThread," + i;\n          if(flatIndex < uniforms.size) {\n            let resRC = getCoordsFromIndex(flatIndex);\n            setOutputAtIndex(flatIndex, A[getIndexFromCoords").concat(this.outputShape.length,"D(\n              ").concat(e,"(").concat(t,"), uniforms.aShape)]);\n          }\n        }\n      }\n    ")},e}();function Kt(e){for(var n=e.inputs,a=e.backend,r=e.attrs,i=n.x,o=r.perm,s=a,u=i.shape.length,c=new Array(u),d=0;d<c.length;d++)c[d]=i.shape[o[d]];if(a.shouldExecuteOnCPU([i])){var l=s.tensorMap.get(i.dataId).values,h=_t(l,i.shape,i.dtype,o,c);return a.makeTensorInfo(c,i.dtype,h)}if(2===i.shape.length&&t.util.arraysEqual(o,[1,0])){var p=new Gt(i.shape,o);return s.runWebGPUProgram(p,[i],i.dtype)}var f=new Ht(i.shape,o);return s.runWebGPUProgram(f,[i],i.dtype)}var Xt={kernelName:t.Transpose,backendName:"webgpu",kernelFunc:Kt},jt=function(){function e(e,n){this.workgroupSize=[64,1,1],this.variableNames=["x"],this.uniforms="reduceSize : i32,",this.size=!0,this.inputShape=[e.batchSize,e.inSize];var a=u(t.backend_util.computeOutAndReduceShapes(this.inputShape,[1]),1)[0];this.outputShape=0===a.length?[1]:a,this.dispatchLayout=U(this.outputShape),this.dispatch=F(this.dispatchLayout,this.outputShape,[1,1,1]),this.reduceType=n,this.shaderKey="reduce_".concat(n)}return e.prototype.getUserCode=function(){var e="",t="0.0",n=this.workgroupSize[0];"min"===this.reduceType||"max"===this.reduceType?(e="\n         if (isnan(candidate)) {\n          bestValue = uniforms.NAN;\n         } else if (!isnan(bestValue) && candidate ".concat("min"===this.reduceType?"<":">"," bestValue)\n           {  bestValue = candidate; }"),t="f32(x[offset])"):"sum"===this.reduceType||"mean"===this.reduceType?e=" bestValue = bestValue + candidate; ":"prod"===this.reduceType?(e=" bestValue = bestValue * candidate; ",t="1.0"):"all"===this.reduceType?(e=" bestValue = f32(bestValue >= 1.0 && candidate >= 1.0); ",t="1.0"):"any"===this.reduceType&&(e=" bestValue = f32(bestValue >= 1.0 || candidate >= 1.0); ",t="0.0");var a="mean"===this.reduceType?"setOutputAtIndex(outputIndex, bestValue / f32(uniforms.reduceSize));":"setOutputAtIndex(outputIndex, bestValue);",r="\n         var<workgroup> xBestValues : array<f32, ".concat(n,">;\n       ");return"\n       fn DIV_CEIL(a : u32, b : u32) -> u32 {\n        return ((a - 1u) / b + 1u);\n       }\n\n       ".concat(r,"\n       fn getOffset(outputIndex : i32) -> i32 {\n         let outputCoords = getCoordsFromIndex(outputIndex);\n         let offset = ").concat(1===this.outputShape.length?"outputCoords":"outputCoords[0]"," * uniforms.reduceSize;\n          return offset;\n       }\n       ").concat(k("index")," {\n         let outputIndex = index / ").concat(n,";\n         let offset = getOffset(outputIndex);\n         var bestValue = ").concat(t,";\n         let Length = uniforms.reduceSize;\n         let WorkPerThread = DIV_CEIL(u32(Length), ").concat(n,"u);\n         for (var k = i32(localId.x); k < Length && outputIndex < uniforms.size;\n             k = k + ").concat(n,") {\n           let candidate = f32(x[offset + k]);\n           ").concat(e,"\n         }\n         xBestValues[localId.x] = bestValue;\n         workgroupBarrier();\n\n         var reduceSize = min(u32(Length), ").concat(n,"u);\n         for (var currentSize = reduceSize / 2u; reduceSize > 1u;\n             currentSize = reduceSize / 2u) {\n           let interval = DIV_CEIL(reduceSize, 2u);\n           if (localId.x < currentSize) {\n            let candidate = xBestValues[localId.x + interval];\n            ").concat(e,"\n            xBestValues[localId.x] = bestValue;\n           }\n           reduceSize = interval;\n           workgroupBarrier();\n         }\n\n         if (localId.x == 0u && outputIndex < uniforms.size) {\n          ").concat(a,"\n        }\n       }\n     ")},e}();function qt(e,n,a,r,i){var o=e.shape.length,s=[],c=t.util.parseAxisParam(n,e.shape),d=c,l=t.backend_util.getAxesPermutation(d,o),h=e;null!=l&&(h=Kt({inputs:{x:e},attrs:{perm:l},backend:i}),d=t.backend_util.getInnerMostAxes(d.length,o),s.push(h)),t.backend_util.assertAxesAreInnerMostDims(r,d,o);var p,f=u(t.backend_util.computeOutAndReduceShapes(h.shape,d),2),m=f[0],g=f[1],v=m;if(a&&(v=t.backend_util.expandShapeToKeepDim(m,c)),"max"!==r&&"prod"!==r||!i.shouldExecuteOnCPU([h])){var b=t.util.sizeFromShape(g),x={windowSize:b,inSize:b,batchSize:t.util.sizeFromShape(h.shape)/b,outSize:1},y="mean"===r?"float32":t.sumOutType(e.dtype),w=[{type:"int32",data:[b]}],k=new jt(x,r),S=i.runWebGPUProgram(k,[h],y,w);s.push(S),p=xe({inputs:{x:S},attrs:{shape:v},backend:i})}else{var I=i.tensorMap.get(h.dataId).values;switch(r){case"max":var C=mt(I,t.util.sizeFromShape(g),v,e.dtype);p=i.makeTensorInfo(v,e.dtype,C);break;case"prod":var A=wt(h.shape,h.dtype,I,d),R=A.outVals,N=A.outShape,P=A.outDtype;p=i.makeTensorInfo(N,P,R);break;default:throw new Error("".concat(r," CPU implementation is not yet supported."))}}return s.forEach((function(e){return i.disposeData(e.dataId)})),p}var Yt={kernelName:t.All,backendName:"webgpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,a=e.attrs,r=t.x,i=a.keepDims;return qt(r,a.axis,i,"all",n)}};var Qt={kernelName:t.Any,backendName:"webgpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,a=e.attrs,r=t.x,i=a.keepDims;return qt(r,a.axis,i,"any",n)}},Zt=function(){function e(e,n,a){this.workgroupSize=[64,1,1],this.variableNames=["x"],this.uniforms="infinityValue : f32,",this.size=!0;var r=[n];this.op="min"===a?"<":">";var i=u(t.backend_util.computeOutAndReduceShapes(e,r),2),o=i[0],s=i[1];this.outputShape=0===o.length?[1]:o,this.dispatchLayout=U(this.outputShape),t.util.sizeFromShape(s)<32||t.util.sizeFromShape(o)>1e3?(this.type="plain",this.dispatch=F(this.dispatchLayout,this.outputShape,this.workgroupSize)):(this.type="shared",this.dispatch=F(this.dispatchLayout,this.outputShape,[1,1,1])),this.inputShape=e,this.shaderKey="argMinMax_".concat(this.op,"_").concat(this.type)}return e.prototype.getUserCode=function(){var e=this,t=this.workgroupSize[0],n=function(){return 1===e.inputShape.length?"uniforms.xShape":"uniforms.xShape.".concat(w(e.inputShape.length-1))},a=function(){var t="";if(1===e.outputShape.length)1!==e.inputShape.length&&(t+="outputCoords,");else for(var n=0;n<e.outputShape.length;n++)t+="outputCoords.".concat(w(n),",");return t};if("shared"===this.type){var r="\n      var<workgroup> xBestIndices : array<i32, ".concat(t,">;\n      var<workgroup> xBestValues : array<f32, ").concat(t,">;\n    ");return"\n      fn DIV_CEIL(a : u32, b : u32) -> u32 {\n        return ((a - 1u) / b + 1u);\n      }\n\n      ".concat(r,"\n\n      ").concat(k("index")," {\n        let outputIndex = index / ").concat(t,";\n        let reduceLength = ").concat(n(),";\n\n        var bestIndex = i32(localId.x);\n        var bestValue = uniforms.infinityValue;\n        let outputCoords = getCoordsFromIndex(outputIndex);\n        for (var k = i32(localId.x); k < reduceLength && outputIndex < uniforms.size;\n            k = k + ").concat(t,") {\n          let candidate = getX(").concat(a()," k);\n          if (!isnan(candidate) && candidate ").concat(this.op," bestValue) {\n            bestValue = candidate;\n            bestIndex = k;\n          }\n        }\n        xBestValues[localId.x] = bestValue;\n        xBestIndices[localId.x] = bestIndex;\n        workgroupBarrier();\n\n        var reduceSize = min(u32(reduceLength), ").concat(t,"u);\n        for (var currentSize = reduceSize / 2u; reduceSize > 1u;\n            currentSize = reduceSize / 2u) {\n          let interval = DIV_CEIL(reduceSize, 2u);\n          if (localId.x < currentSize) {\n            let candidate = xBestValues[localId.x + interval];\n            if (candidate ").concat(this.op," bestValue) {\n              bestValue = candidate;\n              xBestValues[localId.x] = bestValue;\n              xBestIndices[localId.x] = xBestIndices[localId.x + interval];\n            }\n          }\n          reduceSize = interval;\n          workgroupBarrier();\n        }\n\n        if (localId.x == 0u && outputIndex < uniforms.size) {\n          setOutputAtIndexI32(outputIndex, xBestIndices[localId.x]);\n        }\n      }\n    ")}return"\n      ".concat(k("index")," {\n        if (index < uniforms.size) {\n          let outputCoords = getCoordsFromIndex(index);\n          var bestIndex = 0;\n          var bestValue = getX(").concat(a()," 0);\n          let reduceLength = ").concat(n(),";\n          for (var i = 1; i < reduceLength; i++) {\n            let candidate = getX(").concat(a()," i);\n            if (candidate ").concat(this.op," bestValue) {\n              bestValue = candidate;\n              bestIndex = i;\n            }\n          }\n          setOutputAtIndexI32(index, bestIndex);\n        }\n      }\n      ")},e}();var Jt={kernelName:t.ArgMax,backendName:"webgpu",kernelFunc:function(e){var n=e.inputs,a=e.backend,r=e.attrs,i=n.x,o=r.axis,s=t.util.parseAxisParam(o,i.shape),u=t.backend_util.getAxesPermutation(s,i.shape.length),c=i,d=[];null!=u&&(c=Kt({inputs:{x:i},backend:a,attrs:{perm:u}}),d.push(c),s=t.backend_util.getInnerMostAxes(s.length,c.shape.length)),t.backend_util.assertAxesAreInnerMostDims("argMax",[s[0]],c.shape.length);var l=new Zt(c.shape,s[0],"max"),h=[{type:"float32",data:[Number.NEGATIVE_INFINITY]}],p=a.runWebGPUProgram(l,[c],"int32",h);return d.forEach((function(e){return a.disposeData(e.dataId)})),p}};var $t={kernelName:t.ArgMin,backendName:"webgpu",kernelFunc:function(e){var n=e.inputs,a=e.backend,r=e.attrs,i=n.x,o=r.axis,s=t.util.parseAxisParam(o,i.shape),u=t.backend_util.getAxesPermutation(s,i.shape.length),c=i,d=[];null!=u&&(c=Kt({inputs:{x:i},backend:a,attrs:{perm:u}}),d.push(c),s=t.backend_util.getInnerMostAxes(s.length,c.shape.length)),t.backend_util.assertAxesAreInnerMostDims("argMin",[s[0]],c.shape.length);var l=new Zt(c.shape,s[0],"min"),h=[{type:"float32",data:[Number.POSITIVE_INFINITY]}],p=a.runWebGPUProgram(l,[c],"int32",h);return d.forEach((function(e){return a.disposeData(e.dataId)})),p}},en=Te({opType:K.ASIN}),tn={kernelName:t.Asin,backendName:"webgpu",kernelFunc:en},nn=Te({opType:K.ASINH}),an={kernelName:t.Asinh,backendName:"webgpu",kernelFunc:nn},rn=Te({opType:K.ATAN}),on={kernelName:t.Atan,backendName:"webgpu",kernelFunc:rn},sn=ze({opType:M.ATAN2}),un={kernelName:t.Atan2,backendName:"webgpu",kernelFunc:sn},cn=Te({opType:K.ATANH}),dn={kernelName:t.Atanh,backendName:"webgpu",kernelFunc:cn},ln=function(){function e(e,t){this.variableNames=["x"],this.uniforms="stride : vec2<i32>, pad : vec2<i32>, dilation : vec2<i32>, convDims : vec2<i32>, filterDims : vec2<i32>,",this.workgroupSize=[128,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=U(this.outputShape),this.dispatch=F(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="pool2D_".concat(t),this.poolType=t}return e.prototype.getUserCode=function(){var e="resultValue = max(value, resultValue);";"avg"===this.poolType&&(e="resultValue = resultValue + value; count = count + 1.0;");var t="resultValue";return"avg"===this.poolType&&(t="resultValue / max(count, 1.0)"),"\n      ".concat(k("index")," {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n          let batch = coords[0];\n          let xRCCorner = vec2<i32>(coords.yz) * uniforms.stride - uniforms.pad;\n          let xRCorner = xRCCorner.x;\n          let xCCorner = xRCCorner.y;\n\n          var resultValue = ").concat("avg"===this.poolType?"0.0":"-1.0 / pow(10.0, -20.0)",";\n          var count = 0.0;\n\n          for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + uniforms.dilation.x) {\n            let xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= uniforms.convDims.x) {\n              continue;\n            }\n\n            for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + uniforms.dilation.y) {\n              let xC = xCCorner + wC;\n              if (xC < 0 || xC >= uniforms.convDims.y) {\n                continue;\n              }\n\n              let value = getX(batch, xR, xC, coords[3]);\n              ").concat(e,"\n            }\n          }\n\n          setOutputAtIndex(index, ").concat(t,");\n        }\n      }\n    ")},e}(),hn=function(){function e(e){this.variableNames=["x"],this.uniforms="stride : vec2<i32>,",this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=U(this.outputShape),this.dispatch=F(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="poolWithFilterSizeEqualsOne"}return e.prototype.getUserCode=function(){return"\n      ".concat(k("index")," {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let batch = coords[0];\n          let d = coords[3];\n\n          let xRCCorner = coords.yz * uniforms.stride;\n          let xRCorner = xRCCorner.x;\n          let xCCorner = xRCCorner.y;\n\n          let value = getX(batch, xRCorner, xCCorner, d);\n          setOutputAtIndex(index, value);\n        }\n      }\n    ")},e}();function pn(e){var t=e.inputs,n=e.backend,a=e.attrs;return qt(t.x,a.reductionIndices,a.keepDims,"max",n)}var fn={kernelName:t.Max,backendName:"webgpu",kernelFunc:pn};function mn(e){var t=e.inputs,n=e.backend,a=e.attrs,r=t.x,i=a.keepDims;return qt(r,a.axis,i,"mean",n)}var gn={kernelName:t.Mean,backendName:"webgpu",kernelFunc:mn};function vn(e,n,a,r){if(1===n.filterWidth&&1===n.filterHeight&&t.util.arraysEqual(n.inShape,n.outShape))return Ce({inputs:{x:e},backend:r});if(n.filterWidth===n.inWidth&&n.filterHeight===n.inHeight&&1===n.batchSize&&"VALID"===n.padInfo.type){var i=e.shape.length,o=xe({inputs:{x:e},backend:r,attrs:{shape:[e.shape[i-3]*e.shape[i-2],e.shape[i-1]]}}),s=void 0;"avg"===a?s=mn({inputs:{x:o},backend:r,attrs:{axis:0,keepDims:!1}}):(t.util.assert("max"===a,(function(){return"Invalid pool type ".concat(a)})),s=pn({inputs:{x:o},backend:r,attrs:{reductionIndices:0,keepDims:!1}}));var u=xe({inputs:{x:s},backend:r,attrs:{shape:n.outShape}});return r.disposeData(o.dataId),r.disposeData(s.dataId),u}var c,d=[{type:"int32",data:[n.strideHeight,n.strideWidth]}];return 1===n.filterHeight&&1===n.filterWidth?c=new hn(n):("avg"===a?c=new ln(n,"avg"):(t.util.assert("max"===a,(function(){return"Invalid pool type ".concat(a)})),c=new ln(n,"max")),d.push({type:"int32",data:[n.padInfo.top,n.padInfo.left]},{type:"int32",data:[n.dilationHeight,n.dilationWidth]},{type:"int32",data:[n.inHeight,n.inWidth]},{type:"int32",data:[n.effectiveFilterHeight,n.effectiveFilterWidth]})),r.runWebGPUProgram(c,[e],e.dtype,d)}var bn={kernelName:t.AvgPool,backendName:"webgpu",kernelFunc:function(e){var n=e.inputs,a=e.backend,r=e.attrs,i=n.x,o=r.filterSize,s=r.strides,u=r.pad,c=r.dimRoundingMode;return vn(i,t.backend_util.computePool2DInfo(i.shape,o,s,1,u,c),"avg",a)}},xn=function(){function e(e){this.variableNames=["dy"],this.uniforms="stride : vec2<i32>, pads : vec2<i32>, dilation : vec2<i32>, filterDims : vec2<i32>,\n       outHeight : i32, outWidth : i32, avgMultiplier : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=U(this.outputShape),this.dispatch=F(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="avg_pool2d_backprop"}return e.prototype.getUserCode=function(){return"\n      ".concat(k("index")," {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let batch = coords[0];\n        let d = coords[3];\n\n        let dyRCCorner = vec2<i32>(coords.yz) - uniforms.pads;\n        let dyRCorner = dyRCCorner.x;\n        let dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        var dotProd = 0.0;\n        for (var wR = 0; wR < uniforms.filterDims[0]; wR = wR + uniforms.dilation[0]) {\n          let dyR = f32(dyRCorner + wR) / f32(uniforms.stride[0]);\n\n          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {\n            continue;\n          }\n          let idyR = i32(dyR);\n\n          for (var wC = 0; wC < uniforms.filterDims[1]; wC = wC + uniforms.dilation[1]) {\n            let dyC = f32(dyCCorner + wC) / f32(uniforms.stride[1]);\n\n            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {\n              continue;\n            }\n            let idyC = i32(dyC);\n\n            let dyValue = getDy(batch, idyR, idyC, d);\n\n            dotProd = dotProd + dyValue * uniforms.avgMultiplier;\n          }\n        }\n        setOutputAtIndex(index, dotProd);\n      }\n    }\n    ")},e}();var yn={kernelName:t.AvgPoolGrad,backendName:"webgpu",kernelFunc:function(e){var n=e.inputs,a=e.backend,r=e.attrs,i=n.dy,o=n.input,s=o;W([i,o],"avgPoolGrad");var u=r.filterSize,c=r.strides,d=r.pad,l=t.backend_util.computePool2DInfo(s.shape,u,c,1,d),h=new xn(l),p=1/(l.filterHeight*l.filterWidth),f=[{type:"int32",data:[l.strideHeight,l.strideWidth]},{type:"int32",data:[l.effectiveFilterHeight-1-l.padInfo.top,l.effectiveFilterWidth-1-l.padInfo.left]},{type:"int32",data:[l.dilationHeight,l.dilationWidth]},{type:"int32",data:[l.effectiveFilterHeight,l.effectiveFilterWidth]},{type:"int32",data:[l.outHeight]},{type:"int32",data:[l.outWidth]},{type:"float32",data:[p]}];return a.runWebGPUProgram(h,[i],s.dtype,f)}};var wn={kernelName:t.BatchMatMul,backendName:"webgpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,a=e.attrs;return we({a:t.a,b:t.b,transposeA:a.transposeA,transposeB:a.transposeB,backend:n})}},kn=function(){function e(e,t){this.variableNames=["source"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.rank=t.length,this.dispatchLayout=U(this.outputShape),this.dispatch=F(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.start=e,this.uniforms="start : ".concat(y(e.length),", "),this.shaderKey="slice"}return e.prototype.getUserCode=function(){var e,t=y(this.rank),n=function(e){if(1===e)return"sourceLoc";if(e<=6)return Sn.slice(0,e).map((function(e){return"sourceLoc.".concat(e)})).join(",");throw Error("Slicing for rank ".concat(e," is not yet supported"))}(this.rank);return e=1===this.start.length?this.outputShape.map((function(e,t){return"sourceLoc = uniforms.start + coords;"})):this.outputShape.map((function(e,t){return"sourceLoc.".concat(Sn[t]," = uniforms.start.").concat(w(t)," + coords.").concat(Sn[t],";")})),"\n      ".concat(k("index")," {\n        if (index < uniforms.size) {\n          var sourceLoc : ").concat(t,";\n          let coords = getCoordsFromIndex(index);\n          ").concat(e.join("\n"),"\n          setOutputAtIndex(index, getSource(").concat(n,"));\n        }\n      }\n    ")},e}(),Sn=["x","y","z","w","u","v"];function In(e){var n=e.inputs,a=e.backend,r=e.attrs,i=n.x,o=r.begin,s=r.size,c=u(t.slice_util.parseSliceParams(i,o,s),2),d=c[0],l=c[1];if(t.slice_util.assertParamsValid(i,d,l),a.shouldExecuteOnCPU([i])||"string"===i.dtype){var h=a.tensorMap.get(i.dataId),p=At(h.values,d,l,i.shape,i.dtype);return a.makeTensorInfo(l,i.dtype,p)}if(0===t.util.sizeFromShape(l))return a.makeTensorInfo(l,i.dtype,[]);var f=new kn(d,l),m=[{type:"int32",data:d}];return a.runWebGPUProgram(f,[i],i.dtype,m)}var Cn={kernelName:t.Slice,backendName:"webgpu",kernelFunc:In},An={kernelName:t.BatchToSpaceND,backendName:"webgpu",kernelFunc:function(e){var n=e.inputs,a=e.backend,r=e.attrs,i=n.x,o=r.blockShape,s=r.crops;t.util.assert(i.shape.length<=4,(function(){return"batchToSpaceND for rank > 4 with a WebGPU backend not implemented yet"}));var u=o.reduce((function(e,t){return e*t})),c=t.backend_util.getReshaped(i.shape,o,u),d=t.backend_util.getPermuted(c.length,o.length),l=t.backend_util.getReshapedPermuted(i.shape,o,u),h=t.backend_util.getSliceBeginCoords(s,o.length),p=t.backend_util.getSliceSize(l,s,o.length),f=[],m=xe({inputs:{x:i},backend:a,attrs:{shape:c}}),g=Kt({inputs:{x:m},backend:a,attrs:{perm:d}}),v=xe({inputs:{x:g},backend:a,attrs:{shape:l}}),b=In({inputs:{x:v},backend:a,attrs:{begin:h,size:p}});return f.push(m),f.push(g),f.push(v),f.forEach((function(e){return a.disposeData(e.dataId)})),b}},Rn="\n  fn bincount_write(index: i32, value: f32) {\n    ".concat(b("&result[index]","value","float32"),"\n  }\n"),Nn=function(){function e(e,t,n){void 0===n&&(n=!1),this.outputShape=[],this.variableNames=["x"],this.uniforms="binCountSize : i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.hasWeights=!0,this.binaryOutput=!1,this.outputShape=e,this.rank=e.length,this.dispatchLayout=U(this.outputShape),this.dispatch=F(this.dispatchLayout,this.outputShape,this.workgroupSize),this.binaryOutput=n,n&&(this.atomic=!1),this.hasWeights=t,this.hasWeights&&this.variableNames.push("w"),this.shaderKey="bincount_".concat(this.hasWeights,"_").concat(this.binaryOutput,"_").concat(this.rank)}return e.prototype.getUserCode=function(){return"\n    ".concat(this.binaryOutput?"\n  fn bincount_write(index: i32, value: f32) {\n    atomicStore(&result[index], bitcast<i32>(value));\n  }\n":Rn,"\n  ").concat(k("index")," {\n    ").concat(1===this.rank?"if (index < uniforms.xShape) {\n      let indexVal = i32(getX(index));\n      if (indexVal < uniforms.binCountSize) {\n        let value = ".concat(this.binaryOutput?1:this.hasWeights?"getW(index)":"1.",";\n        bincount_write(indexVal, value);\n      }\n    }"):"let coord = getCoordsFromIndex(index);\n    if (coordsInBounds2D(coord, uniforms.xShape)) {\n      let indexVal = i32(getX(coord[0], coord[1]));\n      if (indexVal < uniforms.binCountSize) {\n        let value = ".concat(this.binaryOutput?1:this.hasWeights?"getW(coord[0], coord[1])":"1.",";\n        bincount_write(coord.x * uniforms.binCountSize + indexVal, value);\n      }\n    }"),"\n  }\n  ")},e}();var Pn={kernelName:t.Bincount,backendName:"webgpu",kernelFunc:function(e){var n=e.inputs,a=e.backend,r=e.attrs,i=n.x,o=n.weights,s=r.size,u=t.util.sizeFromShape(i.shape),c=t.util.sizeFromShape(o.shape)>0,d=[s],l=o.dtype,h=ve({backend:a,attrs:{shape:d,value:0,dtype:l}}),p=new Nn([u],c),f=[{type:"int32",data:[s]}],m=c?[i,o]:[i];return a.runWebGPUProgram(p,m,l,f,h)}},Tn=ze({opType:M.NOT_EQUAL,dtype:"bool",cpuKernelImpl:yt}),zn={kernelName:t.NotEqual,backendName:"webgpu",kernelFunc:Tn};function _n(e){var t=e.inputs,n=e.backend,a=t.input;return Ce({inputs:{x:n.tensorMap.get(a.dataId).complexTensorInfos.real},backend:n})}var Fn={kernelName:t.Real,backendName:"webgpu",kernelFunc:_n};var Bn={kernelName:t.Cast,backendName:"webgpu",kernelFunc:function e(n){var r=n.inputs,i=n.backend,o=n.attrs,s=r.x,c=o.dtype;if("complex64"===c){if("complex64"===s.dtype)return Ce({inputs:{x:s},backend:i});var d=a.zeros(s.shape),l=e({inputs:{x:s},backend:i,attrs:{dtype:"float32"}}),h=Re({inputs:{real:l,imag:d},backend:i});return d.dispose(),i.disposeData(l.dataId),h}if("complex64"===s.dtype){var p=_n({inputs:{input:s},backend:i}),h=e({inputs:{x:p},backend:i,attrs:{dtype:c}});return i.disposeData(p.dataId),h}if(!t.util.hasEncodingLoss(s.dtype,c))return{dataId:(h=Ce({inputs:{x:s},backend:i})).dataId,shape:h.shape,dtype:c};if(i.shouldExecuteOnCPU([s])){var f=i.tensorMap.get(s.dataId).values,m=u(tt(f,s.shape,s.dtype,c),3),g=m[0],v=m[1],b=m[2];return i.makeTensorInfo(g,v,b)}if("int32"===c)return function(e,t){var n=new Pe(e.shape,K.TO_INT),a=t.runWebGPUProgram(n,[e],"int32");return{dataId:a.dataId,shape:a.shape,dtype:a.dtype}}(s,i);if("bool"===c){var x=i.makeTensorInfo([],"bool",t.util.getTypedArrayFromDType("bool",1));h=Tn({inputs:{a:s,b:x},backend:i});return i.disposeData(x.dataId),h}throw new Error("Error in Cast: failed to cast ".concat(s.dtype," to ").concat(c))}},En=Te({opType:K.CEIL,cpuKernelImpl:nt}),Ln={kernelName:t.Ceil,backendName:"webgpu",kernelFunc:En},Un=function(){function e(e){this.variableNames=["A"],this.uniforms="minVal : f32, maxVal : f32,",this.workPerThread=4,this.workgroupSize=[64,1,1],this.isVec4=!0,this.size=!0,this.outputShape=e,this.dispatchLayout=U(this.outputShape),this.dispatch=F(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.shaderKey="clipVec4"}return e.prototype.getUserCode=function(){return"\n      ".concat(k("index")," {\n        if(index < uniforms.size) {\n          let value = getAByOutputIndex(index);\n          var clampedValue = clamp(\n              value, vec4<f32>(uniforms.minVal), vec4<f32>(uniforms.maxVal));\n          clampedValue = select(clampedValue, value, isnanVec4(value));\n          setOutputAtIndex(index, clampedValue);\n        }\n      }\n    ")},e}(),On=function(){function e(e){this.variableNames=["A"],this.uniforms="minVal : f32, maxVal : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=U(this.outputShape),this.dispatch=F(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="clip"}return e.prototype.getUserCode=function(){return"\n      ".concat(k("index")," {\n        if(index < uniforms.size) {\n          let value = getAByOutputIndex(index);\n          if (isnan(value)) {\n            setOutputAtIndex(index, value);\n            return;\n          }\n          setOutputAtIndex(index, clamp(value, uniforms.minVal, uniforms.maxVal));\n        }\n      }\n    ")},e}();var Dn={kernelName:t.ClipByValue,backendName:"webgpu",kernelFunc:function(e){var n,a=e.inputs,r=e.backend,i=e.attrs,o=a.x,s=[{type:"float32",data:[i.clipValueMin]},{type:"float32",data:[i.clipValueMax]}];return n=t.util.sizeFromShape(o.shape)%4==0?new Un(o.shape):new On(o.shape),r.runWebGPUProgram(n,[o],o.dtype,s)}},Wn=function(){function e(e){this.uniforms="",this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.backend_util.computeOutShape(e,1),this.variableNames=e.map((function(e,t){return"T".concat(t)})),this.dispatchLayout=U(this.outputShape),this.dispatch=F(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.offsetLength=e.length-1;for(var n=0;n<this.offsetLength;n++)this.uniforms+="offset".concat(n," : i32,");this.shaderKey="concat"}return e.prototype.getUserCode=function(){var e=[];if(this.offsetLength>0){e.push("if (yC < uniforms.offset0){ setOutputAtCoords(coords.x, coords.y, getT0(yR, yC)); }");for(var t=1;t<this.offsetLength;t++)e.push("else if (yC < uniforms.offset".concat([t],"){ ")+"setOutputAtCoords(coords.x, coords.y, getT".concat(t,"(yR, yC - uniforms.offset").concat(t-1,")); }"));var n=this.offsetLength,a=this.offsetLength-1;e.push("else { setOutputAtCoords(coords.x, coords.y, getT".concat(n,"(yR, yC - uniforms.offset").concat(a,")); }"))}else e.push("setOutputAtCoords(coords.x, coords.y, getT0(yR, yC));");return"\n      ".concat(k("index")," {\n        for(var i = 0; i < ").concat(this.workPerThread,"; i = i + 1) {\n          let flatIndex = index * ").concat(this.workPerThread," + i;\n          if(flatIndex < uniforms.size) {\n            let coords = getCoordsFromIndex(flatIndex);\n            let yR = coords.x;\n            let yC = coords.y;\n\n            ").concat(e.join("\n        "),"\n          }\n        }\n      }\n    ")},e}();function Mn(e){var t=e.inputs,n=e.backend,a=t.input;return Ce({inputs:{x:n.tensorMap.get(a.dataId).complexTensorInfos.imag},backend:n})}var Vn={kernelName:t.Imag,backendName:"webgpu",kernelFunc:Mn};function Gn(e,n,a){var r,i,o=e[0].dtype;if("complex64"===o){var u=e.map((function(e){return _n({inputs:{input:e},backend:a})})),c=e.map((function(e){return Mn({inputs:{input:e},backend:a})})),d=Gn(u,n,a),l=Gn(c,n,a),h=Re({inputs:{real:d,imag:l},backend:a});return u.forEach((function(e){return a.disposeData(e.dataId)})),c.forEach((function(e){return a.disposeData(e.dataId)})),a.disposeData(d.dataId),a.disposeData(l.dataId),h}var p=a.shouldExecuteOnCPU(e);if("string"===o&&(p=!0),p){var f=e.map((function(e){var r=t.util.sizeFromShape(e.shape.slice(n));return xe({inputs:{x:e},backend:a,attrs:{shape:[-1,r]}})})),m=f.map((function(e){return{vals:a.readSync(e.dataId),shape:e.shape}})),g=t.backend_util.computeOutShape(f.map((function(e){return e.shape})),1),v=1===f[0].shape[0],b=at(m,g,o,v),x=t.backend_util.computeOutShape(e.map((function(e){return e.shape})),n),y=a.makeTensorInfo(x,o,b);return f.forEach((function(e){return a.disposeData(e.dataId)})),y}var w=a.device.limits.maxStorageBuffersPerShaderStage-1;if(e.length>w){for(var k=[],S=0;S<e.length;S+=w){var I=e.slice(S,S+w);k.push(Gn(I,n,a))}h=Gn(k,n,a);try{for(var C=s(k),A=C.next();!A.done;A=C.next()){S=A.value;a.disposeData(S.dataId)}}catch(e){r={error:e}}finally{try{A&&!A.done&&(i=C.return)&&i.call(C)}finally{if(r)throw r.error}}return h}var R=function(e,n,a){var r=t.backend_util.computeOutShape(e.map((function(e){return e.shape})),n);return{tensors2D:e.map((function(e){return xe({inputs:{x:e},backend:a,attrs:{shape:[t.util.sizeFromShape(e.shape.slice(0,n)),t.util.sizeFromShape(e.shape.slice(n))]}})})),outShape:r}}(e,n,a),N=R.tensors2D,P=R.outShape,T=N.map((function(e){return e.shape})),z=new Wn(T),_=[],F=new Array(T.length-1);if(F.length>0){F[0]=T[0][1],_.push({type:"int32",data:[F[0]]});for(S=1;S<F.length;S++)F[S]=F[S-1]+T[S][1],_.push({type:"int32",data:[F[S]]})}var B=a.runWebGPUProgram(z,N,N[0].dtype,_);N.forEach((function(e){return a.disposeData(e.dataId)}));var E=xe({inputs:{x:B},backend:a,attrs:{shape:P}});return a.disposeData(B.dataId),E}function Hn(e){var n=e.inputs,a=e.backend,r=e.attrs.axis,i=t.util.parseAxisParam(r,n[0].shape)[0],o=n.map((function(e){return e.shape}));t.backend_util.assertParamsConsistent(o,i);var s=t.backend_util.computeOutShape(n.map((function(e){return e.shape})),i);if(0===t.util.sizeFromShape(s))return a.makeTensorInfo(s,n[0].dtype,[]);var u=n.filter((function(e){return t.util.sizeFromShape(e.shape)>0}));return 1===u.length?Ce({inputs:{x:u[0]},backend:a}):Gn(u,i,a)}var Kn={kernelName:t.Concat,backendName:"webgpu",kernelFunc:Hn};var Xn=function(){function e(e,t,n,a,r,i,o,s){void 0===r&&(r=!1),void 0===i&&(i=null),void 0===o&&(o=!1),void 0===s&&(s=!1),this.variableNames=["x","W"],this.uniforms="filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>, dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=e.outShape,this.isChannelsLast="channelsLast"===e.dataFormat,this.isVec4=((e.inChannels%4==0||e.inChannels%3==0)&&this.isChannelsLast||e.outWidth%4==0&&!this.isChannelsLast)&&e.outChannels%4==0,this.dispatchLayout=this.isChannelsLast?{x:[3],y:[1,2],z:[0]}:{x:[2,3],y:[1],z:[0]},this.workgroupSize=E(this.dispatchLayout,this.outputShape,this.isVec4),this.elementsPerThread=L(this.dispatchLayout,this.outputShape,this.isVec4),this.dispatch=F(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread),this.isVec4?(this.isChannelsLast&&e.inChannels%4!=0?(this.innerElementSize=3,this.variableTypes=["f32","vec4<f32>"]):(this.innerElementSize=4,this.variableTypes=["vec4<f32>","vec4<f32>"]),r&&(this.variableNames.push("bias"),this.variableTypes.push("vec4<f32>")),o&&(this.variableNames.push("preluActivationWeights"),this.variableTypes.push("vec4<f32>"))):(this.innerElementSize=this.elementsPerThread[0],r&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights")),this.sequentialAccessByThreads=s,this.addBias=r,this.activation=i,this.hasPreluActivationWeights=o,this.tileAOuter=this.workgroupSize[1]*this.elementsPerThread[1],this.tileBOuter=this.workgroupSize[0]*this.elementsPerThread[0],this.tileInner=Math.max(this.workgroupSize[0]*this.innerElementSize,this.workgroupSize[1]),this.fitAOuter=t%this.tileAOuter==0,this.fitBOuter=n%this.tileBOuter==0,this.fitInner=a%this.tileInner==0,this.shaderKey="conv2DMM_".concat(this.elementsPerThread,"_").concat(this.activation,"}_").concat(this.fitAOuter,"_").concat(this.fitBOuter,"_").concat(this.fitInner,"_").concat(this.isVec4,"_").concat(this.innerElementSize,"_").concat(this.isChannelsLast,"_").concat(this.sequentialAccessByThreads)}return e.prototype.getUserCode=function(){var e=this.isVec4?ue(this.elementsPerThread,this.workgroupSize,!this.isChannelsLast,this.tileInner):de(this.elementsPerThread,this.workgroupSize,!this.isChannelsLast,this.tileInner,!1,null,this.sequentialAccessByThreads),t=this.isVec4?[this.innerElementSize,4,4]:[1,1,1];return"\n    ".concat(function(e,t,n,a,r,i,o,s,u,c){void 0===r&&(r=!1),void 0===i&&(i=null),void 0===o&&(o=!1),void 0===s&&(s=4),void 0===u&&(u=4),void 0===c&&(c=4);var d=e?"\n      let coord = vec4<i32>(batch, xRow, xCol, xCh);\n      ":"\n      let coord = vec4<i32>(batch, xCh, xRow, xCol);\n      ",l=e?"\n      let coords = vec4<i32>(\n        batch,\n        row / outWidth,\n        row % outWidth,\n        col);\n      ":"\n      let coords = vec4<i32>(\n        batch,\n        row,\n        col / outWidth,\n        col % outWidth);\n      ",h=e?"uniforms.xShape[1]":"uniforms.xShape[2]",p=e?"uniforms.xShape[2]":"uniforms.xShape[3]",f=e?"row":"col",m=e?"col":"row",g="\n      let inChannels = uniforms.wShape[2];\n      let outWidth = ".concat(e?"uniforms.outShape[2]":"uniforms.outShape[3]",";\n      let outRow = ").concat(f," / outWidth;\n      let outCol = ").concat(f," % outWidth;\n\n      let WRow = ").concat(m," / (uniforms.filterDims[1] * inChannels);\n      let WCol = ").concat(m," / inChannels % uniforms.filterDims[1];\n      let xRow = outRow * uniforms.stride[0] + uniforms.dilation[0] * WRow - uniforms.pad[0];\n      let xCol = outCol * uniforms.stride[1] + uniforms.dilation[1] * WCol - uniforms.pad[1];\n      let xCh = ").concat(m," % inChannels;\n      var resData = ").concat(ae(s),"(0.0);\n      // The bounds checking is always needed since we use it to pad zero for\n      // the 'same' padding type.\n      if (xRow >= 0 && xRow < ").concat(h," && xCol >= 0 && xCol < ").concat(p,") {\n        ").concat(d,"\n        let xIndex = getIndexFromCoords4D(coord, uniforms.xShape);\n        ").concat(function(e){switch(e){case 1:return"resData = x[xIndex];";case 3:return"resData = vec3<f32>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);";case 4:return"resData = x[xIndex / 4];";default:throw new Error("innerElementSize ".concat(e," is not supported."))}}(s),"\n      }\n      return resData;"),v=e?t&&a?"\n      let col = colIn * ".concat(s,";\n      ").concat(g):"\n      let col = colIn * ".concat(s,";\n      if (row < uniforms.dimAOuter && col < uniforms.dimInner) {\n        ").concat(g,"\n      }\n      return ").concat(ae(s),"(0.0);"):a&&n?"\n      let col = colIn * ".concat(s,";\n      ").concat(g):"\n      let col = colIn * ".concat(s,";\n      if (row < uniforms.dimInner && col < uniforms.dimBOuter) {\n        ").concat(g,"\n      }\n      return ").concat(ae(s),"(0.0);"),b="".concat(function(e){switch(e){case 1:return"return W[row * uniforms.wShape[3] + colIn];";case 4:return"return W[row * uniforms.wShape[3] / 4 + colIn];";default:throw new Error("innerElementSize ".concat(e," is not supported."))}}(u)),x=ae(c),y=ae(e?s:u),w=ae(e?u:s);return"\n      ".concat(re(i,o,4===c,4),"\n      fn mm_readA(batch: i32, row : i32, colIn : i32) -> ").concat(y," {\n        ").concat(e?v:b,"\n      }\n\n      fn mm_readB(batch: i32, row : i32, colIn : i32) -> ").concat(w," {\n        ").concat(e?b:v,"\n      }\n\n      fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ").concat(x,") {\n        let col = colIn * ").concat(c,";\n        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)\n        {\n        var value = valueIn;\n        let outWidth = ").concat(e?"uniforms.outShape[2]":"uniforms.outShape[3]",";\n        ").concat(l,"\n        ").concat(ie(r,i),"\n        setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n        }\n      }")}(this.isChannelsLast,this.fitAOuter,this.fitBOuter,this.fitInner,this.addBias,this.activation,this.hasPreluActivationWeights,t[0],t[1],t[2]),"\n    ").concat(e,"\n  ")},e}(),jn=function(){function e(e,t,n,a){void 0===t&&(t=!1),void 0===n&&(n=null),void 0===a&&(a=!1),this.variableNames=["x","W"],this.uniforms="filterDims: vec2<i32>, pad: vec2<i32>, stride: vec2<i32>, dilation: vec2<i32>,",this.workgroupSize=[4,4,8],this.outputShape=e.outShape,this.isChannelsLast="channelsLast"===e.dataFormat,this.dispatchLayout=this.isChannelsLast?{x:[2],y:[1],z:[0,3]}:{x:[3],y:[2],z:[0,1]},this.dispatch=F(this.dispatchLayout,this.outputShape,this.workgroupSize),this.addBias=t,this.activation=n,this.hasPreluActivationWeights=a,t&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),this.shaderKey="conv2dnaive_".concat(this.activation,"_").concat(this.isChannelsLast)}return e.prototype.getUserCode=function(){return"\n       ".concat(re(this.activation,this.hasPreluActivationWeights,!1,4),"\n       fn readInp(batch : i32, row : i32, col : i32, chan : i32) -> f32{\n         let coords = vec4<i32>(batch, row, col, chan);\n         if (coordsInBounds4D(coords, uniforms.xShape)) {\n           return  getX(batch, row, col, chan);\n         } else {\n          return 0.0;\n         }\n       }\n       fn readFilt(row : i32, col : i32, xChannel : i32, outChannel : i32) -> f32{\n         let coords = vec4<i32>(row, col, xChannel, outChannel);\n         if(coordsInBounds4D(coords, uniforms.wShape)) {\n           return getW(row, col, xChannel, outChannel);\n          } else {\n            return 0.0;\n          }\n       }\n       fn writeResult(batch : i32, row : i32, col : i32, chan : i32, valueIn : f32) {\n         let coords = ").concat(this.isChannelsLast?"vec4<i32>(batch, row, col, chan);":"vec4<i32>(batch, chan, row, col);","\n         if (coordsInBounds4D(coords, uniforms.outShape)) {\n           var value = valueIn;\n           ").concat(ie(this.addBias,this.activation),"\n           setOutputAtCoords(coords.x, coords.y, coords.z, coords.w, value);\n         }\n       }\n       ").concat(k("index")," {\n         let coords = getOutputCoords();\n         let batch = coords[0];\n         let outChannel = ").concat(this.isChannelsLast?"coords[3];":"coords[1];","\n         let outRow = ").concat(this.isChannelsLast?"coords[1];":"coords[2];","\n         let outCol = ").concat(this.isChannelsLast?"coords[2];":"coords[3];","\n         var acc : f32 = 0.0;\n         for (var row = 0; row < uniforms.filterDims[0]; row = row + 1) {\n           for (var col = 0; col < uniforms.filterDims[1]; col = col + 1) {\n             let xRow = outRow * uniforms.stride[0] + uniforms.dilation[0] * row - uniforms.pad[0];\n             let xCol = outCol * uniforms.stride[1] + uniforms.dilation[1] * col - uniforms.pad[1];\n             for (var xChannel = 0; xChannel < ").concat(this.isChannelsLast?"uniforms.xShape[3];":"uniforms.xShape[1];"," xChannel = xChannel + 1) {\n               ").concat(this.isChannelsLast?"let v = readInp(batch, xRow, xCol, xChannel);":"let v = readInp(batch, xChannel, xRow, xCol);","\n               let f = readFilt(row, col, xChannel, outChannel);\n               acc = acc + v * f;\n             }\n           }\n         }\n         writeResult(batch, outRow, outCol, outChannel, acc);\n       }\n     ")},e}(),qn=function(){function e(e,t){this.variableNames=["x"],this.uniforms="pad : vec2<i32>, stride : vec2<i32>, dilation : vec2<i32>, outWidth : i32, itemsPerBlockRow : i32,\n       inChannels : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=U(this.outputShape),this.dispatch=F(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast=t,this.shaderKey="im2col_".concat(this.isChannelsLast)}return e.prototype.getUserCode=function(){var e=this.isChannelsLast?1:2,t=this.isChannelsLast?2:3,n=this.isChannelsLast?"coords[1]":"coords[2]",a=this.isChannelsLast?"coords[2]":"coords[1]",r=this.isChannelsLast?"getX(batch, xRow, xCol, ch)":"getX(batch, ch, xRow, xCol)";return"\n    ".concat(k("index")," {\n      let coords = getCoordsFromIndex(index);\n      if(index < uniforms.size) {\n        let batch = coords[0];\n        let row = ").concat(n,";\n        let col = ").concat(a,";\n        let offsetY = (row / uniforms.outWidth) * uniforms.stride[0] - uniforms.pad[0];\n        let xRow = offsetY + uniforms.dilation[0] * (col / uniforms.itemsPerBlockRow);\n        var value = 0.0;\n        if(xRow < uniforms.xShape[").concat(e,"] && xRow >= 0) {\n          let offsetX = (row % uniforms.outWidth) * uniforms.stride[1] -\n              uniforms.pad[1];\n          let xCol = offsetX + uniforms.dilation[1] * ((col %\n              uniforms.itemsPerBlockRow) / uniforms.inChannels);\n          let ch = col % uniforms.inChannels;\n          if(xCol < uniforms.xShape[").concat(t,"] && xCol >= 0) {\n            value = ").concat(r,";\n          }\n        }\n        setOutputAtIndex(index, value);\n      }\n    }\n   ")},e}();function Yn(e,t){var n=e.length;return n>=3?c(c([],u(e.slice(0,-3)),!1),t?[e[n-3]*e[n-2],e[n-1]]:[e[n-3],e[n-2]*e[n-1]],!1):!t&&1===n&&e[0]>1?[e[0],1]:null}function Qn(e){var n,a,r=e.x,i=e.filter,o=e.convInfo,d=e.backend,l=e.bias,h=void 0===l?null:l,p=e.preluActivationWeights,f=void 0===p?null:p,m=e.leakyreluAlpha,g=void 0===m?0:m,v=e.activation,b=void 0===v?null:v,x=null!=h,y=null!=f,w="channelsLast"===o.dataFormat,k=w&&o.filterHeight===o.inHeight&&o.filterWidth===o.inWidth&&"VALID"===o.padInfo.type,S=t.env().getBool("WEBGPU_USE_NAIVE_CONV2D_DEBUG");if(!S&&(k||1===o.filterHeight&&1===o.filterWidth&&1===o.dilationHeight&&1===o.dilationWidth&&1===o.strideHeight&&1===o.strideWidth&&("SAME"===o.padInfo.type||"VALID"===o.padInfo.type)))return function(e){var t,n,a,r,i,o=e.x,u=e.filter,c=e.convInfo,d=e.backend,l=e.bias,h=void 0===l?null:l,p=e.preluActivationWeights,f=void 0===p?null:p,m=e.leakyreluAlpha,g=void 0===m?0:m,v=e.activation,b=void 0===v?null:v,x="channelsLast"===c.dataFormat,y=!x,w=[];if(x&&c.filterHeight===c.inHeight&&c.filterWidth===c.inWidth&&"VALID"===c.padInfo.type){var k=c.inHeight*c.inWidth*c.inChannels;a=xe({inputs:{x:o},backend:d,attrs:{shape:[1,c.batchSize,k]}}),r=xe({inputs:{x:u},backend:d,attrs:{shape:[1,k,c.outChannels]}})}else a=xe({inputs:{x:o},backend:d,attrs:{shape:x?[c.batchSize,c.inHeight*c.inWidth,c.inChannels]:[c.batchSize,c.inChannels,c.inHeight*c.inWidth]}}),r=xe({inputs:{x:u},backend:d,attrs:{shape:[1,c.inChannels,c.outChannels]}});w.push(a),w.push(r),null!=f&&null!=(i=Yn(f.shape,x))&&(f=xe({inputs:{x:f},backend:d,attrs:{shape:i}}),w.push(f)),null!=h&&null!=(i=Yn(h.shape,x))&&(h=xe({inputs:{x:h},backend:d,attrs:{shape:i}}),w.push(h));var S=we({a:x?a:r,b:x?r:a,transposeA:y,transposeB:!1,backend:d,bias:h,activation:b,preluActivationWeights:f,leakyreluAlpha:g}),I=xe({inputs:{x:S},backend:d,attrs:{shape:c.outShape}});w.push(S);try{for(var C=s(w),A=C.next();!A.done;A=C.next()){var R=A.value;d.disposeData(R.dataId)}}catch(e){t={error:e}}finally{try{A&&!A.done&&(n=C.return)&&n.call(C)}finally{if(t)throw t.error}}return I}({x:r,filter:i,convInfo:o,backend:d,bias:h,activation:b,preluActivationWeights:f,leakyreluAlpha:g});var I,C=t.env().getNumber("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL"),A=C>0?C:d.thresholdToIncreaseWorkgroups,R=o.batchSize*Math.ceil(o.outHeight*o.outWidth/32)*Math.ceil(o.outChannels/32);if(t.env().getBool("WEBGPU_CONV_SEPARATE_IM2COL_SHADER")||R<=A)return function(e){var t,n,a=e.x,r=e.filter,i=e.convInfo,o=e.backend,u=e.bias,c=void 0===u?null:u,d=e.preluActivationWeights,l=void 0===d?null:d,h=e.leakyreluAlpha,p=void 0===h?0:h,f=e.activation,m=void 0===f?null:f,g=i.filterWidth,v=i.filterHeight,b=i.inChannels,x=i.strideWidth,y=i.strideHeight,w=i.padInfo,k=i.outWidth,S=i.outHeight,I=i.dilationWidth,C=i.dilationHeight,A="channelsLast"===i.dataFormat,R=g*v*b,N=S*k,P=A?[i.batchSize,N,R]:[i.batchSize,R,N],T=new qn(P,A),z=[{type:"int32",data:[w.top,w.left]},{type:"int32",data:[y,x]},{type:"int32",data:[C,I]},{type:"int32",data:[k]},{type:"int32",data:[b*g]},{type:"int32",data:[b]}],_=o.runWebGPUProgram(T,[a],a.dtype,z),F=[];F.push(_);var B,E=xe({inputs:{x:r},backend:o,attrs:{shape:[1,R,-1]}});F.push(E),null!=l&&null!=(B=Yn(l.shape,A))&&(l=xe({inputs:{x:l},backend:o,attrs:{shape:B}}),F.push(l)),null!=c&&null!=(B=Yn(c.shape,A))&&(c=xe({inputs:{x:c},backend:o,attrs:{shape:B}}),F.push(c));var L=we({a:A?_:E,b:A?E:_,transposeA:!A,transposeB:!1,backend:o,bias:c,activation:m,preluActivationWeights:l,leakyreluAlpha:p}),U=xe({inputs:{x:L},backend:o,attrs:{shape:i.outShape}});F.push(L);try{for(var O=s(F),D=O.next();!D.done;D=O.next()){var W=D.value;o.disposeData(W.dataId)}}catch(e){t={error:e}}finally{try{D&&!D.done&&(n=O.return)&&n.call(O)}finally{if(t)throw t.error}}return U}({x:r,filter:i,convInfo:o,backend:d,bias:h,preluActivationWeights:f,leakyreluAlpha:g,activation:b});var N=[o.padInfo.top,o.padInfo.left],P=[{type:"int32",data:[o.filterHeight,o.filterWidth]},{type:"int32",data:c([],u(N),!1)},{type:"int32",data:[o.strideHeight,o.strideWidth]},{type:"int32",data:[o.dilationHeight,o.dilationWidth]}];if(S)I=new jn(o,x,b,y);else{var T=w?o.outHeight*o.outWidth:o.outChannels,z=w?o.outChannels:o.outHeight*o.outWidth,_=o.filterHeight*o.filterWidth*o.inChannels;P.push({type:"int32",data:[T]},{type:"int32",data:[z]},{type:"int32",data:[_]});var F=d.adapterInfo.isIntel();I=new Xn(o,T,z,_,x,b,y,F)}var B=[],E=[r,i];x&&(w||1!==h.shape.length||(h=xe({inputs:{x:h},backend:d,attrs:{shape:[h.shape[0],1,1]}}),B.push(h)),E.push(h)),y&&(w||1!==f.shape.length||(f=xe({inputs:{x:f},backend:d,attrs:{shape:[f.shape[0],1,1]}}),B.push(f)),E.push(f)),"leakyrelu"===b&&(P.push({type:"float32",data:[g]}),I.uniforms+=" alpha : f32,");var L=d.runWebGPUProgram(I,E,r.dtype,P);try{for(var U=s(B),O=U.next();!O.done;O=U.next()){var D=O.value;d.disposeData(D.dataId)}}catch(e){n={error:e}}finally{try{O&&!O.done&&(a=U.return)&&a.call(U)}finally{if(n)throw n.error}}return L}var Zn={kernelName:t.Conv2D,backendName:"webgpu",kernelFunc:function(e){var n=e.inputs,a=e.attrs,r=e.backend,i=n.x,o=n.filter,s=a.strides,u=a.pad,c=a.dataFormat,d=a.dilations,l=a.dimRoundingMode,h=t.backend_util.convertConv2DDataFormat(c);return Qn({x:i,filter:o,convInfo:t.backend_util.computeConv2DInfo(i.shape,o.shape,s,d,u,l,!1,h),backend:r})}},Jn=function(){function e(e){this.variableNames=["dy","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, stride : vec2<i32>, outBackprop : vec4<i32>,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=U(this.outputShape),this.dispatch=F(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast="channelsLast"===e.dataFormat,this.shaderKey="conv2DDerInput_".concat(this.isChannelsLast)}return e.prototype.getUserCode=function(){var e=this.isChannelsLast?1:2,t=this.isChannelsLast?2:3,n=this.isChannelsLast?3:1;return"\n    ".concat(k("index")," {\n      if(index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let batch = coords[0];\n        let d1 = coords[").concat(n,"];\n\n        let dyCorner = vec2<i32>(coords[").concat(e,"], coords[").concat(t,"]) - uniforms.pads;\n        let dyRCorner = dyCorner.x;\n        let dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        var dotProd = 0.0;\n        for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + 1) {\n          let dyR = (f32(dyRCorner) + f32(wR)) / f32(uniforms.stride.x);\n          let wRPerm = uniforms.filterDims.x - 1 - wR;\n          if (dyR < 0.0 || dyR >= f32(uniforms.outBackprop[1]) || fract(dyR) > 0.0 ||\n              wRPerm < 0) {\n            continue;\n          }\n          let idyR = i32(dyR);\n\n          for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + 1) {\n            let dyC = (f32(dyCCorner) + f32(wC)) / f32(uniforms.stride.y);\n            let wCPerm = uniforms.filterDims.y - 1 - wC;\n            if (dyC < 0.0 || dyC >= f32(uniforms.outBackprop[2]) ||\n                fract(dyC) > 0.0 || wCPerm < 0) {\n              continue;\n            }\n            let idyC = i32(dyC);\n\n            for (var d2 = 0; d2 < uniforms.outBackprop[3]; d2 = d2 + 1) {\n              if (").concat(this.isChannelsLast,") {\n                let xValue = getDy(batch, idyR, idyC, d2);\n                let wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd = dotProd + xValue * wValue;\n              } else {\n                let xValue = getDy(batch, d2, idyR, idyC);\n                let wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd = dotProd + xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutputAtIndex(index, dotProd);\n      }\n    }\n  ")},e}(),$n=function(){function e(e){this.variableNames=["x","dy"],this.uniforms="pad : vec2<i32>, stride : vec2<i32>, batchSize : i32, outHeight : i32, outWidth : i32, inHeight : i32, inWidth : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.filterShape,this.dispatchLayout=U(this.outputShape),this.dispatch=F(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast="channelsLast"===e.dataFormat,this.shaderKey="conv2DDerFilter_".concat(this.isChannelsLast)}return e.prototype.getUserCode=function(){return"\n    ".concat(k("index")," {\n      if(index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let wR = coords[0];\n        let wC = coords[1];\n        let d1 = coords[2];\n        let d2 = coords[3];\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        var dotProd = 0.0;\n        for (var b = 0; b < uniforms.batchSize; b = b + 1) {\n          for (var yR = 0; yR < uniforms.outHeight; yR = yR + 1) {\n            let xR = wR + yR * uniforms.stride[0] - uniforms.pad[0];\n            if (xR < 0 || xR >= uniforms.inHeight) {\n              continue;\n            }\n\n            for (var yC = 0; yC < uniforms.outWidth; yC = yC + 1) {\n              let xC = wC + yC * uniforms.stride[1] - uniforms.pad[1];\n\n              if (xC < 0 || xC >= uniforms.inWidth) {\n                continue;\n              }\n\n              if (").concat(this.isChannelsLast,") {\n                let dyValue = getDy(b, yR, yC, d2);\n                let xValue = getX(b, xR, xC, d1);\n                dotProd = dotProd + xValue * dyValue;\n              } else {\n                let dyValue = getDy(b, d2, yR, yC);\n                let xValue = getX(b, d1, xR, xC);\n                dotProd = dotProd + xValue * dyValue;\n              }\n            }\n          }\n        }\n        setOutputAtIndex(index, dotProd);\n      }\n    }\n  ")},e}();var ea={kernelName:t.Conv2DBackpropFilter,backendName:"webgpu",kernelFunc:function(e){var n=e.inputs,a=e.backend,r=e.attrs,i=n.x,o=n.dy,s=r.strides,u=r.pad,c=r.dataFormat,d=r.dimRoundingMode,l=r.filterShape,h=t.backend_util.convertConv2DDataFormat(c),p=t.backend_util.computeConv2DInfo(i.shape,l,s,1,u,d,!1,h),f=new $n(p),m=[{type:"int32",data:[p.padInfo.top,p.padInfo.left]},{type:"int32",data:[p.strideHeight,p.strideWidth]},{type:"int32",data:[p.batchSize]},{type:"int32",data:[p.outHeight]},{type:"int32",data:[p.outWidth]},{type:"int32",data:[p.inHeight]},{type:"int32",data:[p.inWidth]}];return a.runWebGPUProgram(f,[i,o],i.dtype,m)}};var ta=function(){function e(e){this.variableNames=["x","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, stride : vec2<i32>, outBackprop : vec4<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=e.inShape,t.util.assert("channelsLast"===e.dataFormat,(function(){return"TODO: NCHW is unimplemented"})),this.isVec4=e.inChannels%4==0&&e.outChannels%4==0,this.dispatchLayout={x:[3],y:[1,2],z:[0]},this.workgroupSize=E(this.dispatchLayout,this.outputShape,this.isVec4),this.elementsPerThread=L(this.dispatchLayout,this.outputShape,this.isVec4),this.dispatch=F(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread),this.isVec4&&(this.variableTypes=["vec4<f32>","f32"]),this.shaderKey="conv2DDerInputMM_".concat(this.isVec4,"_").concat(this.elementsPerThread)}return e.prototype.getUserCode=function(){var e=this.isVec4?ue(this.elementsPerThread,this.workgroupSize):de(this.elementsPerThread,this.workgroupSize);return"\n    ".concat(function(e){void 0===e&&(e=4);var t="\n      let outRow = row / uniforms.outShape[2];\n      let outCol = row % uniforms.outShape[2];\n\n      let WRow = col / (uniforms.filterDims[1] * uniforms.outBackprop[3]);\n      let WCol = col / uniforms.outBackprop[3] % uniforms.filterDims[1];\n      let xR = f32(outRow - uniforms.pads[0] + WRow) / f32(uniforms.stride[0]);\n      let xC = f32(outCol - uniforms.pads[1] + WCol) / f32(uniforms.stride[1]);\n      if (xR < 0.0 || xR >= f32(uniforms.outBackprop[1]) || fract(xR) > 0.0) {\n        return ".concat(ae(e),"(0.0);\n      }\n      if (xC < 0.0 || xC >= f32(uniforms.outBackprop[2]) || fract(xC) > 0.0) {\n        return ").concat(ae(e),"(0.0);\n      }\n      let coord = vec4<i32>(\n          batch,\n          i32(xR),\n          i32(xC),\n          col % uniforms.outBackprop[3]);\n      return x[getIndexFromCoords4D(coord, uniforms.xShape)/").concat(e,"];"),n="if (row < uniforms.dimAOuter && col < uniforms.dimInner) {\n        ".concat(t,"\n      }\n      return ").concat(ae(e),"(0.0);");return"\n  fn mm_readA(batch: i32, row : i32, colIn : i32) -> ".concat(ae(e)," {\n    let col = colIn * ").concat(e,";\n    ").concat(n,"\n  }\n\n  fn mm_readB(batch: i32, row : i32, colIn : i32) -> ").concat(ae(e)," {\n    let col = colIn * ").concat(e,";\n    let coordX = uniforms.filterDims.x - 1 -\n        row / (uniforms.filterDims[1] * uniforms.outBackprop[3]);\n    let coordY = uniforms.filterDims.y - 1 -\n        (row / uniforms.outBackprop[3]) % uniforms.filterDims[1];\n    if (row < uniforms.dimInner && col < uniforms.dimBOuter &&\n        coordX >= 0 && coordY >= 0) {\n      let rowInner = row % uniforms.outBackprop[3];\n      let coord = vec4<i32>(coordX, coordY, col, rowInner);\n      ").concat(function(e){switch(e){case 1:return"return W[getIndexFromCoords4D(coord, uniforms.wShape)];";case 4:return"\n            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);\n            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);\n            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);\n            let v0 = W[getIndexFromCoords4D(coord, uniforms.wShape)];\n            let v1 = W[getIndexFromCoords4D(coord1, uniforms.wShape)];\n            let v2 = W[getIndexFromCoords4D(coord2, uniforms.wShape)];\n            let v3 = W[getIndexFromCoords4D(coord3, uniforms.wShape)];\n            return vec4<f32>(v0, v1, v2, v3);\n            ";default:throw new Error("innerElementSize ".concat(e," is not supported."))}}(e),"\n    }\n    return ").concat(ae(e),"(0.0);\n  }\n\n  fn mm_write(batch: i32, row : i32, colIn : i32, valueInput : ").concat(ae(e),") {\n    let col = colIn * ").concat(e,";\n    if (row < uniforms.dimAOuter && (col + ").concat(e-1,") < uniforms.dimBOuter) {\n      var value = valueInput;\n      let outCoord = vec4<i32>(\n          batch,\n          row / uniforms.outShape[2],\n          row % uniforms.outShape[2],\n          col);\n      result[getIndexFromCoords4D(outCoord, uniforms.outShape)/").concat(e,"] = value;\n    }\n  }")}(this.isVec4?4:1),"\n    ").concat(e,"\n    ")},e}();var na,aa={kernelName:t.Conv2DBackpropInput,backendName:"webgpu",kernelFunc:function(e){var n,a=e.inputs,r=e.backend,i=e.attrs,o=a.dy,s=a.filter,u=i.inputShape,c=i.strides,d=i.pad,l=i.dataFormat,h=i.dimRoundingMode,p=t.backend_util.convertConv2DDataFormat(l),f=t.backend_util.computeConv2DInfo(u,s.shape,c,1,d,h,!1,p),m=[{type:"int32",data:[f.filterHeight,f.filterWidth]},{type:"int32",data:[f.filterHeight-1-f.padInfo.top,f.filterWidth-1-f.padInfo.left]},{type:"int32",data:[f.strideHeight,f.strideWidth]},{type:"int32",data:[f.batchSize,f.outHeight,f.outWidth,f.outChannels]}];if(t.env().getBool("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE")||f.filterHeight<=2&&f.filterWidth<=2&&f.outChannels<=16&&1===f.inChannels)n=new Jn(f);else{n=new ta(f);var g=f.inHeight*f.inWidth,v=f.inChannels,b=f.filterHeight*f.filterWidth*f.outChannels;m.push({type:"uint32",data:[g]},{type:"uint32",data:[v]},{type:"uint32",data:[b]})}return r.runWebGPUProgram(n,[o,s],"float32",m)}},ra=Te({opType:K.COS}),ia={kernelName:t.Cos,backendName:"webgpu",kernelFunc:ra},oa=Te({opType:K.COSH}),sa={kernelName:t.Cosh,backendName:"webgpu",kernelFunc:oa},ua=function(){function e(e,t,n,a){this.variableNames=["Image","Boxes","BoxInd"],this.uniforms="extrapolationValue : f32,",this.workgroupSize=[64,1,1],this.size=!0;var r=u(t,1)[0];this.outputShape=[r,n[0],n[1],e],this.dispatchLayout=U(this.outputShape),this.dispatch=F(this.dispatchLayout,this.outputShape,this.workgroupSize),this.methodId="bilinear"===a?1:0,this.cropHeightBiggerThan1=this.outputShape[1]>1,this.cropWidthBiggerThan1=this.outputShape[2]>1,this.shaderKey="cropAndResize_".concat(this.methodId,"_").concat(this.cropHeightBiggerThan1,"_").concat(this.cropWidthBiggerThan1)}return e.prototype.getUserCode=function(){var e=u(["f32(uniforms.imageShape[1] - 1)","f32(uniforms.imageShape[2] - 1)"],2),t=e[0],n=e[1],a=u(this.cropHeightBiggerThan1?["(".concat(t," / f32(uniforms.outShape[1] - 1))"),"(y2-y1) * height_ratio","y1*".concat(t," + f32(y)*(height_scale)")]:["0.0","0.0","0.5 * (y1+y2) * ".concat(t)],3),r=a[0],i=a[1],o=a[2],s=u(this.cropWidthBiggerThan1?["(".concat(n," / f32(uniforms.outShape[2] - 1))"),"(x2-x1) * width_ratio","x1*".concat(n," + f32(x)*(width_scale)")]:["0.0","0.0","0.5 * (x1+x2) * ".concat(n)],3),c=s[0],d=s[1],l=s[2];return"\n    ".concat(k("index")," {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let height_ratio = f32(").concat(r,");\n        let width_ratio = f32(").concat(c,");\n        let b = coords[0];\n        let y = coords[1];\n        let x = coords[2];\n        let d = coords[3];\n        // get box vals\n        let y1 = getBoxes(b, 0);\n        let x1 = getBoxes(b, 1);\n        let y2 = getBoxes(b, 2);\n        let x2 = getBoxes(b, 3);\n        // get image in batch index\n        let bInd = i32(round(getBoxInd(b)));\n        if(bInd < 0 || bInd >= uniforms.outShape[0]) {\n          return;\n        }\n        let height_scale = ").concat(i,";\n        let width_scale = ").concat(d,";\n        let in_y = ").concat(o,";\n        if( in_y < 0.0 || in_y > ").concat(t," ) {\n          setOutputAtIndex(index, uniforms.extrapolationValue);\n          return;\n        }\n        let in_x = ").concat(l,";\n        if( in_x < 0.0 || in_x > ").concat(n," ) {\n          setOutputAtIndex(index, uniforms.extrapolationValue);\n          return;\n        }\n        let sourceFracIndexCR = vec2<f32>(in_x,in_y);\n        if(").concat(this.methodId," == 1) {\n          // Compute the four integer indices.\n          let sourceFloorCR = vec2<i32>(sourceFracIndexCR);\n          let sourceCeilCR = vec2<i32>(ceil(sourceFracIndexCR));\n          let topLeft = getImage(bInd, sourceFloorCR.y, sourceFloorCR.x, d);\n          let bottomLeft = getImage(bInd, sourceCeilCR.y, sourceFloorCR.x, d);\n          let topRight = getImage(bInd, sourceFloorCR.y, sourceCeilCR.x, d);\n          let bottomRight = getImage(bInd, sourceCeilCR.y, sourceCeilCR.x, d);\n          let fracCR = sourceFracIndexCR - vec2<f32>(sourceFloorCR);\n          let top = topLeft + (topRight - topLeft) * fracCR.x;\n          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          let newValue = top + (bottom - top) * fracCR.y;\n          setOutputAtIndex(index, newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          let sourceNearestCR = vec2<i32>(floor(\n            sourceFracIndexCR + vec2<f32>(0.5,0.5)));\n          let newValue = getImage(\n            bInd, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutputAtIndex(index, newValue);\n        }\n      }\n    }\n    ")},e}(),ca={kernelName:t.CropAndResize,backendName:"webgpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,a=e.attrs,r=t.image,i=t.boxes,o=t.boxInd,s=a.cropSize,u=a.method,c=a.extrapolationValue,d=new ua(r.shape[3],i.shape,s,u),l=[{type:"float32",data:[c]}];return n.runWebGPUProgram(d,[r,i,o],"float32",l)}};!function(e){e.Prod="*",e.Sum="+"}(na||(na={}));var da=function(){function e(e,t,n,a){this.variableNames=["x"],this.uniforms="index : f32,",this.size=!0,this.workgroupSize=[128,1,1],this.outputShape=t,this.dispatchLayout=U(this.outputShape),this.dispatch=F(this.dispatchLayout,this.outputShape,this.workgroupSize),this.exclusive=n,this.reverse=a,this.op=e,this.shaderKey="cum_".concat(this.op,"_").concat(this.exclusive,"_").concat(this.reverse)}return e.prototype.getUserCode=function(){var e=this.outputShape.length,t=this.op===na.Prod?"1.0":"0.0",n=this.exclusive?t:"getX(".concat(la(e,"coords",this.op),")"),a=this.outputShape[this.outputShape.length-1],r="",i="";return this.exclusive?(r=this.reverse?"end != ".concat(a-1):"end != 0",i=this.reverse?"end + 1":"end - 1"):(r=this.reverse?"end + pow2 < ".concat(a):"end >= pow2",i=this.reverse?"end + pow2":"end - pow2"),"\n      ".concat(k("index")," {\n       if (index < uniforms.size) {\n         var coords = getCoordsFromIndex(index);\n\n         let end = ").concat(ha(e,"coords",this.op),";\n         var val = ").concat(n,";\n         let pow2 = i32(pow(2.0, uniforms.index));\n         if (").concat(r,") {\n           let idx = ").concat(i,";\n           ").concat(ha(e,"coords",this.op)," = idx;\n           val ").concat(this.op,"= getX(").concat(la(e,"coords",this.op),");\n         }\n         setOutputAtIndex(index, val);\n       }\n      }\n    ")},e}();function la(e,t,n){if(1===e)return"".concat(t);if(2===e)return"".concat(t,".x, ").concat(t,".y");if(3===e)return"".concat(t,".x, ").concat(t,".y, ").concat(t,".z");if(4===e)return"".concat(t,".x, ").concat(t,".y, ").concat(t,".z, ").concat(t,".w");throw Error("Cumulative ".concat(n," for rank ").concat(e," is not yet supported"))}function ha(e,t,n){if(1===e)return"".concat(t);if(2===e)return"".concat(t,".y");if(3===e)return"".concat(t,".z");if(4===e)return"".concat(t,".w");throw Error("Cumulative ".concat(n," for rank ").concat(e," is not yet supported"))}function pa(e,n,a,r,i,o){var s=n.shape.length,u=t.backend_util.getAxesPermutation([r],s),c=n;null!=u&&(c=Kt({inputs:{x:n},backend:a,attrs:{perm:u}}));var d=t.backend_util.getInnerMostAxes(1,s)[0];if(d!==s-1)throw new Error("WebGPU cumprod shader expects an inner-most axis=".concat(n.shape.length-1," ")+"but got axis=".concat(r));for(var l=c.shape[d],h=Ce({inputs:{x:c},backend:a}),p=0;p<=Math.ceil(Math.log2(l))-1;p++){var f=new da(e,c.shape,!1,o),m=h,g=[{type:"float32",data:[p]}];h=a.runWebGPUProgram(f,[h],h.dtype,g),a.disposeData(m.dataId)}if(i){f=new da(e,c.shape,i,o),m=h,g=[{type:"float32",data:[0]}];h=a.runWebGPUProgram(f,[h],h.dtype,g),a.disposeData(m.dataId)}if(null!=u){var v=Kt({inputs:{x:h},backend:a,attrs:{perm:t.backend_util.getUndoAxesPermutation(u)}});return a.disposeData(h.dataId),a.disposeData(c.dataId),v}return h}var fa={kernelName:t.Cumprod,backendName:"webgpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,a=e.attrs,r=t.x,i=a.axis,o=a.exclusive,s=a.reverse;return pa(na.Prod,r,n,i,o,s)}};var ma={kernelName:t.Cumsum,backendName:"webgpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,a=e.attrs,r=t.x,i=a.axis,o=a.exclusive,s=a.reverse;return pa(na.Sum,r,n,i,o,s)}};var ga={kernelName:t.DenseBincount,backendName:"webgpu",kernelFunc:function(e){var n=e.inputs,a=e.backend,r=e.attrs,i=n.x,o=n.weights,s=r.size,u=r.binaryOutput,c=1===i.shape.length,d=t.util.sizeFromShape(o.shape)>0,l=o.dtype,h=c?[i.shape[0]]:[i.shape[0],i.shape[1]],p=ve({backend:a,attrs:{shape:c?[s]:[i.shape[0],s],value:0,dtype:l}}),f=new Nn(h,d,u),m=[{type:"int32",data:[s]}],g=d?[i,o]:[i];return a.runWebGPUProgram(f,g,l,m,p)}},va=function(){function e(e,t){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.uniforms="blockSize : i32,",this.outputShape=e,this.dispatchLayout=U(this.outputShape),this.dispatch=F(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="depthToSpace_".concat(t),this.dataFormat=t}return e.prototype.getUserCode=function(){return"\n      ".concat(k("index")," {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let b = coords[0];\n          let h = ").concat(this.getHeightCoordString(),";\n          let w = ").concat(this.getWidthCoordString(),";\n          let d = ").concat(this.getDepthCoordString(),";\n\n          let in_h = h / uniforms.blockSize;\n          let offset_h = h % uniforms.blockSize;\n          let in_w = w / uniforms.blockSize;\n          let offset_w = w % uniforms.blockSize;\n          let offset_d = (offset_h * uniforms.blockSize + offset_w) *\n            ").concat(this.getOutputDepthSize(),";\n          let in_d = d + offset_d;\n\n          let rlt = ").concat(this.getInputSamplingString(),";\n          setOutputAtIndex(index, rlt);\n        }\n      }")},e.prototype.getHeightCoordString=function(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"},e.prototype.getWidthCoordString=function(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"},e.prototype.getDepthCoordString=function(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"},e.prototype.getOutputDepthSize=function(){return"NHWC"===this.dataFormat?"uniforms.outShape[3]":"uniforms.outShape[1]"},e.prototype.getInputSamplingString=function(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"},e}();var ba={kernelName:t.DepthToSpace,backendName:"webgpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,a=e.attrs,r=t.x,i=a.blockSize,o=a.dataFormat,s=r.shape[0],u=("NHWC"===o?r.shape[1]:r.shape[2])*i,c=("NHWC"===o?r.shape[2]:r.shape[3])*i,d=("NHWC"===o?r.shape[3]:r.shape[1])/(i*i),l=[{type:"int32",data:[i]}],h=new va("NHWC"===o?[s,u,c,d]:[s,d,u,c],o);return n.runWebGPUProgram(h,[r],r.dtype,l)}},xa=function(){function e(e,t,n,a,r,i){void 0===a&&(a=!1),void 0===r&&(r=null),void 0===i&&(i=!1),this.variableNames=["x","W"],this.uniforms="pad : vec2<i32>, inDims : vec2<i32>,",this.workgroupSize=[16,16,1],this.outputShape=e,this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=F(this.dispatchLayout,this.outputShape,this.workgroupSize),a&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),this.addBias=a,this.activation=r,this.hasPreluActivation=i,this.filterHeight=t,this.filterWidth=n,this.shaderKey="depthwiseNCHW_".concat(this.activation,"_").concat(this.filterHeight,"_").concat(this.filterWidth)}return e.prototype.getUserCode=function(){var e=this.filterWidth*this.filterHeight,t=this.workgroupSize[0]*this.workgroupSize[1]*this.workgroupSize[2],n=this.workgroupSize[1]+this.filterHeight-1,a=this.workgroupSize[0]+this.filterWidth-1;return"\n      ".concat(re(this.activation,this.hasPreluActivation,!1,4),"\n\n      var<workgroup> mm_Asub : array<array<f32, ").concat(a,">, ").concat(n,">;\n      var<workgroup> mm_Bsub : array<array<f32, ").concat(this.filterWidth,">, ").concat(this.filterHeight,">;\n      fn readX(batch : i32, channel : i32, row : i32, col : i32) -> f32 {\n        var value = 0.0;\n        if (row >=0 && row < uniforms.inDims[0] && col >=0 && col < uniforms.inDims[1])\n        {\n          value = getX(batch, channel, row, col);\n        }\n        return value;\n      }\n\n      ").concat(k()," {\n        let coords = getOutputCoords();\n        let batch = coords[0];\n        let xRCCorner = vec2<i32>(coords.zw) - uniforms.pad;\n        let channelMul = uniforms.wShape[3];\n        let d1 = coords[1] / channelMul;\n        let q = coords[1] % channelMul;\n\n        let inputRowStart = xRCCorner.x;\n        let inputColStart = xRCCorner.y;\n\n        let localRow = i32(localId.y);\n        let localCol = i32(localId.x);\n\n        // Load one tile of X into local memory.\n        for (var inputRow = localRow; inputRow < ").concat(n,"; inputRow = inputRow + ").concat(this.workgroupSize[1],") {\n          for (var inputCol = localCol; inputCol < ").concat(a,"; inputCol = inputCol + ").concat(this.workgroupSize[0],") {\n            let rowOffset = inputRow - localRow;\n            let colOffset = inputCol - localCol;\n            mm_Asub[inputRow][inputCol] = readX(batch, d1, inputRowStart + rowOffset, inputColStart + colOffset);\n          }\n        }\n\n        // Load one tile of W into local memory.\n        var wIndex = i32(localIndex);\n        ").concat(e<t?"if (wIndex < ".concat(e,")"):"for(; wIndex < ".concat(e,"; wIndex = wIndex + ").concat(t,")"),"\n\n        {\n          let wRow = wIndex / ").concat(this.filterWidth,";\n          let wCol = wIndex % ").concat(this.filterWidth,";\n          mm_Bsub[wRow][wCol] = getW(wRow, wCol, d1, q);\n        }\n\n        workgroupBarrier();\n\n        var value = 0.0;\n        for (var wR = 0; wR < ").concat(this.filterHeight,"; wR = wR + 1) {\n          for (var wC = 0; wC < ").concat(this.filterWidth,"; wC = wC + 1) {\n            let xVal = mm_Asub[localRow + wR][localCol + wC];\n            let wVal = mm_Bsub[wR][wC];\n            value = fma(xVal, wVal, value);\n          }\n        }\n        ").concat(ie(this.addBias,this.activation),"\n        if (coordsInBounds4D(coords, uniforms.outShape)) {\n          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n        }\n      }\n    ")},e}(),ya=function(){function e(e,n,a,r){void 0===n&&(n=!1),void 0===a&&(a=null),void 0===r&&(r=!1),this.variableNames=["x","W"],this.uniforms="pad : vec2<i32>, inDims : vec2<i32>,",this.workgroupSize=[4,4,4],this.workPerThread=4,this.isVec4=!0,this.outputShape=e.outShape,this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=F(this.dispatchLayout,this.outputShape,this.workgroupSize,[4,this.workPerThread,1]),t.util.assert("channelsLast"===e.dataFormat,(function(){return"TODO: NCHW is unimplemented"})),n&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),this.convInfo=e,this.addBias=n,this.activation=a,this.hasPreluActivation=r,this.shaderKey="depthwiseVec4_".concat(a,"_").concat(this.convInfo.filterHeight,"_").concat(this.convInfo.filterWidth,"_").concat(this.convInfo.strideHeight,"_").concat(this.convInfo.strideWidth,"_").concat(this.workPerThread)}return e.prototype.getUserCode=function(){var e=(this.workPerThread-1)*this.convInfo.strideWidth+this.convInfo.filterWidth,t=this.convInfo.strideHeight,n=this.convInfo.strideWidth;return"\n      ".concat(re(this.activation,this.hasPreluActivation,!0,4),"\n      fn readX(batch : i32, row : i32, col : i32, channel : i32) -> vec4<f32> {\n        var value = vec4<f32>(0.0);\n        if (col >=0 && col < uniforms.inDims[1]) {\n          value = getX(batch, row, col, channel);\n        }\n        return value;\n      }\n\n      ").concat(k()," {\n        let batch = i32(globalId.z) / uniforms.outShape[1];\n        let r = i32(globalId.z) % uniforms.outShape[1];\n        let c = i32(globalId.y) * ").concat(this.workPerThread,";\n        let d1 = i32(globalId.x) * 4;\n        let xRCCorner = vec2<i32>(r, c) * vec2<i32>(").concat(t,", ").concat(n,") - uniforms.pad;\n\n        let xRCorner = xRCCorner.x;\n        let xCCorner = xRCCorner.y;\n        var xVals : array<vec4<f32>, ").concat(e,">;\n        var dotProd : array<vec4<f32>, ").concat(this.workPerThread,">;\n        for (var i = 0; i < ").concat(this.workPerThread,"; i++) {\n          dotProd[i] = vec4<f32>(0.0);\n        }\n\n        // Use constant instead of uniform can give better performance.\n        for (var wR = 0; wR < ").concat(this.convInfo.filterHeight,"; wR = wR + 1) {\n          let xR = xRCorner + wR;\n          if (xR >=0 && xR < uniforms.inDims[0]) {\n            for (var i = 0; i < ").concat(e,"; i++) {\n              xVals[i] = readX(batch, xR, xCCorner + i, d1);\n            }\n            for (var wC = 0; wC < ").concat(this.convInfo.filterWidth,"; wC = wC + 1) {\n              let wValue = getW(wR, wC, d1, 0);\n              for (var i = 0; i < ").concat(this.workPerThread,"; i++) {\n                dotProd[i] = fma(xVals[i * ").concat(n," + wC], wValue, dotProd[i]);\n              }\n            }\n          }\n        }\n\n        for (var i = 0; i < ").concat(this.workPerThread,"; i = i + 1) {\n          let coords = vec4<i32>(batch, r, c + i, d1);\n          if (coordsInBounds4D(coords, uniforms.outShape)) {\n            var value = dotProd[i];\n            ").concat(ie(this.addBias,this.activation),"\n            setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n          }\n        }\n      }\n    ")},e}(),wa=function(){function e(e,t,n,a){void 0===t&&(t=!1),void 0===n&&(n=null),void 0===a&&(a=!1),this.variableNames=["x","W"],this.uniforms="pad : vec2<i32>, inDims : vec2<i32>, filterHeight : i32,\n      filterWidth : i32, stride : vec2<i32>, dilation : vec2<i32>,",this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=U(this.outputShape),this.dispatch=F(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast="channelsLast"===e.dataFormat,t&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),this.convInfo=e,this.addBias=t,this.activation=n,this.hasPreluActivation=a,this.shaderKey="depthwise_".concat(this.activation,"_").concat(this.isChannelsLast)}return e.prototype.getUserCode=function(){var e=this.isChannelsLast?"getX(batch, xR, xC, d1);":"getX(batch, d1, xR, xC);";return"\n      ".concat(re(this.activation,this.hasPreluActivation,!1,4),"\n\n      ").concat(k("index")," {\n        if (index < uniforms.size) {\n          let coords = getOutputCoords();\n          let batch = coords[0];\n          let xRCCorner = vec2<i32>(coords.").concat(this.isChannelsLast?"yz":"zw",") * uniforms.stride - uniforms.pad;\n          let d2 = coords[").concat(this.isChannelsLast?3:1,"];\n          let channelMul = uniforms.wShape[3];\n          let d1 = d2 / channelMul;\n          let q = d2 % channelMul;\n\n          let inputRowStart = xRCCorner.x;\n          let inputColStart = xRCCorner.y;\n          let inputRowEnd = inputRowStart + uniforms.filterHeight *\n              uniforms.dilation[0];\n          let inputColEnd = inputColStart + uniforms.filterWidth *\n              uniforms.dilation[1];\n\n          // Convolve x(?, ?, d1)|x(d1, ?, ?) with w(:, :, d1, q) to get\n          // y(yR, yC, d2)|y(d2, yR, yC). ? = to be determined. : = across all\n          // values in that axis. x(?, ?, d1) and y(yR, yC, d2) is for NHWC.\n          // x(d1, ?, ?) and y(d2, yR, yC) is for NCHW.\n          var value = 0.0;\n\n          // Extract if checking out of for loop for performance.\n          if (inputRowStart >= 0 && inputColStart >= 0 &&\n            inputRowEnd < uniforms.inDims[0] &&\n                inputColEnd < uniforms.inDims[1]) {\n              for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {\n                let xR = inputRowStart + wR * uniforms.dilation[0];\n\n                for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {\n                  let xC = inputColStart + wC * uniforms.dilation[1];\n\n                  let xVal = ").concat(e,";\n                  let wVal = getW(wR, wC, d1, q);\n                  value = value + xVal * wVal;\n                }\n              }\n            } else {\n              for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {\n                let xR = inputRowStart + wR * uniforms.dilation[0];\n\n                if (xR < 0 || xR >= uniforms.inDims[0]) {\n                  continue;\n                }\n\n                for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {\n                  let xC = inputColStart + wC * uniforms.dilation[1];\n\n                  if (xC < 0 || xC >= uniforms.inDims[1]) {\n                    continue;\n                  }\n\n                  let xVal = ").concat(e,";\n                  let wVal = getW(wR, wC, d1, q);\n                  value = value + xVal * wVal;\n                }\n              }\n            }\n            ").concat(ie(this.addBias,this.activation),"\n          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n        }\n      }\n    ")},e}();var ka={kernelName:t.DepthwiseConv2dNative,backendName:"webgpu",kernelFunc:function(e){var n=e.inputs,a=e.backend,r=e.attrs,i=n.x,o=n.filter,s=r.strides,u=r.pad,c=r.dataFormat,d=r.dilations,l=r.dimRoundingMode,h=t.backend_util.convertConv2DDataFormat(c),p=d;null==p&&(p=[1,1]);var f,m=t.backend_util.computeConv2DInfo(i.shape,o.shape,s,p,u,l,!0,h),g=[{type:"int32",data:[m.padInfo.top,m.padInfo.left]},{type:"int32",data:[m.inHeight,m.inWidth]}],v="channelsLast"===m.dataFormat;return!v&&m.inHeight>16&&m.inWidth>16&&1===m.strideHeight&&1===m.strideWidth&&1===m.dilationWidth&&1===m.dilationHeight&&m.inChannels===m.outChannels?f=new xa(m.outShape,m.filterHeight,m.filterWidth):v&&m.outHeight>4&&m.outWidth>4&&m.strideWidth<=2&&m.inChannels===m.outChannels&&1===m.dilationHeight&&1===m.dilationWidth&&m.inChannels%4==0?f=new ya(m):(f=new wa(m),g.push({type:"int32",data:[m.filterHeight]},{type:"int32",data:[m.filterWidth]},{type:"int32",data:[m.strideHeight,m.strideWidth]},{type:"int32",data:[m.dilationHeight,m.dilationWidth]})),a.runWebGPUProgram(f,[i,o],i.dtype,g)}},Sa=function(){function e(e){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e,e],this.dispatchLayout=U(this.outputShape),this.dispatch=F(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="diag"}return e.prototype.getUserCode=function(){return"\n      ".concat(k("index")," {\n        if (index < uniforms.size) {\n          let coords = getOutputCoords();\n          let value = select(0.0, getX(coords[0]), coords[0] == coords[1]);\n          setOutputAtIndex(index, value);\n        }\n      }\n    ")},e}();var Ia={kernelName:t.Diag,backendName:"webgpu",kernelFunc:function(e){var n=e.inputs,a=e.backend,r=n.x,i=c(c([],u(r.shape),!1),u(r.shape),!1),o=t.util.sizeFromShape(r.shape),s=xe({inputs:{x:r},backend:a,attrs:{shape:[o]}}),d=new Sa(o),l=a.runWebGPUProgram(d,[s],s.dtype),h=xe({inputs:{x:l},backend:a,attrs:{shape:i}});return a.disposeData(s.dataId),a.disposeData(l.dataId),h}},Ca=function(){function e(e){this.variableNames=["x","w"],this.uniforms="filterDims: vec2<i32>, pad: vec2<i32>, stride: vec2<i32>, dilation: vec2<i32>",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=U(this.outputShape),this.dispatch=F(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="dilation2d"}return e.prototype.getUserCode=function(){return"\n       ".concat(k("index")," {\n         if (index < uniforms.size) {\n           let neg_infinity = -3.4e38;\n           let coords = getOutputCoords();\n           let batch = coords.x;\n           let d1 = coords.w;\n           let outTopLeftCorner = coords.yz * uniforms.stride - uniforms.pad;\n           let hBeg = outTopLeftCorner.x;\n           let wBeg = outTopLeftCorner.y;\n\n           var curVal = neg_infinity;\n           for (var h = 0; h < uniforms.filterDims[0]; h = h + 1) {\n             let hIn = hBeg + h * uniforms.dilation[0];\n\n             if (hIn >= 0 && hIn < uniforms.xShape[1]) {\n               for (var w = 0; w < uniforms.filterDims[1]; w = w + 1) {\n                 let wIn = wBeg + w * uniforms.dilation[1];\n\n                 if (wIn >= 0 && wIn < uniforms.xShape[2]) {\n                   let val = getX(batch, hIn, wIn, d1) + getW(h, w, d1);\n                   if (val > curVal) {\n                     curVal = val;\n                   }\n                 }\n               }\n             }\n           }\n\n           setOutputAtIndex(index, curVal);\n         }\n       }\n     ")},e}();var Aa={kernelName:t.Dilation2D,backendName:"webgpu",kernelFunc:function(e){var n=e.inputs,a=e.backend,r=e.attrs,i=n.x,o=n.filter,s=r.strides,d=r.pad,l=r.dilations,h=t.backend_util.computeDilation2DInfo(i.shape,o.shape,s,d,"NHWC",l),p=[h.padInfo.top,h.padInfo.left],f=[{type:"int32",data:[h.filterHeight,h.filterWidth]},{type:"int32",data:c([],u(p),!1)},{type:"int32",data:[h.strideHeight,h.strideWidth]},{type:"int32",data:[h.dilationHeight,h.dilationWidth]}],m=new Ca(h);return a.runWebGPUProgram(m,[i,o],i.dtype,f)}},Ra=ze({opType:M.MUL,cpuKernelImpl:bt,supportsComplex:!0}),Na={kernelName:t.Multiply,backendName:"webgpu",kernelFunc:Ra};function Pa(e){var t=e.inputs,n=e.backend,a=e.attrs;return qt(t.x,a.axis,a.keepDims,"sum",n)}var Ta={kernelName:t.Sum,backendName:"webgpu",kernelFunc:Pa};var za={kernelName:t.Einsum,backendName:"webgpu",kernelFunc:function(e){var n,a,r,i,o=e.inputs,u=e.backend,c=e.attrs.equation,d=o,l=t.backend_util.decodeEinsumEquation(c,d.length),h=l.allDims,p=l.summedDims,f=l.idDims;t.backend_util.checkEinsumDimSizes(h.length,f,d);for(var m=t.backend_util.getEinsumComputePath(p,f),g=m.path,v=m.steps,b=v.length,x=null,y=h.length,w=[],k=0;k<b;++k){try{for(var S=(n=void 0,s(v[k])),I=S.next();!I.done;I=S.next()){var C=I.value,A=t.backend_util.getEinsumPermutation(y,f[C]),R=A.permutationIndices,N=A.expandDims,P=void 0;t.backend_util.isIdentityPermutation(R)?P=d[C]:(P=Kt({inputs:{x:d[C]},backend:u,attrs:{perm:R}}),w.push(P));for(var T=P.shape.slice(),z=0;z<N.length;++z)T.splice(N[z],0,1);t.util.arraysEqual(P.shape,T)||(P=xe({inputs:{x:P},backend:u,attrs:{shape:T}}),w.push(P)),null===x?x=P:(x=Ra({inputs:{a:P,b:x},backend:u}),w.push(x))}}catch(e){n={error:e}}finally{try{I&&!I.done&&(a=S.return)&&a.call(S)}finally{if(n)throw n.error}}k<b-1&&(g[k]>=0&&(x=Pa({inputs:{x:x},backend:u,attrs:{axis:g[k]-(h.length-y),keepDims:!1}}),w.push(x)),y--)}try{for(var _=s(w),F=_.next();!F.done;F=_.next()){var B=F.value;B!==x&&u.disposeData(B.dataId)}}catch(e){r={error:e}}finally{try{F&&!F.done&&(i=_.return)&&i.call(_)}finally{if(r)throw r.error}}return x}},_a=Te({opType:K.ELU}),Fa={kernelName:t.Elu,backendName:"webgpu",kernelFunc:_a},Ba=ze({opType:M.EQUAL,dtype:"bool",cpuKernelImpl:rt}),Ea={kernelName:t.Equal,backendName:"webgpu",kernelFunc:Ba},La=Te({opType:K.ERF}),Ua={kernelName:t.Erf,backendName:"webgpu",kernelFunc:La},Oa=Te({opType:K.EXP,cpuKernelImpl:it,dtype:"float32"}),Da={kernelName:t.Exp,backendName:"webgpu",kernelFunc:Oa};function Wa(e){var n=e.inputs,a=e.attrs,r=e.backend,i=a.dim,o=n.input,s=o.shape.length,u=o.shape.slice(),c=i;return i<0&&(t.util.assert(-(s+1)<=i,(function(){return"Axis must be in the interval [".concat(-(s+1),", ").concat(s,"]")})),c=s+i+1),u.splice(c,0,1),xe({inputs:{x:o},backend:r,attrs:{shape:u}})}var Ma={kernelName:t.ExpandDims,backendName:"webgpu",kernelFunc:Wa},Va=Te({opType:K.EXPM1,cpuKernelImpl:ot}),Ga={kernelName:t.Expm1,backendName:"webgpu",kernelFunc:Va},Ha=function(){function e(e,t){this.variableNames=["real","imag"],this.outputShape=[],this.uniforms="exponentMultiplier : f32, denominator: f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=U(this.outputShape),this.dispatch=F(this.dispatchLayout,this.outputShape,this.workgroupSize),this.component=e,this.shaderKey="fft_".concat(e)}return e.prototype.getUserCode=function(){var e="real"===this.component?"return real * expR - imag * expI;":"return real * expI + imag * expR;";return"\n    fn unaryOpComplex(real: f32, expR: f32, imag: f32, expI: f32) -> f32 {\n      ".concat(e,"\n    }\n\n    fn mulMatDFT(batch: i32, index: i32) -> f32 {\n      let indexRatio = f32(index) / f32(uniforms.realShape[1]);\n      let exponentMultiplierTimesIndexRatio =\n          uniforms.exponentMultiplier * indexRatio;\n\n      var result = 0.0;\n\n      for (var i = 0; i < uniforms.realShape[1]; i = i + 1) {\n        // x = (-2|2 * PI / N) * index * i;\n        let x = exponentMultiplierTimesIndexRatio * f32(i);\n        let expR = cos(x);\n        let expI = sin(x);\n        let real = getReal(batch, i);\n        let imag = getImag(batch, i);\n\n        result = result +\n            unaryOpComplex(real, expR, imag, expI) / uniforms.denominator;\n      }\n\n      return result;\n    }\n\n    ").concat(k("index")," {\n      if (index < uniforms.size) {\n        let coords = getOutputCoords();\n        setOutputAtIndex(index, mulMatDFT(coords[0], coords[1]));\n      }\n    }\n  ")},e}();function Ka(e,n,a){var r=a.tensorMap.get(e.dataId),i=t.util.sizeFromShape(e.shape),o=e.shape[e.shape.length-1],s=[],u=xe({inputs:{x:e},backend:a,attrs:{shape:[i/o,o]}});s.push(u);var c=u.shape,d=new Ha("real",c),l=new Ha("imag",c),h=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:c},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:c}],p=[{type:"float32",data:[n?2*Math.PI:-2*Math.PI]},{type:"float32",data:[n?c[1]:1]}],f=a.runWebGPUProgram(d,h,"float32",p);s.push(f);var m=a.runWebGPUProgram(l,h,"float32",p);s.push(m);var g=Re({inputs:{real:f,imag:m},backend:a});s.push(g);var v=xe({inputs:{x:g},backend:a,attrs:{shape:e.shape}});return s.forEach((function(e){return a.disposeData(e.dataId)})),v}var Xa,ja={kernelName:t.FFT,backendName:"webgpu",kernelFunc:function(e){var t=e.inputs,n=e.backend;return Ka(t.input,!1,n)}},qa=function(){function e(e){this.outputShape=[],this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=U(this.outputShape),this.dispatch=F(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="flipLeftRight"}return e.prototype.getUserCode=function(){return"\n      ".concat(k("index")," {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let coordX = uniforms.xShape[2] - coords[2] - 1;\n          let outputValue = getX(coords[0], coords[1], coordX, coords[3]);\n          setOutputAtIndex(index, outputValue);\n        }\n      }\n    ")},e}(),Ya={kernelName:t.FlipLeftRight,backendName:"webgpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,a=t.image,r=n,i=new qa(a.shape);return r.runWebGPUProgram(i,[a],a.dtype)}},Qa=Te({opType:K.FLOOR,cpuKernelImpl:st}),Za={kernelName:t.Floor,backendName:"webgpu",kernelFunc:Qa},Ja=ze({opType:M.INT_DIV,dtype:"int32"}),$a={kernelName:t.FloorDiv,backendName:"webgpu",kernelFunc:Ja},er=function(){function e(e,t,n){void 0===n&&(n=!1),this.isFromPixels=!0,this.outputShape=[0],this.variableNames=[],this.workgroupSize=[256,1,1],this.outputShape=e,this.dispatchLayout=U(this.outputShape),this.dispatch=F(this.dispatchLayout,this.outputShape,this.workgroupSize,[t,1,1]),this.importVideo=n,this.shaderKey="fromPixels_".concat(this.importVideo)}return e.prototype.getUserCode=function(){var e=this.importVideo?"textureLoad(src, vec2<i32>(coords.yx));":"textureLoad(src, vec2<i32>(coords.yx), 0)",t=this.importVideo?"texture_external":"texture_2d<f32>";return"\n      @binding(1) @group(0) var src: ".concat(t,";\n      ").concat(k("index")," {\n        let flatIndex = index * uniforms.numChannels;\n        if (flatIndex < uniforms.size) {\n          let coords = getCoordsFromIndex(flatIndex);\n          let values = ").concat(e,";\n          for (var i = 0; i < uniforms.numChannels; i = i + 1) {\n            result[flatIndex + i] = i32(floor(255.0 * values[i]));\n          }\n        }\n      }\n  ")},e}(),tr={kernelName:t.FromPixels,backendName:"webgpu",kernelFunc:function(e){var n=e.inputs,a=e.backend,r=e.attrs,i=n.pixels,o=r.numChannels;if(null==i)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");var s="undefined"!=typeof HTMLVideoElement&&i instanceof HTMLVideoElement,d="undefined"!=typeof HTMLImageElement&&i instanceof HTMLImageElement,l="undefined"!=typeof HTMLCanvasElement&&i instanceof HTMLCanvasElement||"undefined"!=typeof OffscreenCanvas&&i instanceof OffscreenCanvas,h="undefined"!=typeof ImageBitmap&&i instanceof ImageBitmap,p=u(s?[i.videoWidth,i.videoHeight]:[i.width,i.height],2),f=p[0],m=p[1],g=[m,f,o],v=s||d;if(h||l||v){var b;if(v){var x=t.env().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");null!=Xa&&x===nr||(nr=x,Xa=document.createElement("canvas").getContext("2d",{willReadFrequently:nr})),Xa.canvas.width=f,Xa.canvas.height=m,Xa.drawImage(i,0,0,f,m),i=Xa.canvas}var y=GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING,w="rgba8unorm",k=a.textureManager.acquireTexture(g[1],g[0],w,y);a.queue.copyExternalImageToTexture({source:i},{texture:k},[g[1],g[0]]),b={width:f,height:m,format:w,usage:y,texture:k};var S=t.util.sizeFromShape(g),I=t.util.computeStrides(g),C=new er(g,o,!1),A=[{type:"uint32",data:[S]},{type:"uint32",data:[o]},{type:"uint32",data:c([],u(I),!1)}],R=a.makeTensorInfo([m,f],"int32");a.tensorMap.get(R.dataId).resourceInfo=b;var N=a.runWebGPUProgram(C,[R],"int32",A);return a.disposeData(R.dataId),N}var P=i.data,T=P;if(null!=o&&4!==o){T=new Uint8Array(i.width*i.height*o);for(var z=P.length,_=0,F=0;F<z;F++)F%4<o&&(T[_++]=P[F])}var B=a.makeTensorInfo(g,"int32",new Int32Array(T));return a.uploadToGPU(B.dataId),B}},nr=t.env().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");var ar=function(){function e(e,n,a,r,i){this.uniforms="varianceEpsilon : f32,",this.workgroupSize=[128,1,1],this.size=!0,this.variableNames=["x","mean","variance"],t.backend_util.assertAndGetBroadcastShape(e,n),t.backend_util.assertAndGetBroadcastShape(e,a),this.outputShape=e,this.dispatchLayout=U(this.outputShape),this.dispatch=F(this.dispatchLayout,this.outputShape,this.workgroupSize),null!=r&&(t.backend_util.assertAndGetBroadcastShape(e,r),this.variableNames.push("offset")),null!=i&&(t.backend_util.assertAndGetBroadcastShape(e,i),this.variableNames.push("scale")),this.offsetShape=r,this.scaleShape=i,this.shaderKey="batchNorm"}return e.prototype.getUserCode=function(){var e="0.0";null!=this.offsetShape&&(e="getOffsetByOutputIndex(index)");var t="1.0";return null!=this.scaleShape&&(t="getScaleByOutputIndex(index)"),"\n      ".concat(k("index")," {\n        if (index < uniforms.size)\n        {\n          let xValue = getXByOutputIndex(index);\n          let meanValue = getMeanByOutputIndex(index);\n          let varianValue = getVarianceByOutputIndex(index);\n          let offsetValue = ").concat(e,";\n          let scaleValue = ").concat(t,";\n          let inv = scaleValue * inverseSqrt(varianValue + f32(uniforms.varianceEpsilon));\n          setOutputAtIndex(index,dot(vec3<f32>(xValue, -meanValue, offsetValue), vec3<f32>(inv, inv, 1.0)));\n        }\n      }\n  ")},e}(),rr={kernelName:t.FusedBatchNorm,backendName:"webgpu",kernelFunc:function(e){var t=e.inputs,n=e.attrs,a=e.backend,r=t.x,i=t.scale,o=t.offset,s=t.mean,u=t.variance,c=n.varianceEpsilon,d=a,l=[r,s,u],h=null;null!=o&&(h=o.shape,l.push(o));var p=null;null!=i&&(p=i.shape,l.push(i));var f=new ar(r.shape,s.shape,u.shape,h,p),m=[{type:"float32",data:[c]}];return d.runWebGPUProgram(f,l,r.dtype,m)}};var ir={kernelName:t.FusedConv2D,backendName:"webgpu",kernelFunc:function(e){var n=e.inputs,a=e.backend,r=e.attrs,i=n.x,o=n.filter,s=n.bias,u=n.preluActivationWeights,c=r.strides,d=r.pad,l=r.dataFormat,h=r.dilations,p=r.dimRoundingMode,f=r.activation,m=r.leakyreluAlpha,g=t.backend_util.convertConv2DDataFormat(l);return Qn({x:i,filter:o,convInfo:t.backend_util.computeConv2DInfo(i.shape,o.shape,c,h,d,p,!1,g),backend:a,bias:s,preluActivationWeights:u,leakyreluAlpha:m,activation:f})}};var or={kernelName:t.FusedDepthwiseConv2D,backendName:"webgpu",kernelFunc:function(e){var n=e.inputs,a=e.backend,r=e.attrs,i=n.x,o=n.filter,s=n.bias,u=n.preluActivationWeights,c=r.strides,d=r.pad,l=r.dilations,h=r.dimRoundingMode,p=r.activation,f=r.leakyreluAlpha,m=l;null==m&&(m=[1,1]),t.util.assert(t.backend_util.eitherStridesOrDilationsAreOne(c,m),(function(){return"Error in depthwiseConv2d: Either strides or dilations must be "+"1. Got strides ".concat(c," and dilations '").concat(m,"'")}));var g=t.backend_util.computeConv2DInfo(i.shape,o.shape,c,m,d,h,!0),v=[i,o],b=null!=s,x=null!=u;b&&v.push(s),x&&v.push(u);var y,w=[{type:"int32",data:[g.padInfo.top,g.padInfo.left]},{type:"int32",data:[g.inHeight,g.inWidth]}];return g.outHeight>4&&g.outWidth>4&&g.strideWidth<=2&&g.inChannels===g.outChannels&&1===g.dilationHeight&&1===g.dilationWidth&&g.inChannels%4==0?y=new ya(g,b,p,x):(y=new wa(g,b,p,x),w.push({type:"int32",data:[g.filterHeight]},{type:"int32",data:[g.filterWidth]},{type:"int32",data:[g.strideHeight,g.strideWidth]},{type:"int32",data:[g.dilationHeight,g.dilationWidth]})),"leakyrelu"===p&&(w.push({type:"float32",data:[f]}),y.uniforms+=" alpha : f32,"),a.runWebGPUProgram(y,v,"float32",w)}},sr=function(){function e(e,t){this.variableNames=["A","indices"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=U(this.outputShape),this.dispatch=F(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="gathernd_".concat(e),this.sliceDim=e,this.uniforms="sliceDim : i32, strides : ".concat(y(e),",")}return e.prototype.getUserCode=function(){var e;return e=this.sliceDim>1?"uniforms.strides[j]":"uniforms.strides","\n      ".concat(k("index")," {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          var flattenIndex = 0;\n          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {\n            let indexTemp = i32(round(getIndices(coords[0], j)));\n            let strideNum = ").concat(e,";\n            flattenIndex = flattenIndex + indexTemp * strideNum;\n          }\n\n          setOutputAtIndex(index, getA(flattenIndex, coords[1]));\n        }\n      }\n      ")},e}();var ur={kernelName:t.GatherNd,backendName:"webgpu",kernelFunc:function(e){var n=e.inputs,a=e.backend,r=n.params,i=n.indices,o=i.shape,s=o[o.length-1],c=t.util.sizeFromShape(r.shape),d=u(t.backend_util.prepareAndValidate(r,i),4),l=d[0],h=d[1],p=d[2],f=d[3],m=xe({inputs:{x:i},backend:a,attrs:{shape:[h,s]}}),g=xe({inputs:{x:r},backend:a,attrs:{shape:[t.util.sizeFromShape(r.shape)/p,p]}});if(a.shouldExecuteOnCPU([r,i])||"string"===r.dtype){var v=a.readSync(i.dataId),b=a.bufferSync(r),x=ut(v,b,r.dtype,h,s,p,f,r.shape,c);return a.makeTensorInfo(l,r.dtype,x.values)}var y=new sr(s,[h,p]),w=[{type:"int32",data:[s]},{type:"int32",data:f}],k=a.runWebGPUProgram(y,[g,m],g.dtype,w),S=xe({inputs:{x:k},backend:a,attrs:{shape:l}});return a.disposeData(m.dataId),a.disposeData(g.dataId),a.disposeData(k.dataId),S}},cr=function(){function e(e,t){this.variableNames=["A","indices"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.slice(),this.aShape=e,this.outputShape=t,this.dispatchLayout=U(this.outputShape),this.dispatch=F(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="gather"}return e.prototype.getUserCode=function(){var e=function(e){for(var t=["resRC.x","resRC.y","resRC.z","resRC.w"],n=[],a=0;a<e.length;a++)2===a?n.push("indexZ"):n.push("".concat(t[a]));return n.join()}(this.aShape);return"\n      ".concat(k("index")," {\n        if (index < uniforms.size) {\n          let resRC = getCoordsFromIndex(index);\n          let indexZ = i32(getIndices(resRC.x, resRC.z));\n          let inBounds = select(0.0, 1.0, indexZ >= 0 && indexZ < uniforms.aShape[2]);\n          setOutputAtIndex(index, inBounds * getA(").concat(e,"));\n        }\n      }\n    ")},e}();function dr(e){var n=e.inputs,a=e.backend,r=e.attrs,i=n.x,o=n.indices,s=r.axis,u=r.batchDims,c=t.util.parseAxisParam(s,i.shape)[0],d=t.backend_util.segment_util.collectGatherOpShapeInfo(i,o,c,u),l=t.util.sizeFromShape(o.shape),h=[],p=xe({inputs:{x:i},backend:a,attrs:{shape:[d.batchSize,d.outerSize,d.dimSize,d.sliceSize]}}),f=xe({inputs:{x:o},backend:a,attrs:{shape:[d.batchSize,l/d.batchSize]}});h.push(p),h.push(f);var m=[d.batchSize,d.outerSize,l/d.batchSize,d.sliceSize];if(a.shouldExecuteOnCPU([i,o])){var g=a.tensorMap.get(f.dataId).values,v=t.buffer(f.shape,f.dtype,g),b=a.tensorMap.get(p.dataId).values,x=t.buffer(p.shape,p.dtype,b),y=ct(x,v,m);return h.forEach((function(e){return a.disposeData(e.dataId)})),a.makeTensorInfo(d.outputShape,y.dtype,y.values)}var w=new cr(p.shape,m),k=a.runWebGPUProgram(w,[p,f],p.dtype);h.push(k);var S=xe({inputs:{x:k},backend:a,attrs:{shape:d.outputShape}});return h.forEach((function(e){return a.disposeData(e.dataId)})),S}var lr={kernelName:t.GatherV2,backendName:"webgpu",kernelFunc:dr},hr=ze({opType:M.GREATER,cpuKernelImpl:lt,dtype:"bool"}),pr={kernelName:t.Greater,backendName:"webgpu",kernelFunc:hr},fr=ze({opType:M.GREATER_EQUAL,dtype:"bool",cpuKernelImpl:dt}),mr={kernelName:t.GreaterEqual,backendName:"webgpu",kernelFunc:fr};var gr={kernelName:t.IFFT,backendName:"webgpu",kernelFunc:function(e){var t=e.inputs,n=e.backend;return Ka(t.input,!0,n)}},vr=Te({opType:K.IS_FINITE,dtype:"bool"}),br={kernelName:t.IsFinite,backendName:"webgpu",kernelFunc:vr},xr=Te({opType:K.IS_INF,dtype:"bool"}),yr={kernelName:t.IsInf,backendName:"webgpu",kernelFunc:xr},wr=Te({opType:K.IS_NAN,dtype:"bool"}),kr={kernelName:t.IsNan,backendName:"webgpu",kernelFunc:wr};var Sr={kernelName:t.LeakyRelu,backendName:"webgpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,a=e.attrs,r=t.x,i=[{type:"float32",data:[a.alpha]}],o=new Pe(r.shape,K.LEAKYRELU,"alpha : f32,");return n.runWebGPUProgram(o,[r],"float32",i)}},Ir=ze({opType:M.LESS,dtype:"bool",cpuKernelImpl:pt}),Cr={kernelName:t.Less,backendName:"webgpu",kernelFunc:Ir},Ar=ze({opType:M.LESS_EQUAL,dtype:"bool",cpuKernelImpl:ht}),Rr={kernelName:t.LessEqual,backendName:"webgpu",kernelFunc:Ar},Nr=function(){function e(e){this.variableNames=[],this.outputShape=[],this.uniforms="start : f32, step : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e],this.dispatchLayout=U(this.outputShape),this.dispatch=F(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="linSpace"}return e.prototype.getUserCode=function(){return"\n      ".concat(k("index")," {\n        if (index < uniforms.size) {\n          setOutputAtIndex(index, uniforms.start + f32(index) * uniforms.step);\n        }\n      }\n    ")},e}();var Pr={kernelName:t.LinSpace,backendName:"webgpu",kernelFunc:function(e){var t=e.backend,n=e.attrs,a=n.start,r=n.stop,i=n.num,o=(r-a)/(i-1),s=new Nr(i),u=[{type:"float32",data:[a]},{type:"float32",data:[o]}];return t.runWebGPUProgram(s,[],"float32",u)}},Tr=Te({opType:K.LOG,cpuKernelImpl:ft}),zr={kernelName:t.Log,backendName:"webgpu",kernelFunc:Tr},_r=Te({opType:K.LOG1P}),Fr={kernelName:t.Log1p,backendName:"webgpu",kernelFunc:_r},Br=ze({opType:M.LOGICAL_AND,dtype:"bool"}),Er={kernelName:t.LogicalAnd,backendName:"webgpu",kernelFunc:Br},Lr=Te({opType:K.LOGICAL_NOT}),Ur={kernelName:t.LogicalNot,backendName:"webgpu",kernelFunc:Lr},Or=ze({opType:M.LOGICAL_OR}),Dr={kernelName:t.LogicalOr,backendName:"webgpu",kernelFunc:Or},Wr="\n  var powValue = 0.0;\n  let basis = uniforms.bias + uniforms.alpha * sum;\n  if (uniforms.beta == 0.5) {\n    powValue = inverseSqrt(basis);\n  } else if (uniforms.beta == 1.0) {\n    powValue = 1.0 / basis;\n  } else {\n    powValue = exp(log(basis) * (-uniforms.beta));\n  }\n",Mr=function(){function e(e){this.outputShape=[],this.variableNames=["x"],this.uniforms="radius : i32, bias : f32, alpha : f32, beta : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=U(this.outputShape),this.dispatch=F(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="lrn"}return e.prototype.getUserCode=function(){return"\n    ".concat(k("index")," {\n      if (index < uniforms.size) {\n        let coords = getOutputCoords();\n        let b = coords[0];\n        let r = coords[1];\n        let c = coords[2];\n        let d = coords[3];\n\n        let x = getX(b, r, c, d);\n        var sum = 0.0;\n        for (var i = -uniforms.radius; i <= uniforms.radius; i = i + 1) {\n          let idx = d + i;\n          if (idx >= 0 && idx < uniforms.xShape[3]) {\n            let z = getX(b, r, c, idx);\n            sum = sum + z * z;\n          }\n        }\n        ").concat(Wr,"\n\n        setOutputAtIndex(index, x * powValue);\n      }\n    }\n  ")},e}(),Vr=function(){function e(e,n){var a=this;this.outputShape=[],this.variableNames=["x"],this.uniforms="radius : i32, bias : f32, alpha : f32, beta : f32,",this.workgroupSize=[256,1,1],this.maxAllowRadius=16,t.util.assert(n<=this.maxAllowRadius,(function(){return"Radius must be less than or equal to ".concat(a.maxAllowRadius,", current radius is ").concat(n)})),this.outputShape=e,this.elementsPerWorkgroup=this.workgroupSize[0]-2*this.maxAllowRadius,this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=F(this.dispatchLayout,this.outputShape,[this.elementsPerWorkgroup,this.workgroupSize[1],this.workgroupSize[2]]),this.shaderKey="lrn_shared"}return e.prototype.getUserCode=function(){return"\n    var <workgroup>lrnSub: array<f32, ".concat(this.workgroupSize[0],">;\n    const elementsPerWorkgroup = ").concat(this.elementsPerWorkgroup,";\n    const maxAllowRadius = ").concat(this.maxAllowRadius,";\n\n    ").concat(k()," {\n      let localDepth = i32(localId.x);\n      let workgroupDepth = i32(workgroupId.x) * elementsPerWorkgroup;\n      let xDepth = workgroupDepth + localDepth - maxAllowRadius;\n      let b = i32(globalId.z) / uniforms.xShape[1];\n      let r = i32(globalId.z) - b * uniforms.xShape[1];\n      let c = i32(globalId.y);\n      let d = workgroupDepth + localDepth;\n\n      var x = 0.0;\n      if (xDepth >= 0 && xDepth < uniforms.xShape[3]) {\n        x = getX(b, r, c, xDepth);\n      }\n      lrnSub[localDepth] = x;\n      workgroupBarrier();\n\n      if (localDepth < elementsPerWorkgroup && d < uniforms.outShape[3]) {\n        var sum = 0.0;\n        let index = localDepth + maxAllowRadius;\n        for (var i = -uniforms.radius; i <= uniforms.radius; i = i + 1) {\n          let z = lrnSub[index + i];\n          sum = sum + z * z;\n        }\n        ").concat(Wr,"\n\n        setOutputAtCoords(b, r, c, d, lrnSub[index] * powValue);\n      }\n    } ")},e}();var Gr={kernelName:t.LRN,backendName:"webgpu",kernelFunc:function(e){var t,n=e.inputs,a=e.backend,r=e.attrs,i=n.x,o=r.depthRadius,s=r.bias,u=r.alpha,c=r.beta;t=o>16?new Mr(i.shape):new Vr(i.shape,o);var d=[{type:"int32",data:[o]},{type:"float32",data:[s]},{type:"float32",data:[u]},{type:"float32",data:[c]}];return a.runWebGPUProgram(t,[i],i.dtype,d)}},Hr=ze({opType:M.MAX,cpuKernelImpl:gt}),Kr={kernelName:t.Maximum,backendName:"webgpu",kernelFunc:Hr};var Xr={kernelName:t.MaxPool,backendName:"webgpu",kernelFunc:function(e){var n=e.inputs,a=e.backend,r=e.attrs,i=n.x,o=r.filterSize,s=r.strides,u=r.pad,c=r.dimRoundingMode;return vn(i,t.backend_util.computePool2DInfo(i.shape,o,s,1,u,c),"max",a)}};var jr={kernelName:t.Min,backendName:"webgpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,a=e.attrs;return qt(t.x,a.axis,a.keepDims,"min",n)}},qr=ze({opType:M.MIN,cpuKernelImpl:vt}),Yr={kernelName:t.Minimum,backendName:"webgpu",kernelFunc:qr},Qr=function(){function e(e,t,n){var a=this;this.uniforms="",this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.map((function(t,n){return t[0]+e[n]+t[1]})),this.dispatchLayout=U(this.outputShape),this.dispatch=F(this.dispatchLayout,this.outputShape,this.workgroupSize),this.xShape=e,t.map((function(e,t){a.uniforms+=" pad".concat(t," : vec2<i32>,")})),this.offset="reflect"===n?0:1,this.shaderKey="mirrorPad_".concat(n)}return e.prototype.getUserCode=function(){var e=this.xShape.length,t=this.xShape.map((function(e,t){return"uniforms.pad".concat(t,"[0]")})).join(","),n=this.xShape.map((function(t,n){return"uniforms.pad".concat(n,"[0] + uniforms.xShape").concat(e>1?"[".concat(n,"]"):"")})).join(","),a=1===e?"start":"start[i]",r=1===e?"end":"end[i]",i=1===e?"outC":"outC[i]",o=y(e),s=e>1?["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,e):"coords";return"\n      ".concat(k("index")," {\n        if (index < uniforms.size) {\n          let start = ").concat(o,"(").concat(t,");\n          let end = ").concat(o,"(").concat(n,");\n          var outC = getCoordsFromIndex(index);\n          for (var i = 0; i < ").concat(e,"; i = i + 1) {\n            if (").concat(i," < ").concat(a,") {\n              ").concat(i," = ").concat(a," * 2 - ").concat(i," - ").concat(this.offset,";\n            } else if(").concat(i," >= ").concat(r,") {\n              ").concat(i," = (").concat(r," - 1) * 2 - ").concat(i," + ").concat(this.offset,";\n            }\n          }\n          let coords = outC - start;\n          setOutputAtIndex(index, getX(").concat(s,"));\n        }\n      }\n    ")},e}(),Zr={kernelName:t.MirrorPad,backendName:"webgpu",kernelFunc:function(e){var t=e.inputs,n=e.attrs,a=e.backend,r=t.x,i=n.paddings,o=n.mode,s=a,u=i.map((function(e){return{type:"int32",data:[e[0],e[1]]}})),c=new Qr(r.shape,i,o);return s.runWebGPUProgram(c,[r],r.dtype,u)}},Jr=ze({opType:M.MOD}),$r={kernelName:t.Mod,backendName:"webgpu",kernelFunc:Jr};var ei={kernelName:t.Neg,backendName:"webgpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,a=t.x;if(n.shouldExecuteOnCPU([a])){var r=n.tensorMap.get(a.dataId),i=u(xt(r.values,a.shape,a.dtype),2),o=i[0],s=i[1];return n.makeTensorInfo(s,a.dtype,o)}var c=new Pe(a.shape,K.NEG);return n.runWebGPUProgram(c,[a],a.dtype)}};var ti={kernelName:t.NonMaxSuppressionV3,backendName:"webgpu",kernelFunc:function(e){console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");var n=e.inputs,a=e.backend,r=e.attrs,i=n.boxes,o=n.scores,s=r.maxOutputSize,u=r.iouThreshold,c=r.scoreThreshold,d=a.readSync(i.dataId),l=a.readSync(o.dataId),h=t.kernel_impls.nonMaxSuppressionV3Impl(d,l,s,u,c).selectedIndices;return a.makeTensorInfo([h.length],"int32",new Int32Array(h))}};var ni={kernelName:t.NonMaxSuppressionV5,backendName:"webgpu",kernelFunc:function(e){console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");var n=e.inputs,a=e.backend,r=e.attrs,i=n.boxes,o=n.scores,s=r.maxOutputSize,u=r.iouThreshold,c=r.scoreThreshold,d=r.softNmsSigma,l=a.readSync(i.dataId),h=a.readSync(o.dataId),p=s,f=u,m=c,g=d,v=t.kernel_impls.nonMaxSuppressionV5Impl(l,h,p,f,m,g),b=v.selectedIndices,x=v.selectedScores;return[a.makeTensorInfo([b.length],"int32",new Int32Array(b)),a.makeTensorInfo([x.length],"float32",new Float32Array(x))]}},ai=function(){function e(e,t){this.variableNames=["x"],this.uniforms="onValue : f32, offValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e,t],this.dispatchLayout=U(this.outputShape),this.dispatch=F(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="onehot"}return e.prototype.getUserCode=function(){return"\n      ".concat(k("index")," {\n        if(index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          setOutputAtIndex(index, mix(uniforms.offValue, uniforms.onValue,\n                                      f32(i32(round(getX(coords.x))) == coords.y)));\n        }\n      }\n    ")},e}();var ri={kernelName:t.OneHot,backendName:"webgpu",kernelFunc:function(e){var n=e.inputs,a=e.backend,r=e.attrs,i=n.indices,o=r.dtype,s=r.depth,d=r.onValue,l=r.offValue,h=t.util.sizeFromShape(i.shape),p=new ai(h,s),f=xe({inputs:{x:i},backend:a,attrs:{shape:[h]}}),m=[{type:"float32",data:[d]},{type:"float32",data:[l]}],g=a.runWebGPUProgram(p,[f],o,m);a.disposeData(f.dataId);var v=xe({inputs:{x:g},backend:a,attrs:{shape:c(c([],u(i.shape),!1),[s],!1)}});return a.disposeData(g.dataId),v}};function ii(e){var t=e.inputs,n=e.backend,a=t.x;if("complex64"===a.dtype){var r=_n({inputs:{input:a},backend:n}),i=ii({inputs:{x:r},backend:n}),o=Mn({inputs:{input:a},backend:n}),s=ii({inputs:{x:o},backend:n}),u=Re({inputs:{real:i,imag:s},backend:n});return n.disposeData(r.dataId),n.disposeData(i.dataId),n.disposeData(o.dataId),n.disposeData(s.dataId),u}return ve({attrs:{shape:a.shape,dtype:a.dtype,value:"string"===a.dtype?"":0},backend:n})}var oi={kernelName:t.ZerosLike,backendName:"webgpu",kernelFunc:ii};var si={kernelName:t.OnesLike,backendName:"webgpu",kernelFunc:function e(t){var n=t.inputs,a=t.backend,r=n.x;if("string"===r.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===r.dtype){var i=_n({inputs:{input:r},backend:a}),o=e({inputs:{x:i},backend:a}),s=Mn({inputs:{input:r},backend:a}),u=ii({inputs:{x:s},backend:a}),c=Re({inputs:{real:o,imag:u},backend:a});return a.disposeData(i.dataId),a.disposeData(o.dataId),a.disposeData(s.dataId),a.disposeData(u.dataId),c}return ve({attrs:{shape:r.shape,dtype:r.dtype,value:1},backend:a})}};var ui={kernelName:t.Pack,backendName:"webgpu",kernelFunc:function(e){var n=e.inputs,a=e.backend,r=e.attrs.axis;if(1===n.length)return Wa({inputs:{input:n[0]},backend:a,attrs:{dim:r}});var i=n[0].shape,o=n[0].dtype;n.forEach((function(e){t.util.assertShapesMatch(i,e.shape,"All tensors passed to stack must have matching shapes"),t.util.assert(o===e.dtype,(function(){return"All tensors passed to stack must have matching dtypes"}))}));var s=[],u=Hn({inputs:n.map((function(e){var t=Wa({inputs:{input:e},backend:a,attrs:{dim:r}});return s.push(t),t})),backend:a,attrs:{axis:r}});return s.forEach((function(e){return a.disposeData(e.dataId)})),u}},ci=function(){function e(e,t){var n=this;this.variableNames=["x"],this.uniforms="constantValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.map((function(t,n){return t[0]+e[n]+t[1]})),this.dispatchLayout=U(this.outputShape),this.dispatch=F(this.dispatchLayout,this.outputShape,this.workgroupSize),t.map((function(e,t){n.uniforms+=" pad".concat(t," : vec2<i32>,")})),this.xShape=e,this.shaderKey="pad"}return e.prototype.getUserCode=function(){var e=this.xShape.length,t=y(e),n=this.xShape.map((function(e,t){return"uniforms.pad".concat(t,"[0]")})).join(","),a=this.xShape.map((function(t,n){return"uniforms.pad".concat(n,"[0] + uniforms.xShape").concat(e>1?"[".concat(n,"]"):"")})).join(","),r=e>1?"".concat(t,"(").concat(n,")"):"".concat(n),i=e>1?"".concat(t,"(").concat(a,")"):"".concat(a),o=e>1?"any(outC < start)":"outC < start",s=e>1?"any(outC >= end)":"outC >= end",u=e>1?["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,e):"coords";return"\n      ".concat(k("index")," {\n        if (index < uniforms.size) {\n          let start = ").concat(r,";\n          let end = ").concat(i,";\n          let outC = getCoordsFromIndex(index);\n\n          if (").concat(o," || ").concat(s,") {\n            setOutputAtIndex(index, uniforms.constantValue);\n          } else {\n            let coords = outC - start;\n            setOutputAtIndex(index, getX(").concat(u,"));\n          }\n        }\n      }\n    ")},e}(),di=function(e){var n=e.inputs,a=e.backend,r=e.attrs,i=n.x,o=r.paddings,s=r.constantValue;if(o.every((function(e){return t.util.arraysEqual(e,[0,0])})))return Ce({inputs:{x:i},backend:a});if(0===t.util.sizeFromShape(i.shape))return ve({backend:a,attrs:{shape:o.map((function(e,t){return e[0]+i.shape[t]+e[1]})),value:s,dtype:i.dtype}});var u=[{type:"float32",data:[s]}];o.map((function(e){return u.push({type:"int32",data:[e[0],e[1]]})}));var c=new ci(i.shape,o);return a.runWebGPUProgram(c,[i],i.dtype,u)},li={kernelName:t.PadV2,backendName:"webgpu",kernelFunc:di},hi=ze({opType:M.POW}),pi={kernelName:t.Pow,backendName:"webgpu",kernelFunc:hi};var fi={kernelName:t.Prelu,backendName:"webgpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,a=t.x,r=t.alpha,i=new Ie(M.PRELU,a.shape,r.shape);return n.runWebGPUProgram(i,[a,r],"float32")}};var mi={kernelName:t.Prod,backendName:"webgpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,a=e.attrs;return qt(t.x,a.axis,a.keepDims,"prod",n)}},gi={kernelName:t.Range,backendName:"webgpu",kernelFunc:function(e){var t=e.backend,n=e.attrs,a=n.start,r=n.stop,i=n.step,o=n.dtype,s=kt(a,r,i,o);return t.makeTensorInfo([s.length],o,s)}},vi=ze({opType:M.DIV}),bi={kernelName:t.RealDiv,backendName:"webgpu",kernelFunc:vi},xi=Te({opType:K.RECIPROCAL}),yi={kernelName:t.Reciprocal,backendName:"webgpu",kernelFunc:xi},wi=Te({opType:K.RELU}),ki={kernelName:t.Relu,backendName:"webgpu",kernelFunc:wi},Si=Te({opType:K.RELU6}),Ii={kernelName:t.Relu6,backendName:"webgpu",kernelFunc:Si},Ci=function(){function e(e,t,n){this.variableNames=["x"],this.uniforms="adjustHeightWidth : vec2<f32>, halfPixelCenters : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e[0],t,n,e[3]],this.dispatchLayout=U(this.outputShape),this.dispatch=F(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="resizeBilinear"}return e.prototype.getUserCode=function(){return"\n      ".concat(k("index")," {\n        if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n          let b = coords[0];\n          let d = coords[3];\n          let rc = coords.yz;\n\n          let effectiveInSize = vec2<f32>(\n            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],\n            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);\n\n          let effectiveOutSize = vec2<f32>(\n            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],\n            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);\n\n          let effectiveInputOverOutputRatioRC =\n              effectiveInSize / effectiveOutSize;\n\n          // Fractional source index\n          let sourceFracIndexRC =\n            (vec2<f32>(rc) + vec2<f32>(uniforms.halfPixelCenters)) *\n            effectiveInputOverOutputRatioRC - vec2<f32>(uniforms.halfPixelCenters);\n\n          // Compute the four integer indices.\n          let sourceFloorRC = vec2<i32>(sourceFracIndexRC);\n          let sourceCeilRC = vec2<i32>(\n            min(vec2<f32>(uniforms.xShape.yz) - vec2<f32>(1.0), ceil(sourceFracIndexRC)));\n\n          let topLeft = getX(b, sourceFloorRC.x, sourceFloorRC.y, d);\n          let bottomLeft = getX(b, sourceCeilRC.x, sourceFloorRC.y, d);\n          let topRight = getX(b, sourceFloorRC.x, sourceCeilRC.y, d);\n          let bottomRight = getX(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n          let fracRC = sourceFracIndexRC - vec2<f32>(sourceFloorRC);\n\n          let top = topLeft + (topRight - topLeft) * fracRC.y;\n          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n          let newValue = top + (bottom - top) * fracRC.x;\n\n          setOutputAtIndex(index, newValue);\n        }\n      }\n    ")},e}();var Ai={kernelName:t.ResizeBilinear,backendName:"webgpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,a=e.attrs,r=t.images,i=a.alignCorners,o=a.size,s=a.halfPixelCenters,c=u(o,2),d=c[0],l=c[1],h=[{type:"float32",data:[i&&d>1?1:0,i&&l>1?1:0]},{type:"float32",data:[s?.5:0]}],p=new Ci(r.shape,d,l);return n.runWebGPUProgram(p,[r],"float32",h)}},Ri=function(){function e(e,t,n,a){this.variableNames=["x"],this.uniforms="adjustHeightWidth : vec2<f32>, roundBase : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e[0],t,n,e[3]],this.dispatchLayout=U(this.outputShape),this.dispatch=F(this.dispatchLayout,this.outputShape,this.workgroupSize),this.halfPixelCenters=a,this.shaderKey="resizeNearest_".concat(a)}return e.prototype.getUserCode=function(){var e;return e=this.halfPixelCenters?"max((vec2<f32>(rc) + vec2<f32>(0.5)) * effectiveInputOverOutputRatioRC, vec2<f32>(0.0))":"vec2<f32>(rc) * effectiveInputOverOutputRatioRC","\n      ".concat(k("index")," {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let b = coords[0];\n          let d = coords[3];\n          let rc = coords.yz;\n\n          let effectiveInSize = vec2<f32>(\n            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],\n            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);\n\n          let effectiveOutSize = vec2<f32>(\n            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],\n            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);\n\n          let effectiveInputOverOutputRatioRC =\n              effectiveInSize / effectiveOutSize;\n\n          // Fractional source index\n          let sourceFracIndexRC = ").concat(e,";\n\n          // Compute the coordinators of nearest neighbor point.\n          let inputShapeRC = vec2<f32>(f32(uniforms.xShape.y), f32(uniforms.xShape.z));\n          let sourceNearestRC = vec2<i32>(\n            min(inputShapeRC - 1.0, floor(sourceFracIndexRC + uniforms.roundBase)));\n          let newValue = getX(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n          setOutputAtIndex(index, newValue);\n        }\n      }\n    ")},e}();var Ni={kernelName:t.ResizeNearestNeighbor,backendName:"webgpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,a=e.attrs,r=t.images,i=a.alignCorners,o=a.halfPixelCenters,s=u(a.size,2),c=s[0],d=s[1],l=[{type:"float32",data:[i&&c>1?1:0,i&&d>1?1:0]},{type:"float32",data:[i?.5:0]}],h=new Ri(r.shape,c,d,o);return n.runWebGPUProgram(h,[r],r.dtype,l)}},Pi=function(){function e(e){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=U(this.outputShape),this.dispatch=F(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms=" axis : vec4<i32>,",this.shaderKey="reverse"}return e.prototype.getUserCode=function(){return"\n      ".concat("\n      // Using uniform variables as judging conditions, so the function has\n      // coherent execution within all threads.\n      fn getReverseCoords(coords : vec4<i32>) -> vec4<i32> {\n        var reverseCoords = coords;\n        if (uniforms.axis[0] == 1) {\n          reverseCoords[0] = uniforms.xShape[0] - coords[0] - 1;\n        }\n        if (uniforms.axis[1] == 1) {\n          reverseCoords[1] = uniforms.xShape[1] - coords[1] - 1;\n        }\n        if (uniforms.axis[2] == 1) {\n          reverseCoords[2] = uniforms.xShape[2] - coords[2] - 1;\n        }\n        if (uniforms.axis[3] == 1) {\n          reverseCoords[3] = uniforms.xShape[3] - coords[3] - 1;\n        }\n\n        return reverseCoords;\n      }\n    ","\n      ").concat(k("index")," {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let reverseCoords = getReverseCoords(coords);\n          setOutputAtIndex(index, getX(reverseCoords[0],\n              reverseCoords[1], reverseCoords[2], reverseCoords[3]));\n        }\n      }\n    ")},e}();var Ti={kernelName:t.Reverse,backendName:"webgpu",kernelFunc:function(e){var n=e.inputs,a=e.backend,r=e.attrs,i=n.x,o=r.dims,s=i.shape.length;if(0===s)return Ce({inputs:{x:i},backend:a});var u=i.shape,c=[1,1,1,1];u.forEach((function(e,t){c[t+4-s]=e}));var d=t.util.parseAxisParam(o,i.shape),l=[0,0,0,0];d.forEach((function(e){l[e+4-s]=1}));var h=[{type:"int32",data:l}],p=xe({inputs:{x:i},backend:a,attrs:{shape:c}}),f=new Pi(c),m=a.runWebGPUProgram(f,[p],p.dtype,h);a.disposeData(p.dataId);var g=xe({inputs:{x:m},backend:a,attrs:{shape:u}});return a.disposeData(m.dataId),g}},zi=function(){function e(e,t){this.outputShape=[],this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=U(this.outputShape),this.dispatch=F(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms="centerX : f32, centerY : f32, sinRadians : f32,\n          cosRadians : f32,",this.shaderKey="rotate",this.outputShape=e,"number"==typeof t?(this.uniforms+=" fillValue : f32,",this.fillSnippet="var outputValue = uniforms.fillValue;",this.shaderKey+="_float"):(this.uniforms+=" fillValue : vec3<f32>,",this.fillSnippet="var outputValue = uniforms.fillValue[coords[3]];",this.shaderKey+="_vec3")}return e.prototype.getUserCode=function(){return"\n        ".concat(k("index")," {\n          if (index < uniforms.size) {\n            let coords = getCoordsFromIndex(index);\n            let coordXFloat = (f32(coords[2]) - uniforms.centerX) *\n                uniforms.cosRadians - (f32(coords[1]) - uniforms.centerY) *\n                uniforms.sinRadians;\n            let coordYFloat = (f32(coords[2]) - uniforms.centerX) *\n                uniforms.sinRadians + (f32(coords[1]) - uniforms.centerY) *\n                uniforms.cosRadians;\n            let coordX = i32(round(coordXFloat + uniforms.centerX));\n            let coordY = i32(round(coordYFloat + uniforms.centerY));\n            ").concat(this.fillSnippet,"\n            if(coordX >= 0 && coordX < uniforms.xShape[2] && coordY >= 0 &&\n                coordY < uniforms.xShape[1]) {\n              outputValue = getX(coords[0], coordY, coordX, coords[3]);\n            }\n            setOutputAtIndex(index, outputValue);\n          }\n        }\n      ")},e}(),_i={kernelName:t.RotateWithOffset,backendName:"webgpu",kernelFunc:function(e){var n=e.inputs,a=e.attrs,r=e.backend,i=n.image,o=a.radians,s=a.fillValue,c=a.center,d=r,l=new zi(i.shape,s),h=u(t.backend_util.getImageCenter(c,i.shape[1],i.shape[2]),2),p=[{type:"float32",data:[h[0]]},{type:"float32",data:[h[1]]},{type:"float32",data:[Math.sin(o)]},{type:"float32",data:[Math.cos(o)]}];return"number"==typeof s?p.push({type:"float32",data:[Number.parseFloat(s.toFixed(2))]}):p.push({type:"float32",data:s}),d.runWebGPUProgram(l,[i],i.dtype,p)}},Fi=Te({opType:K.ROUND}),Bi={kernelName:t.Round,backendName:"webgpu",kernelFunc:Fi},Ei=Te({opType:K.RSQRT,cpuKernelImpl:St}),Li={kernelName:t.Rsqrt,backendName:"webgpu",kernelFunc:Ei},Ui=function(){function e(e,t,n,a,r,i,o,s){void 0===s&&(s=!0),this.variableNames=["updates","indices"],this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=i,this.type=o,this.sumDupeIndices=s,this.dispatchLayout=U(e),this.dispatch=F(this.dispatchLayout,e,this.workgroupSize),this.sliceDimGreaterThanOne=t>1,this.shaderKey="scatter_".concat(n,"_").concat(a,"_").concat(this.sliceDimGreaterThanOne,"_").concat(o,"_").concat(s);var u=y(r.length);this.uniforms="sliceDim : i32, strides: ".concat(u,", updatesSize: i32,"),this.updatesRank=a,this.indicesRank=n}return e.prototype.getUserCode=function(){var e="";1===this.indicesRank?e="coords[0]":2===this.indicesRank&&(e="coords[0], j");var t="getIndices(".concat(e,")"),n=this.sliceDimGreaterThanOne?"uniforms.strides[j]":"uniforms.strides",a="",r="";1===this.dispatchLayout.x.length?(a="flattenedIndex",r="\n      fn getUpdatesCoordsFromFlatIndex(index : i32) -> i32 {\n        return index;\n      }\n      "):2===this.dispatchLayout.x.length&&(a="vec2<i32>(flattenedIndex, coords[1])",r="\n      fn getUpdatesCoordsFromFlatIndex(index : i32) -> vec2<i32> {\n        // N.B. |updates| could be a scalar tensor, conceptually representing a\n        // 2D tensor with all values equal to that. By design, its size must be\n        // the same as |outShape[1]| in one dimension, and |indicesShape[0]|\n        // gives the other.\n        let sliceSize = uniforms.outShape[1];\n        let d0 = index / sliceSize;\n        let d1 = index - d0 * sliceSize;\n        return vec2<i32>(d0, d1);\n      }\n      ");var i=Array.from({length:this.updatesRank},(function(e,t){return"coords[".concat(t,"]")})),o="getUpdates(".concat(i.join(", "),")");return"\n    ".concat(r,"\n      ").concat(k("index")," {\n        if (index < uniforms.updatesSize) {\n          let coords = getUpdatesCoordsFromFlatIndex(index);\n          var flattenedIndex = 0;\n          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {\n            let indexInside = i32(round(").concat(t,"));\n            flattenedIndex = flattenedIndex + indexInside * ").concat(n,";\n          }\n          let updateValue =\n              ").concat(P(this.type,!1),"(").concat(o,");\n          let flatIndex = getOutputIndexFromCoords(").concat(a,");\n\n          ").concat(this.sumDupeIndices?b("&result[flatIndex]","updateValue",this.type):"atomicStore(&result[flatIndex], bitcast<i32>(updateValue));","\n        }\n      }")},e}();var Oi={kernelName:t.ScatterNd,backendName:"webgpu",kernelFunc:function(e){var n=e.inputs,a=e.backend,r=e.attrs,i=n.indices,o=n.updates,s=r.shape,u=t.backend_util.calculateShapes(o,i,s),c=u.sliceRank,d=u.numUpdates,l=u.sliceSize,h=u.strides,p=u.outputSize,f=[p/l,l];if(0===p)return a.makeTensorInfo(s,i.dtype);var m=xe({inputs:{x:i},backend:a,attrs:{shape:[d,c]}}),g=xe({inputs:{x:o},backend:a,attrs:{shape:[d,l]}}),v=g.dtype,b=ve({backend:a,attrs:{shape:f,value:0,dtype:v}}),x=[{type:"int32",data:[c]},{type:"int32",data:h},{type:"int32",data:[t.util.sizeFromShape(g.shape)]}],y=new Ui(g.shape,c,m.shape.length,g.shape.length,h,f,v),w=a.runWebGPUProgram(y,[g,m],v,x,b),k=xe({inputs:{x:w},backend:a,attrs:{shape:s}});return a.disposeData(m.dataId),a.disposeData(g.dataId),a.disposeData(w.dataId),k}},Di=function(){function e(e,t){this.outputShape=[],this.variableNames=["sortedSequence","values"],this.uniforms="numInputs : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=U(this.outputShape),this.dispatch=F(this.dispatchLayout,this.outputShape,this.workgroupSize),this.side=t,this.shaderKey="search_sorted_".concat(t)}return e.prototype.getUserCode=function(){var e="left"===this.side?"<":"<=";return"\n      fn findBound(batch: i32, value: f32) -> i32 {\n        var left = i32(0);\n        var right = uniforms.numInputs;\n        while (left < right) {\n          var mid = (left + right) / 2;\n          if (getSortedSequence(batch, mid) ".concat(e," value) {\n            left = mid + 1;\n          } else {\n            right = mid;\n          }\n        }\n        return right;\n      }\n\n      ").concat(k("index")," {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let value = getValuesByOutputIndex(index);\n          setOutputAtIndexI32(index, findBound(coords[0], value));\n        }\n      }\n    ")},e}();var Wi={kernelName:t.SearchSorted,backendName:"webgpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,a=e.attrs,r=t.sortedSequence,i=t.values,o=a.side,s=new Di([i.shape[0],i.shape[1]],o),u=[{type:"int32",data:[r.shape[1]]}];return n.runWebGPUProgram(s,[r,i],"int32",u)}},Mi=function(){function e(e,t,n){this.variableNames=["c","a","b"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=U(this.outputShape),this.dispatch=F(this.dispatchLayout,this.outputShape,this.workgroupSize),this.cRank=e,this.rank=n,this.shaderKey="select"}return e.prototype.getUserCode=function(){var e,t;if(this.rank>4)throw Error("Where for rank ".concat(this.rank," is not yet supported"));if(1===this.rank)t="resRC",e="resRC";else{for(var n=["resRC.x","resRC.y","resRC.z","resRC.w"],a=[],r=[],i=0;i<this.outputShape.length;i++)r.push("".concat(n[i])),i<this.cRank&&a.push("".concat(n[i]));e=a.join(),t=r.join()}return"\n      ".concat(k("index")," {\n        if (index < uniforms.size) {\n          let resRC = getCoordsFromIndex(index);\n          let cVal = getC(").concat(e,");\n          if (cVal >= 1.0) {\n            setOutputAtIndex(index, getA(").concat(t,"));\n          } else {\n            setOutputAtIndex(index, getB(").concat(t,"));\n          }\n        }\n      }\n    ")},e}();var Vi={kernelName:t.Select,backendName:"webgpu",kernelFunc:function(e){var n=e.inputs,a=e.backend,r=n.condition,i=n.t,o=n.e,s=new Mi(r.shape.length,i.shape,i.shape.length);return a.runWebGPUProgram(s,[r,i,o],t.upcastType(i.dtype,o.dtype))}},Gi=Te({opType:K.SELU}),Hi={kernelName:t.Selu,backendName:"webgpu",kernelFunc:Gi},Ki=Te({opType:K.SIGMOID}),Xi={kernelName:t.Sigmoid,backendName:"webgpu",kernelFunc:Ki},ji=Te({opType:K.SIGN}),qi={kernelName:t.Sign,backendName:"webgpu",kernelFunc:ji},Yi=Te({opType:K.SIN}),Qi={kernelName:t.Sin,backendName:"webgpu",kernelFunc:Yi},Zi=Te({opType:K.SINH}),Ji={kernelName:t.Sinh,backendName:"webgpu",kernelFunc:Zi},$i=ze({opType:M.SUB,cpuKernelImpl:Pt,supportsComplex:!0}),eo={kernelName:t.Sub,backendName:"webgpu",kernelFunc:$i};var to={kernelName:t.Softmax,backendName:"webgpu",kernelFunc:function(e){var n=e.inputs,a=e.backend,r=e.attrs,i=n.logits,o=r.dim,s=t.util.parseAxisParam([o],i.shape),u=pn({inputs:{x:i},backend:a,attrs:{reductionIndices:s,keepDims:!1}}),c=t.backend_util.expandShapeToKeepDim(u.shape,s),d=xe({inputs:{x:u},backend:a,attrs:{shape:c}}),l=$i({inputs:{a:i,b:d},backend:a}),h=Oa({inputs:{x:l},backend:a}),p=Pa({inputs:{x:h},backend:a,attrs:{axis:s,keepDims:!1}}),f=xe({inputs:{x:p},backend:a,attrs:{shape:c}}),m=vi({inputs:{a:h,b:f},backend:a});return a.disposeData(u.dataId),a.disposeData(d.dataId),a.disposeData(l.dataId),a.disposeData(h.dataId),a.disposeData(p.dataId),a.disposeData(f.dataId),m}},no=Te({opType:K.SOFTPLUS}),ao={kernelName:t.Softplus,backendName:"webgpu",kernelFunc:no},ro={kernelName:t.SpaceToBatchND,backendName:"webgpu",kernelFunc:function(e){var n=e.inputs,a=e.backend,r=e.attrs,i=n.x,o=r.blockShape,s=r.paddings;t.util.assert(i.shape.length<=4,(function(){return"spaceToBatchND for rank > 4 with a WebGPU backend not implemented yet"}));var d=o.reduce((function(e,t){return e*t})),l=[[0,0]];l.push.apply(l,c([],u(s),!1));for(var h=1+o.length;h<i.shape.length;++h)l.push([0,0]);var p=[],f=di({inputs:{x:i},backend:a,attrs:{paddings:l,constantValue:0}}),m=t.backend_util.getReshaped(f.shape,o,d,!1),g=t.backend_util.getPermuted(m.length,o.length,!1),v=t.backend_util.getReshapedPermuted(f.shape,o,d,!1),b=xe({inputs:{x:f},backend:a,attrs:{shape:m}}),x=Kt({inputs:{x:b},backend:a,attrs:{perm:g}}),y=xe({inputs:{x:x},backend:a,attrs:{shape:v}});return p.push(f),p.push(b),p.push(x),p.forEach((function(e){return a.disposeData(e.dataId)})),y}},io=function(){function e(e,t){this.variableNames=["A"],this.workgroupSize=[64,1,1],this.size=!0;for(var n=new Array(e.length),a=0;a<n.length;a++)n[a]=e[a]*t[a];this.outputShape=n,this.dispatchLayout=U(this.outputShape),this.dispatch=F(this.dispatchLayout,this.outputShape,this.workgroupSize),this.rank=this.outputShape.length,this.shaderKey="tile"}return e.prototype.getUserCode=function(){var e=function(e,t){void 0===t&&(t="");if(e>=5)throw Error("Tile for rank ".concat(e," is not yet supported"));if(1===e)return"(resRC % ".concat(t,"aShape)");for(var n=["resRC.x","resRC.y","resRC.z","resRC.w"],a=[],r=0;r<e;r++)a.push("(".concat(n[r]," % ").concat(t,"aShape[").concat(r,"])"));return a.join()}(this.rank,"uniforms.");return"\n      ".concat(k("index")," {\n        if (index < uniforms.size) {\n          let resRC = getCoordsFromIndex(index);\n          setOutputAtIndex(index, getA(").concat(e,"));\n        }\n      }\n    ")},e}();function oo(e){var n=e.inputs,a=e.backend,r=e.attrs,i=n.x,o=r.reps;if(a.shouldExecuteOnCPU([i])||"string"===i.dtype||i.shape.length>=5){var s=a.readSync(i.dataId),u="string"===i.dtype?s.map((function(e){return t.util.decodeString(e)})):s,c=t.buffer(i.shape,i.dtype,u),d=Tt(c,o);return a.makeTensorInfo(d.shape,d.dtype,d.values)}var l=new io(i.shape,o);return a.runWebGPUProgram(l,[i],i.dtype)}var so={kernelName:t.Tile,backendName:"webgpu",kernelFunc:oo};var uo={kernelName:t.SparseToDense,backendName:"webgpu",kernelFunc:function(e){var n=e.inputs,a=e.backend,r=e.attrs,i=n.sparseIndices,o=n.sparseValues,s=n.defaultValue,u=r.outputShape,c=t.backend_util.calculateShapes(o,i,u),d=c.sliceRank,l=c.numUpdates,h=c.sliceSize,p=c.strides,f=c.outputSize,m=!1;if("string"===o.dtype){var g=a.bufferSync(i),v=a.bufferSync(o),b=t.util.decodeString(a.readSync(s.dataId)[0]),x=It(g,v,u,f,h,l,d,p,b,m);return a.makeTensorInfo(u,x.dtype,x.values)}var y=[f/h,h],w=xe({inputs:{x:i},backend:a,attrs:{shape:[l,d]}}),k=o.shape.length?xe({inputs:{x:o},backend:a,attrs:{shape:[l,h]}}):Ce({inputs:{x:o},backend:a}),S=k.dtype,I=a.makeTensorInfo([],S,t.util.makeZerosTypedArray(1,S)),C=xe({inputs:{x:s},backend:a,attrs:{shape:Array(y.length).fill(1)}}),A=oo({inputs:{x:C},backend:a,attrs:{reps:y}}),R=[{type:"int32",data:[d]},{type:"int32",data:p},{type:"int32",data:[t.util.sizeFromShape([l,h])]}];switch(l){case 0:break;case 1:var N=new Ui([l,h],d,w.shape.length,k.shape.length,p,y,S,m);a.runWebGPUProgram(N,[k,w],S,R,A);break;default:N=new Ui([l,h],d,w.shape.length,I.shape.length,p,y,S,m);a.runWebGPUProgram(N,[I,w],S,R,A);N=new Ui([l,h],d,w.shape.length,k.shape.length,p,y,S);a.runWebGPUProgram(N,[k,w],S,R,A)}var P=xe({inputs:{x:A},backend:a,attrs:{shape:u}});return a.disposeData(w.dataId),a.disposeData(k.dataId),a.disposeData(C.dataId),a.disposeData(I.dataId),a.disposeData(A.dataId),P}};var co={kernelName:t.SplitV,backendName:"webgpu",kernelFunc:function(e){var n=e.inputs,a=e.backend,r=e.attrs,i=n.x,o=r.numOrSizeSplits,s=r.axis,d=t.util.parseAxisParam(s,i.shape)[0],l=t.backend_util.prepareSplitSize(i,o,d),h=i.shape.length,p=new Array(h).fill(0),f=i.shape.slice();return l.map((function(e){var t=c([],u(f),!1);t[d]=e;var n=In({inputs:{x:i},backend:a,attrs:{begin:p,size:t}});return p[d]+=e,n}))}},lo=Te({opType:K.SQRT}),ho={kernelName:t.Sqrt,backendName:"webgpu",kernelFunc:lo},po={kernelName:t.Square,backendName:"webgpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,a=t.x,r=n,i=new Pe(a.shape,K.SQUARE);return r.runWebGPUProgram(i,[a],a.dtype)}},fo=ze({opType:M.SQUARED_DIFFERENCE}),mo={kernelName:t.SquaredDifference,backendName:"webgpu",kernelFunc:fo};var go={kernelName:t.Step,backendName:"webgpu",kernelFunc:function(e){var t=e.inputs,n=e.attrs,a=e.backend,r=t.x,i=new Pe(r.shape,K.STEP,"stepAlpha : f32,"),o=[{type:"float32",data:[n.alpha]}];return a.runWebGPUProgram(i,[r],r.dtype,o)}},vo=function(){function e(e){this.variableNames=["x"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=U(this.outputShape),this.dispatch=F(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]);var t=y(this.outputShape.length);this.uniforms="begin : ".concat(t,",  strides : ").concat(t,", "),this.shaderKey="stridedSlice"}return e.prototype.getUserCode=function(){var e=this,t="";if(1===this.outputShape.length)t="coords * uniforms.strides + uniforms.begin";else{var n=0;t=this.outputShape.map((function(t,a){return n++,1===e.outputShape.length?"coords * uniforms.strides[".concat(a,"] + uniforms.begin[").concat(a,"]"):"coords[".concat(n-1,"] * uniforms.strides[").concat(a,"] + uniforms.begin[").concat(a,"]")})).join(",")}return"\n       ".concat(k("index")," {\n         if (index < uniforms.size) {\n           let coords = getCoordsFromIndex(index);\n           setOutputAtIndex(index, getX(").concat(t,"));\n         }\n       }\n     ")},e}();var bo={kernelName:t.StridedSlice,backendName:"webgpu",kernelFunc:function(e){var n,a=e.inputs,r=e.backend,i=e.attrs,o=a.x,s=i.begin,u=i.end,c=i.strides,d=i.beginMask,l=i.endMask,h=i.ellipsisMask,p=i.newAxisMask,f=i.shrinkAxisMask,m=t.slice_util.sliceInfo(o.shape,s,u,c,d,l,h,p,f),g=m.finalShapeSparse,v=m.finalShape,b=m.isIdentity,x=m.sliceDim0,y=m.isSimpleSlice,w=m.begin,k=m.end,S=m.strides;if(b)n=xe({inputs:{x:o},backend:r,attrs:{shape:v}});else if(x||y){t.util.assert(o.shape.length>=1,(function(){return"Input must have rank at least 1, got: ".concat(o.shape.length)}));var I=t.slice_util.computeOutShape(w,k,S),C=In({inputs:{x:o},backend:r,attrs:{begin:w,size:I}});n=xe({inputs:{x:C},backend:r,attrs:{shape:v}}),r.disposeData(C.dataId)}else{if(r.shouldExecuteOnCPU([o])){var A=r.readSync(o.dataId),R=t.buffer(o.shape,o.dtype,A),N=Rt(g,R,S,w);n=r.makeTensorInfo(v,o.dtype,N.values)}else{var P=new vo(g),T=[{type:"int32",data:w},{type:"int32",data:S}];n=xe({inputs:{x:N=r.runWebGPUProgram(P,[o],o.dtype,T)},backend:r,attrs:{shape:v}}),r.disposeData(N.dataId)}}return n}};var xo={kernelName:t.StringNGrams,backendName:"webgpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,a=e.attrs,r=a.separator,i=a.nGramWidths,o=a.leftPad,s=a.rightPad,c=a.padWidth,d=a.preserveShortSequences,l=t.data,h=t.dataSplits,p=n.readSync(l.dataId),f=n.readSync(h.dataId),m=u(Nt(p,f,r,i,o,s,c,d),2),g=m[0],v=m[1];return[n.makeTensorInfo([g.length],"string",g),n.makeTensorInfo(h.shape,"int32",v)]}},yo=Te({opType:K.TAN}),wo={kernelName:t.Tan,backendName:"webgpu",kernelFunc:yo},ko=Te({opType:K.TANH}),So={kernelName:t.Tanh,backendName:"webgpu",kernelFunc:ko},Io=function(){function e(e){this.variableNames=["x","indices"],this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=U(this.outputShape),this.dispatch=F(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms="inputSize : i32, firstPass : i32, negativeInf : f32,\n        dir : i32, inc : i32,",this.shaderKey="swap"}return e.prototype.getUserCode=function(){return"\n        ".concat(k("index")," {\n          if (index < uniforms.size) {\n            let outC = getCoordsFromIndex(index);\n            let batch = outC[0];\n            let elemIdx = outC[1];\n            // We compare elements pair-wise within a group of size 2 * inc.\n            // The comparing rule for each group alternates between ascending\n            // and descending. Within each group, we compare each pair at\n            // positions i and i+inc. To decide whether an element at position i\n            // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n            // inc, it is in the first half of the group, we denote it as x0,\n            // otherwise we denote it as x1.\n            // For example, as shown in the Bitonic top K paper referenced\n            // above, Figure5(a) shows that element[1] is in the second half of\n            // the group when group size is 2, but it is in the first half of\n            // the group when group size is 4.\n            let isFirstInPair = elemIdx % (2 * uniforms.inc) < uniforms.inc;\n            var i = 0;\n            if (isFirstInPair) {\n              i = elemIdx;\n            } else {\n              i = elemIdx - uniforms.inc;\n            }\n\n            var i0 = 0;\n            if (uniforms.firstPass == 1) {\n              i0 = i;\n            } else {\n              i0 = i32(getIndices(batch, i));\n            }\n\n            var i1 = 0;\n            if (uniforms.firstPass == 1) {\n              i1 = i + uniforms.inc;\n            } else {\n              i1 = i32(getIndices(batch, i + uniforms.inc));\n            }\n\n            var x0 = f32(0.0);\n            var x1 = f32(0.0);\n            if (i0 < uniforms.inputSize) {\n              x0 = getX(batch, i0);\n            } else {\n              x0 = uniforms.negativeInf;\n            }\n            if (i1 < uniforms.inputSize) {\n              x1 = getX(batch, i1);\n            } else {\n              x1 = uniforms.negativeInf;\n            }\n\n            let reverse = elemIdx % (2 * uniforms.dir) >= uniforms.dir;\n            let isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n            if (reverse == isGreater) {\n              // Elements in opposite order of direction\n              let iTemp = i0;\n              i0 = i1;\n              i1 = iTemp;\n            }\n            if (isFirstInPair) {\n              setOutputAtIndex(index, f32(i0));\n            } else {\n              setOutputAtIndex(index, f32(i1));\n            }\n          }\n        }\n      ")},e}(),Co=function(){function e(e){this.variableNames=["x","indices"],this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=U(this.outputShape),this.dispatch=F(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms="inputSize : i32, firstPass : i32, k : i32,",this.shaderKey="merge"}return e.prototype.getUserCode=function(){return"\n        ".concat(k("index")," {\n          if (index < uniforms.size) {\n            let outC = getCoordsFromIndex(index);\n            let batch = outC[0];\n            let elemIdx = outC[1];\n            // The output size is half of the previous size.\n            // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _\n            // (k=4), we only need to output the indices at positions |, the\n            // indices at positions _ can be thrown away, see Figure5(b) After\n            // Phase 2 (Merge phase) in the Bitonic Top K paper referenced\n            // above.\n            // For example, the paper shows we only need to output the orange\n            // bars. The output sequence should look like this | | | | | | | |.\n            // Because the sequence is halved, to map the output index back to\n            // the previous sequence to find the corresponding value, we need\n            // to double the index. When we double the index, we basically\n            // interpolate a position, so 2i looks like\n            // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k\n            // position of each 2k positions by - elemIdx % k. E.g. for output\n            // at index 4,5,6,7, we want to get the corresponding element at\n            // original index 8,9,10,11, for output at index 8,9,10,11,\n            // we want to get the corresponding element at original index\n            // 16,17,18,19, so on and so forth.\n\n            var i = 0;\n            if (elemIdx < uniforms.k) {\n              i = elemIdx;\n            } else {\n              i = elemIdx * 2 - elemIdx % uniforms.k;\n            }\n            var i0 = 0;\n            if (uniforms.firstPass == 1) {\n              i0 = i;\n            } else {\n              i0 = i32(getIndices(batch, i));\n            }\n            var i1 = 0;\n            if (uniforms.firstPass == 1) {\n              i1 = i + uniforms.k;\n            } else {\n              i1 = i32(getIndices(batch, i + uniforms.k));\n            }\n\n            let x0 = getX(batch, i0);\n            var x1 = f32(0.0);\n            if (i1 < uniforms.inputSize) {\n              x1 = getX(batch, i1);\n            } else {\n              x1 = x0;\n            }\n\n            if (x0 >= x1) {\n              setOutputAtIndex(index, f32(i0));\n            } else {\n              setOutputAtIndex(index, f32(i1));\n            }\n          }\n        }\n      ")},e}();function Ao(e,t){null!==t&&e.disposeData(t.dataId)}function Ro(e){for(var t=1;t<e;)t*=2;return t}var No={kernelName:t.TopK,backendName:"webgpu",kernelFunc:function(e){var n=e.inputs,a=e.backend,r=e.attrs,i=n.x,o=r.k,s=r.sorted,c=i.shape,d=c[c.length-1];if(a.shouldExecuteOnCPU([i])){var l=a.readSync(i.dataId),h=u(zt(l,c,i.dtype,o,s),2),p=h[0],f=h[1];return[a.makeTensorInfo(p.shape,p.dtype,p.values),a.makeTensorInfo(f.shape,f.dtype,f.values)]}if(0===o)return c[c.length-1]=0,[a.makeTensorInfo(c,i.dtype,[]),a.makeTensorInfo(c,"int32",[])];if(1===d)return[i,ve({attrs:{shape:c,dtype:"int32",value:0},backend:a})];for(var m=t.util.sizeFromShape(c)/d,g=xe({inputs:{x:i},attrs:{shape:[m,d]},backend:a}),v=Ro(o),b=Ro(d),x=null,y=function(){return null===x?[g,g]:[g,x]},w=function(e,t,n){var r=y(),i=new Io(n),o=[{type:"int32",data:[d]},{type:"int32",data:[null===x?1:0]},{type:"float32",data:[Number.NEGATIVE_INFINITY]},{type:"int32",data:[e]},{type:"int32",data:[t]}],s=x;x=a.runWebGPUProgram(i,r,"int32",o),Ao(a,s)},k=1;k<v;k*=2)for(var S=2*k,I=k;I>=1;I/=2)w(S,I,[m,b]);for(var C=b;C>v;C/=2){var A=y(),R=new Co([m,C/2]),N=[{type:"int32",data:[d]},{type:"int32",data:[null===x?1:0]},{type:"int32",data:[v]}],P=x;x=a.runWebGPUProgram(R,A,"int32",N),Ao(a,P);for(S=2*(k=v/2),I=k;I>=1;I/=2)w(S,I,x.shape)}var T=x;x=In({inputs:{x:x},backend:a,attrs:{begin:0,size:[m,o]}}),Ao(a,T);var z=dr({inputs:{x:g,indices:x},backend:a,attrs:{axis:1,batchDims:1}});Ao(a,g);var _=c.slice(0,-1);_.push(o),T=x,x=xe({inputs:{x:x},attrs:{shape:_},backend:a}),Ao(a,T);var F=z;return z=xe({inputs:{x:z},attrs:{shape:_},backend:a}),Ao(a,F),[z,x]}},Po=function(){function e(e){this.variableNames=["Image","Transforms"],this.uniforms="interpolationModeId : i32, fillModeId : i32, fillValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=U(this.outputShape),this.dispatch=F(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="transform"}return e.prototype.getUserCode=function(){return"\n          fn mapCoord(outCoord : f32, len : f32) -> f32{\n            var inCoord = outCoord;\n            if(uniforms.fillModeId == 2) {\n              if (inCoord < 0.0) {\n                if (len <= 1.0) {\n                  inCoord = 0.0;\n                } else {\n                  let sz2 = 2.0 * len;\n                  if (inCoord < sz2) {\n                    inCoord = sz2 * f32(i32(f32(-inCoord / sz2))) +\n                    inCoord;\n                  }\n                  if (inCoord < -len) {\n                    inCoord = inCoord + sz2;\n                  } else {\n                    inCoord = -inCoord - 1.0;\n                  }\n                }\n              } else if (inCoord > len - 1.0) {\n                if (len <= 1.0) {\n                  inCoord = 0.0;\n                } else {\n                  let sz2 = 2.0 * len;\n                  inCoord = inCoord - sz2 * f32(i32(f32(inCoord / sz2)));\n                  if (inCoord >= len) {\n                    inCoord = sz2 - inCoord - 1.0;\n                  }\n                }\n              }\n              return clamp(inCoord, 0.0, len - 1.0);\n            } else if (uniforms.fillModeId == 3) {\n              if (inCoord < 0.0) {\n                if (len <= 1.0) {\n                  inCoord = 0.0;\n                } else {\n                  let sz = len - 1.0;\n                  inCoord = inCoord + len * (f32(i32(f32(-inCoord / sz))) + 1.0);\n                }\n              } else if (inCoord > len - 1.0) {\n                if (len <= 1.0) {\n                  inCoord = 0.0;\n                } else {\n                  let sz = len - 1.0;\n                  inCoord = inCoord - len * f32(i32(f32(inCoord / sz)));\n                }\n              }\n              return clamp(inCoord, 0.0, len - 1.0);\n            } else if (uniforms.fillModeId == 4) {\n              return clamp(outCoord, 0.0, len - 1.0);\n            }\n            return outCoord;\n          }\n          fn readWithFillValue(batch : i32, coordY : i32, coordX : i32,\n            channel : i32) -> f32 {\n            var outputValue : f32;\n            if (0 <= coordY && coordY < uniforms.imageShape[1] && 0 <= coordX && coordX < uniforms.imageShape[2]) {\n                outputValue = getImage(batch, coordY, coordX, channel);\n            } else {\n              outputValue = uniforms.fillValue;\n            }\n            return outputValue;\n          }\n\n          ".concat(k("index")," {\n            if (index < uniforms.size) {\n              let coords = getCoordsFromIndex(index);\n              var outputValue : f32;\n              let batch = coords[0];\n              let x = coords[2];\n              let y = coords[1];\n              let channel = coords[3];\n              let xf = f32(x);\n              let yf = f32(y);\n              let a1 = getTransforms(batch, 0);\n              let a2 = getTransforms(batch, 1);\n              let a3 = getTransforms(batch, 2);\n              let b1 = getTransforms(batch, 3);\n              let b2 = getTransforms(batch, 4);\n              let b3 = getTransforms(batch, 5);\n              let c1 = getTransforms(batch, 6);\n              let c2 = getTransforms(batch, 7);\n              let projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = uniforms.fillValue;\n              } else {\n                let inX = (a1 * xf + a2 * yf + a3) / projection;\n                let inY = (b1 * xf + b2 * yf + b3) / projection;\n                let mapX = mapCoord(inX, f32(uniforms.imageShape[2]));\n                let mapY = mapCoord(inY, f32(uniforms.imageShape[1]));\n\n                if (uniforms.interpolationModeId == 1) {\n                  let coordY = i32(round(mapY));\n                  let coordX = i32(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  let yFloor = floor(mapY);\n                  let xFloor = floor(mapX);\n                  let yCeil = yFloor + 1.0;\n                  let xCeil = xFloor + 1.0;\n                  let valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, i32(yFloor), i32(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, i32(yFloor), i32(xCeil), channel);\n                  let valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, i32(yCeil), i32(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, i32(yCeil), i32(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutputAtIndex(index, outputValue);\n            }\n          }\n        ")},e}();var To={kernelName:t.Transform,backendName:"webgpu",kernelFunc:function(e){var t,n=e.inputs,a=e.backend,r=e.attrs,i=n.image,o=n.transforms,s=r.interpolation,c=r.fillMode,d=r.fillValue,l=r.outputShape,h=u(i.shape,4),p=h[0],f=h[1],m=h[2],g=h[3],v=u(null!=l?l:[f,m],2),b=v[0],x=v[1],y=new Po([p,b,x,g]),w="nearest"===s?1:2;switch(c){case"constant":default:t=1;break;case"reflect":t=2;break;case"wrap":t=3;break;case"nearest":t=4}var k=[{type:"int32",data:[w]},{type:"int32",data:[t]},{type:"float32",data:[d]}];return a.runWebGPUProgram(y,[i,o],"float32",k)}};var zo,_o,Fo=[ke,Bt,Lt,Ot,Wt,Vt,Yt,Qt,Jt,$t,tn,an,on,un,dn,bn,yn,wn,An,Pn,Bn,Ln,Dn,Ne,Kn,Zn,ea,aa,ia,sa,ca,fa,ma,ga,ba,ka,Ia,Aa,za,Fa,Ea,Ua,Da,Ma,Ga,ja,be,Ya,tr,Za,$a,rr,ir,or,ur,lr,pr,mr,Ae,gr,Vn,br,yr,kr,Sr,Cr,Rr,Pr,Fr,zr,Er,Ur,Dr,Gr,fn,Kr,Xr,gn,jr,Yr,Zr,$r,Na,ei,ti,ni,zn,ri,si,ui,li,pi,fi,mi,gi,Fn,bi,yi,ki,Ii,ye,Ai,Ni,Ti,_i,Bi,Li,Oi,Wi,Vi,Hi,Xi,qi,Qi,Ji,Cn,go,bo,xo,to,ao,ro,uo,co,ho,po,mo,eo,Ta,wo,So,so,No,To,Xt,{kernelName:t.Unpack,backendName:"webgpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,a=e.attrs,r=t.value,i=a.axis;i<0&&(i+=r.shape.length);for(var o=r,s=o.shape.length,u=r.shape[i],c=new Array(s-1),d=0,l=0;l<s;l++)l!==i&&(c[d++]=o.shape[l]);var h=[],p=new Array(s).fill(0),f=o.shape.slice();f[i]=1;var m=new Array(u);for(l=0;l<m.length;l++){p[i]=l;var g=In({inputs:{x:o},backend:n,attrs:{begin:p,size:f}}),v=xe({inputs:{x:g},backend:n,attrs:{shape:c}});m[l]=v,h.push(g)}return h.forEach((function(e){return n.disposeData(e.dataId)})),m}},oi];try{for(var Bo=s(Fo),Eo=Bo.next();!Eo.done;Eo=Bo.next()){var Lo=Eo.value;t.registerKernel(Lo)}}catch(e){zo={error:e}}finally{try{Eo&&!Eo.done&&(_o=Bo.return)&&_o.call(Bo)}finally{if(zo)throw zo.error}}e.WebGPUBackend=H,e.webgpu_util=V,Object.defineProperty(e,"__esModule",{value:!0})}));
//# sourceMappingURL=tf-backend-webgpu.min.js.map
