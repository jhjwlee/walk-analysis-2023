/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
import { util } from '@tensorflow/tfjs-core';
import { activationFnSnippet, biasActivationSnippet, typeSnippet } from './activation_util';
import { makeMatMulPackedSource, makeMatMulPackedVec4Source, matMulReadFnSource } from './matmul_packed_webgpu';
import { atomicAddSnippet } from './shader_util';
import { getMainHeaderString as main } from './webgpu_program';
import { computeDispatch, flatDispatchLayout } from './webgpu_util';
export class MatMulSplitKProgram {
    constructor(outputShape, dimInner, transposeA = false, transposeB = false) {
        this.variableNames = ['A', 'B'];
        this.uniforms = `dimAOuter : i32, dimBOuter : i32, dimInner : i32,`;
        this.workgroupSize = [8, 8, 1];
        this.atomic = true;
        this.isVec4 = false;
        this.splitedDimInner = 128;
        util.assert(outputShape[0] === 1, () => 'MatMulSplitKProgram only supports batch = 1.');
        this.outputShape = outputShape;
        this.dispatchLayout = { x: [2], y: [1], z: [0, 3] };
        this.isVec4 = (transposeA && this.outputShape[1] % 4 === 0 ||
            !transposeA && dimInner % 4 === 0) &&
            this.outputShape[2] % 4 === 0;
        this.elementsPerThread = [4, 4, this.splitedDimInner];
        if (!this.isVec4) {
            if (this.outputShape[1] < 16) {
                this.elementsPerThread[1] = 1;
            }
            if (this.outputShape[2] < 16) {
                this.elementsPerThread[0] = 1;
            }
        }
        this.dispatch = computeDispatch(this.dispatchLayout, [
            this.outputShape[0], this.outputShape[1], this.outputShape[2],
            dimInner
        ], this.workgroupSize, this.elementsPerThread);
        this.transposeA = transposeA;
        this.transposeB = transposeB;
        this.shaderKey = `matMulSplitK_${transposeA}_${transposeB}_${this.elementsPerThread}_${this.isVec4}`;
    }
    getUserCode() {
        const component = this.isVec4 ? 4 : 1;
        const userCode = `
      ${matMulReadFnSource(false, this.transposeB, false, false, false, component)}
      fn mm_write(batch: i32, row : i32, colIn : i32, value : ${typeSnippet(component)}) {
        let col = colIn * ${component};
        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {
          let coords = vec3<i32>(batch, row, col);
          let flatIndex = getOutputIndexFromCoords(coords);
          // The problem is that we should initialize output to zero before using.
          // Otherwise, the original value will be added to the result.
          for (var i = 0; i < ${component}; i = i + 1) {
            ${atomicAddSnippet('&result[flatIndex + i]', `${component > 1 ? 'value[i]' : 'value'}`, 'float32')}
          }
        }
      }
      ${this.isVec4 ? makeMatMulPackedVec4Source(this.elementsPerThread, this.workgroupSize, this.transposeA, 32, true, this.splitedDimInner) :
            makeMatMulPackedSource(this.elementsPerThread, this.workgroupSize, this.transposeA, 32, true, this.splitedDimInner)}
    `;
        return userCode;
    }
}
export class BiasActivationProgram {
    constructor(outputShape, bias = null, activation = null, preluActivationWeights = null) {
        this.uniforms = '';
        this.variableNames = ['x'];
        this.workgroupSize = [64, 1, 1];
        this.size = true;
        this.outputShape = outputShape;
        this.dispatchLayout = flatDispatchLayout(this.outputShape);
        this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workgroupSize);
        this.addBias = bias != null;
        this.hasPreluActivationWeights = preluActivationWeights != null;
        this.activation = activation;
        if (this.addBias) {
            this.variableNames.push('bias');
        }
        if (this.hasPreluActivationWeights) {
            this.variableNames.push('preluActivationWeights');
        }
        this.shaderKey = `biasActivation_${activation}`;
    }
    getUserCode() {
        return `
    ${activationFnSnippet(this.activation, this.hasPreluActivationWeights)}
    ${main('index')} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        var value = getXByOutputIndex(index);
        ${biasActivationSnippet(this.addBias, this.activation)}
        setOutputAtIndex(index, value);
      }
    }
    `;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWF0bXVsX3NwbGl0S193ZWJncHUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi90ZmpzLWJhY2tlbmQtd2ViZ3B1L3NyYy9tYXRtdWxfc3BsaXRLX3dlYmdwdS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7O0dBZUc7QUFFSCxPQUFPLEVBQTJCLElBQUksRUFBQyxNQUFNLHVCQUF1QixDQUFDO0FBRXJFLE9BQU8sRUFBQyxtQkFBbUIsRUFBRSxxQkFBcUIsRUFBRSxXQUFXLEVBQUMsTUFBTSxtQkFBbUIsQ0FBQztBQUMxRixPQUFPLEVBQUMsc0JBQXNCLEVBQUUsMEJBQTBCLEVBQUUsa0JBQWtCLEVBQUMsTUFBTSx3QkFBd0IsQ0FBQztBQUM5RyxPQUFPLEVBQUMsZ0JBQWdCLEVBQUMsTUFBTSxlQUFlLENBQUM7QUFDL0MsT0FBTyxFQUFDLG1CQUFtQixJQUFJLElBQUksRUFBZ0IsTUFBTSxrQkFBa0IsQ0FBQztBQUM1RSxPQUFPLEVBQUMsZUFBZSxFQUFFLGtCQUFrQixFQUFDLE1BQU0sZUFBZSxDQUFDO0FBRWxFLE1BQU0sT0FBTyxtQkFBbUI7SUFlOUIsWUFDSSxXQUFxQyxFQUFFLFFBQWdCLEVBQ3ZELFVBQVUsR0FBRyxLQUFLLEVBQUUsVUFBVSxHQUFHLEtBQUs7UUFaMUMsa0JBQWEsR0FBRyxDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsQ0FBQztRQUMzQixhQUFRLEdBQUcsbURBQW1ELENBQUM7UUFDL0Qsa0JBQWEsR0FBNkIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBSXBELFdBQU0sR0FBRyxJQUFJLENBQUM7UUFDZCxXQUFNLEdBQUcsS0FBSyxDQUFDO1FBQ2Ysb0JBQWUsR0FBRyxHQUFHLENBQUM7UUFLcEIsSUFBSSxDQUFDLE1BQU0sQ0FDUCxXQUFXLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxFQUNwQixHQUFHLEVBQUUsQ0FBQyw4Q0FB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VUFBVSxFQUFFLElBQUksQ0FBQyx5QkFBeUIsQ0FBQztNQUNwRSxJQUFJLENBQUMsT0FBTyxDQUFDOzs7O1VBSVQscUJBQXFCLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsVUFBVSxDQUFDOzs7O0tBSXpELENBQUM7SUFDSixDQUFDO0NBQ0YiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMiBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbmltcG9ydCB7YmFja2VuZF91dGlsLCBUZW5zb3JJbmZvLCB1dGlsfSBmcm9tICdAdGVuc29yZmxvdy90ZmpzLWNvcmUnO1xuXG5pbXBvcnQge2FjdGl2YXRpb25GblNuaXBwZXQsIGJpYXNBY3RpdmF0aW9uU25pcHBldCwgdHlwZVNuaXBwZXR9IGZyb20gJy4vYWN0aXZhdGlvbl91dGlsJztcbmltcG9ydCB7bWFrZU1hdE11bFBhY2tlZFNvdXJjZSwgbWFrZU1hdE11bFBhY2tlZFZlYzRTb3VyY2UsIG1hdE11bFJlYWRGblNvdXJjZX0gZnJvbSAnLi9tYXRtdWxfcGFja2VkX3dlYmdwdSc7XG5pbXBvcnQge2F0b21pY0FkZFNuaXBwZXR9IGZyb20gJy4vc2hhZGVyX3V0aWwnO1xuaW1wb3J0IHtnZXRNYWluSGVhZGVyU3RyaW5nIGFzIG1haW4sIFdlYkdQVVByb2dyYW19IGZyb20gJy4vd2ViZ3B1X3Byb2dyYW0nO1xuaW1wb3J0IHtjb21wdXRlRGlzcGF0Y2gsIGZsYXREaXNwYXRjaExheW91dH0gZnJvbSAnLi93ZWJncHVfdXRpbCc7XG5cbmV4cG9ydCBjbGFzcyBNYXRNdWxTcGxpdEtQcm9ncmFtIGltcGxlbWVudHMgV2ViR1BVUHJvZ3JhbSB7XG4gIG91dHB1dFNoYXBlOiBudW1iZXJbXTtcbiAgc2hhZGVyS2V5OiBzdHJpbmc7XG4gIGRpc3BhdGNoTGF5b3V0OiB7eDogbnVtYmVyW10sIHk6IG51bWJlcltdLCB6OiBudW1iZXJbXX07XG4gIGRpc3BhdGNoOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl07XG4gIHZhcmlhYmxlTmFtZXMgPSBbJ0EnLCAnQiddO1xuICB1bmlmb3JtcyA9IGBkaW1BT3V0ZXIgOiBpMzIsIGRpbUJPdXRlciA6IGkzMiwgZGltSW5uZXIgOiBpMzIsYDtcbiAgd29ya2dyb3VwU2l6ZTogW251bWJlciwgbnVtYmVyLCBudW1iZXJdID0gWzgsIDgsIDFdO1xuICBlbGVtZW50c1BlclRocmVhZDogW251bWJlciwgbnVtYmVyLCBudW1iZXJdO1xuICB0cmFuc3Bvc2VBOiBib29sZWFuO1xuICB0cmFuc3Bvc2VCOiBib29sZWFuO1xuICBhdG9taWMgPSB0cnVlO1xuICBpc1ZlYzQgPSBmYWxzZTtcbiAgc3BsaXRlZERpbUlubmVyID0gMTI4O1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgICAgb3V0cHV0U2hhcGU6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSwgZGltSW5uZXI6IG51bWJlcixcbiAgICAgIHRyYW5zcG9zZUEgPSBmYWxzZSwgdHJhbnNwb3NlQiA9IGZhbHNlKSB7XG4gICAgdXRpbC5hc3NlcnQoXG4gICAgICAgIG91dHB1dFNoYXBlWzBdID09PSAxLFxuICAgICAgICAoKSA9PiAnTWF0TXVsU3BsaXRLUHJvZ3JhbSBvbmx5IHN1cHBvcnRzIGJhdGNoID0gMS4nKTtcbiAgICB0aGlzLm91dHB1dFNoYXBlID0gb3V0cHV0U2hhcGU7XG4gICAgdGhpcy5kaXNwYXRjaExheW91dCA9IHt4OiBbMl0sIHk6IFsxXSwgejogWzAsIDNdfTtcbiAgICB0aGlzLmlzVmVjNCA9ICh0cmFuc3Bvc2VBICYmIHRoaXMub3V0cHV0U2hhcGVbMV0gJSA0ID09PSAwIHx8XG4gICAgICAgICAgICAgICAgICAgIXRyYW5zcG9zZUEgJiYgZGltSW5uZXIgJSA0ID09PSAwKSAmJlxuICAgICAgICB0aGlzLm91dHB1dFNoYXBlWzJdICUgNCA9PT0gMDtcbiAgICB0aGlzLmVsZW1lbnRzUGVyVGhyZWFkID0gWzQsIDQsIHRoaXMuc3BsaXRlZERpbUlubmVyXTtcblxuICAgIGlmICghdGhpcy5pc1ZlYzQpIHtcbiAgICAgIGlmICh0aGlzLm91dHB1dFNoYXBlWzFdIDwgMTYpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50c1BlclRocmVhZFsxXSA9IDE7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5vdXRwdXRTaGFwZVsyXSA8IDE2KSB7XG4gICAgICAgIHRoaXMuZWxlbWVudHNQZXJUaHJlYWRbMF0gPSAxO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuZGlzcGF0Y2ggPSBjb21wdXRlRGlzcGF0Y2goXG4gICAgICAgIHRoaXMuZGlzcGF0Y2hMYXlvdXQsXG4gICAgICAgIFtcbiAgICAgICAgICB0aGlzLm91dHB1dFNoYXBlWzBdLCB0aGlzLm91dHB1dFNoYXBlWzFdLCB0aGlzLm91dHB1dFNoYXBlWzJdLFxuICAgICAgICAgIGRpbUlubmVyXG4gICAgICAgIF0sXG4gICAgICAgIHRoaXMud29ya2dyb3VwU2l6ZSwgdGhpcy5lbGVtZW50c1BlclRocmVhZCk7XG5cbiAgICB0aGlzLnRyYW5zcG9zZUEgPSB0cmFuc3Bvc2VBO1xuICAgIHRoaXMudHJhbnNwb3NlQiA9IHRyYW5zcG9zZUI7XG4gICAgdGhpcy5zaGFkZXJLZXkgPSBgbWF0TXVsU3BsaXRLXyR7dHJhbnNwb3NlQX1fJHt0cmFuc3Bvc2VCfV8ke1xuICAgICAgICB0aGlzLmVsZW1lbnRzUGVyVGhyZWFkfV8ke3RoaXMuaXNWZWM0fWA7XG4gIH1cblxuICBnZXRVc2VyQ29kZSgpOiBzdHJpbmcge1xuICAgIGNvbnN0IGNvbXBvbmVudCA9IHRoaXMuaXNWZWM0ID8gNCA6IDE7XG4gICAgY29uc3QgdXNlckNvZGUgPSBgXG4gICAgICAke1xuICAgICAgICBtYXRNdWxSZWFkRm5Tb3VyY2UoXG4gICAgICAgICAgICBmYWxzZSwgdGhpcy50cmFuc3Bvc2VCLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCBjb21wb25lbnQpfVxuICAgICAgZm4gbW1fd3JpdGUoYmF0Y2g6IGkzMiwgcm93IDogaTMyLCBjb2xJbiA6IGkzMiwgdmFsdWUgOiAke1xuICAgICAgICB0eXBlU25pcHBldChjb21wb25lbnQpfSkge1xuICAgICAgICBsZXQgY29sID0gY29sSW4gKiAke2NvbXBvbmVudH07XG4gICAgICAgIGlmIChyb3cgPCB1bmlmb3Jtcy5kaW1BT3V0ZXIgJiYgY29sIDwgdW5pZm9ybXMuZGltQk91dGVyKSB7XG4gICAgICAgICAgbGV0IGNvb3JkcyA9IHZlYzM8aTMyPihiYXRjaCwgcm93LCBjb2wpO1xuICAgICAgICAgIGxldCBmbGF0SW5kZXggPSBnZXRPdXRwdXRJbmRleEZyb21Db29yZHMoY29vcmRzKTtcbiAgICAgICAgICAvLyBUaGUgcHJvYmxlbSBpcyB0aGF0IHdlIHNob3VsZCBpbml0aWFsaXplIG91dHB1dCB0byB6ZXJvIGJlZm9yZSB1c2luZy5cbiAgICAgICAgICAvLyBPdGhlcndpc2UsIHRoZSBvcmlnaW5hbCB2YWx1ZSB3aWxsIGJlIGFkZGVkIHRvIHRoZSByZXN1bHQuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAke2NvbXBvbmVudH07IGkgPSBpICsgMSkge1xuICAgICAgICAgICAgJHtcbiAgICAgICAgYXRvbWljQWRkU25pcHBldChcbiAgICAgICAgICAgICcmcmVzdWx0W2ZsYXRJbmRleCArIGldJywgYCR7Y29tcG9uZW50ID4gMSA/ICd2YWx1ZVtpXScgOiAndmFsdWUnfWAsXG4gICAgICAgICAgICAnZmxvYXQzMicpfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgJHtcbiAgICAgICAgdGhpcy5pc1ZlYzQgPyBtYWtlTWF0TXVsUGFja2VkVmVjNFNvdXJjZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50c1BlclRocmVhZCwgdGhpcy53b3JrZ3JvdXBTaXplLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYW5zcG9zZUEsIDMyLCB0cnVlLCB0aGlzLnNwbGl0ZWREaW1Jbm5lcikgOlxuICAgICAgICAgICAgICAgICAgICAgIG1ha2VNYXRNdWxQYWNrZWRTb3VyY2UoXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudHNQZXJUaHJlYWQsIHRoaXMud29ya2dyb3VwU2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFuc3Bvc2VBLCAzMiwgdHJ1ZSwgdGhpcy5zcGxpdGVkRGltSW5uZXIpfVxuICAgIGA7XG4gICAgcmV0dXJuIHVzZXJDb2RlO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBCaWFzQWN0aXZhdGlvblByb2dyYW0gaW1wbGVtZW50cyBXZWJHUFVQcm9ncmFtIHtcbiAgb3V0cHV0U2hhcGU6IG51bWJlcltdO1xuICBzaGFkZXJLZXk6IHN0cmluZztcbiAgdW5pZm9ybXMgPSAnJztcbiAgZGlzcGF0Y2hMYXlvdXQ6IHt4OiBudW1iZXJbXX07XG4gIGRpc3BhdGNoOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl07XG4gIHZhcmlhYmxlTmFtZXMgPSBbJ3gnXTtcbiAgd29ya2dyb3VwU2l6ZTogW251bWJlciwgbnVtYmVyLCBudW1iZXJdID0gWzY0LCAxLCAxXTtcbiAgc2l6ZSA9IHRydWU7XG4gIHByaXZhdGUgYWRkQmlhczogYm9vbGVhbjtcbiAgcHJpdmF0ZSBhY3RpdmF0aW9uOiBiYWNrZW5kX3V0aWwuQWN0aXZhdGlvbjtcbiAgcHJpdmF0ZSBoYXNQcmVsdUFjdGl2YXRpb25XZWlnaHRzOiBib29sZWFuO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgICAgb3V0cHV0U2hhcGU6IG51bWJlcltdLCBiaWFzOiBUZW5zb3JJbmZvID0gbnVsbCxcbiAgICAgIGFjdGl2YXRpb246IGJhY2tlbmRfdXRpbC5BY3RpdmF0aW9uID0gbnVsbCxcbiAgICAgIHByZWx1QWN0aXZhdGlvbldlaWdodHM6IFRlbnNvckluZm8gPSBudWxsKSB7XG4gICAgdGhpcy5vdXRwdXRTaGFwZSA9IG91dHB1dFNoYXBlO1xuICAgIHRoaXMuZGlzcGF0Y2hMYXlvdXQgPSBmbGF0RGlzcGF0Y2hMYXlvdXQodGhpcy5vdXRwdXRTaGFwZSk7XG4gICAgdGhpcy5kaXNwYXRjaCA9IGNvbXB1dGVEaXNwYXRjaChcbiAgICAgICAgdGhpcy5kaXNwYXRjaExheW91dCwgdGhpcy5vdXRwdXRTaGFwZSwgdGhpcy53b3JrZ3JvdXBTaXplKTtcbiAgICB0aGlzLmFkZEJpYXMgPSBiaWFzICE9IG51bGw7XG4gICAgdGhpcy5oYXNQcmVsdUFjdGl2YXRpb25XZWlnaHRzID0gcHJlbHVBY3RpdmF0aW9uV2VpZ2h0cyAhPSBudWxsO1xuICAgIHRoaXMuYWN0aXZhdGlvbiA9IGFjdGl2YXRpb247XG4gICAgaWYgKHRoaXMuYWRkQmlhcykge1xuICAgICAgdGhpcy52YXJpYWJsZU5hbWVzLnB1c2goJ2JpYXMnKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5oYXNQcmVsdUFjdGl2YXRpb25XZWlnaHRzKSB7XG4gICAgICB0aGlzLnZhcmlhYmxlTmFtZXMucHVzaCgncHJlbHVBY3RpdmF0aW9uV2VpZ2h0cycpO1xuICAgIH1cblxuICAgIHRoaXMuc2hhZGVyS2V5ID0gYGJpYXNBY3RpdmF0aW9uXyR7YWN0aXZhdGlvbn1gO1xuICB9XG5cbiAgZ2V0VXNlckNvZGUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gYFxuICAgICR7YWN0aXZhdGlvbkZuU25pcHBldCh0aGlzLmFjdGl2YXRpb24sIHRoaXMuaGFzUHJlbHVBY3RpdmF0aW9uV2VpZ2h0cyl9XG4gICAgJHttYWluKCdpbmRleCcpfSB7XG4gICAgICBpZiAoaW5kZXggPCB1bmlmb3Jtcy5zaXplKSB7XG4gICAgICAgIGxldCBjb29yZHMgPSBnZXRDb29yZHNGcm9tSW5kZXgoaW5kZXgpO1xuICAgICAgICB2YXIgdmFsdWUgPSBnZXRYQnlPdXRwdXRJbmRleChpbmRleCk7XG4gICAgICAgICR7Ymlhc0FjdGl2YXRpb25TbmlwcGV0KHRoaXMuYWRkQmlhcywgdGhpcy5hY3RpdmF0aW9uKX1cbiAgICAgICAgc2V0T3V0cHV0QXRJbmRleChpbmRleCwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBgO1xuICB9XG59XG4iXX0=