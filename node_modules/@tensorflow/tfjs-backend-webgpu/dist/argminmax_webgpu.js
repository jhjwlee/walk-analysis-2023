/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
import { backend_util, util } from '@tensorflow/tfjs-core';
import { getCoordsXYZ, getMainHeaderString as main } from './webgpu_program';
import { computeDispatch, flatDispatchLayout } from './webgpu_util';
export class ArgMinMaxProgram {
    constructor(inputShape, axis, reduceType) {
        this.workgroupSize = [64, 1, 1];
        this.variableNames = ['x'];
        this.uniforms = 'infinityValue : f32,';
        this.size = true;
        const axes = [axis];
        this.op = reduceType === 'min' ? '<' : '>';
        // |outShape| is the shape with the removed axis
        const [outputShape, reduceShape] = backend_util.computeOutAndReduceShapes(inputShape, axes);
        this.outputShape = outputShape.length === 0 ? [1] : outputShape;
        this.dispatchLayout = flatDispatchLayout(this.outputShape);
        // The shared algorithm is mainly used for large reduce size. It fully
        // utilizes the threads in one workgroup to do the reduction. However,
        // when the reduce size is very small or the output shape is too large. It's
        // better to use the plain algorithm to reduce the number of workgroups to
        // speedup. The threthold can be further tuned.
        if (util.sizeFromShape(reduceShape) < 32 ||
            util.sizeFromShape(outputShape) > 1000) {
            this.type = 'plain';
            this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workgroupSize);
        }
        else {
            this.type = 'shared';
            // A work group only outputs a data, so we transfer [1, 1, 1] to compute
            // dispatch size.
            this.dispatch =
                computeDispatch(this.dispatchLayout, this.outputShape, [1, 1, 1]);
        }
        this.inputShape = inputShape;
        this.shaderKey = `argMinMax_${this.op}_${this.type}`;
    }
    getUserCode() {
        const workgroupSizeX = this.workgroupSize[0];
        const getInputShapeLastDim = () => {
            if (this.inputShape.length === 1) {
                return 'uniforms.xShape';
            }
            else {
                return `uniforms.xShape.${getCoordsXYZ(this.inputShape.length - 1)}`;
            }
        };
        const splitOutputCoords = () => {
            let snippet = '';
            if (this.outputShape.length === 1) {
                if (this.inputShape.length !== 1) {
                    snippet += 'outputCoords,';
                }
            }
            else {
                for (let i = 0; i < this.outputShape.length; i++) {
                    snippet += `outputCoords.${getCoordsXYZ(i)},`;
                }
            }
            return snippet;
        };
        if (this.type === 'shared') {
            const sharedMemorySnippet = `
      var<workgroup> xBestIndices : array<i32, ${workgroupSizeX}>;
      var<workgroup> xBestValues : array<f32, ${workgroupSizeX}>;
    `;
            const userCode = `
      fn DIV_CEIL(a : u32, b : u32) -> u32 {
        return ((a - 1u) / b + 1u);
      }

      ${sharedMemorySnippet}

      ${main('index')} {
        let outputIndex = index / ${workgroupSizeX};
        let reduceLength = ${getInputShapeLastDim()};

        var bestIndex = i32(localId.x);
        var bestValue = uniforms.infinityValue;
        let outputCoords = getCoordsFromIndex(outputIndex);
        for (var k = i32(localId.x); k < reduceLength && outputIndex < uniforms.size;
            k = k + ${workgroupSizeX}) {
          let candidate = getX(${splitOutputCoords()} k);
          if (!isnan(candidate) && candidate ${this.op} bestValue) {
            bestValue = candidate;
            bestIndex = k;
          }
        }
        xBestValues[localId.x] = bestValue;
        xBestIndices[localId.x] = bestIndex;
        workgroupBarrier();

        var reduceSize = min(u32(reduceLength), ${workgroupSizeX}u);
        for (var currentSize = reduceSize / 2u; reduceSize > 1u;
            currentSize = reduceSize / 2u) {
          let interval = DIV_CEIL(reduceSize, 2u);
          if (localId.x < currentSize) {
            let candidate = xBestValues[localId.x + interval];
            if (candidate ${this.op} bestValue) {
              bestValue = candidate;
              xBestValues[localId.x] = bestValue;
              xBestIndices[localId.x] = xBestIndices[localId.x + interval];
            }
          }
          reduceSize = interval;
          workgroupBarrier();
        }

        if (localId.x == 0u && outputIndex < uniforms.size) {
          setOutputAtIndexI32(outputIndex, xBestIndices[localId.x]);
        }
      }
    `;
            return userCode;
        }
        else {
            const userCode = `
      ${main('index')} {
        if (index < uniforms.size) {
          let outputCoords = getCoordsFromIndex(index);
          var bestIndex = 0;
          var bestValue = getX(${splitOutputCoords()} 0);
          let reduceLength = ${getInputShapeLastDim()};
          for (var i = 1; i < reduceLength; i++) {
            let candidate = getX(${splitOutputCoords()} i);
            if (candidate ${this.op} bestValue) {
              bestValue = candidate;
              bestIndex = i;
            }
          }
          setOutputAtIndexI32(index, bestIndex);
        }
      }
      `;
            return userCode;
        }
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXJnbWlubWF4X3dlYmdwdS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3RmanMtYmFja2VuZC13ZWJncHUvc3JjL2FyZ21pbm1heF93ZWJncHUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7OztHQWVHO0FBRUgsT0FBTyxFQUFDLFlBQVksRUFBRSxJQUFJLEVBQUMsTUFBTSx1QkFBdUIsQ0FBQztBQUN6RCxPQUFPLEVBQUMsWUFBWSxFQUFFLG1CQUFtQixJQUFJLElBQUksRUFBZ0IsTUFBTSxrQkFBa0IsQ0FBQztBQUMxRixPQUFPLEVBQUMsZUFBZSxFQUFFLGtCQUFrQixFQUFDLE1BQU0sZUFBZSxDQUFDO0FBRWxFLE1BQU0sT0FBTyxnQkFBZ0I7SUFjM0IsWUFBWSxVQUFvQixFQUFFLElBQVksRUFBRSxVQUF1QjtRQVR2RSxrQkFBYSxHQUE2QixDQUFDLEVBQUUsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFDckQsa0JBQWEsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ3RCLGFBQVEsR0FBRyxzQkFBc0IsQ0FBQztRQUlsQyxTQUFJLEdBQUcsSUFBSSxDQUFDO1FBSVYsTUFBTSxJQUFJLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUVwQixJQUFJLENBQUMsRUFBRSxHQUFHLFVBQVUsS0FBSyxLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDO1FBRTNDLGdEQUFnRDtRQUNoRCxNQUFNLENBQUMsV0FBVyxFQUFFLFdBQVcsQ0FBQyxHQUM1QixZQUFZLENBQUMseUJBQXlCLENBQUMsVUFBVSxFQUFFLElBQUksQ0FBQyxDQUFDO1FBRTdELElBQUksQ0FBQyxXQUFXLEdBQUcsV0FBVyxDQUFDLE1BQU0sS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFdBQVcsQ0FBQztRQUNoRSxJQUFJLENBQUMsY0FBYyxHQUFHLGtCQUFrQixDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQztRQUMzRCxzRUFBc0U7UUFDdEUsc0VBQXNFO1FBQ3RFLDRFQUE0RTtRQUM1RSwwRUFBMEU7UUFDMUUsK0NBQStDO1FBQy9DLElBQUksSUFBSSxDQUFDLGFBQWEsQ0FBQyxXQUFXLENBQUMsR0FBRyxFQUFFO1lBQ3BDLElBQUksQ0FBQyxhQUFhLENBQUMsV0FBVyxDQUFDLEdBQUcsSUFBSSxFQUFFO1lBQzFDLElBQUksQ0FBQyxJQUFJLEdBQUcsT0FBTyxDQUFDO1lBQ3BCLElBQUksQ0FBQyxRQUFRLEdBQUcsZUFBZSxDQUMzQixJQUFJLENBQUMsY0FBYyxFQUFFLElBQUksQ0FBQyxXQUFXLEVBQUUsSUFBSSxDQUFDLGFBQWEsQ0FBQyxDQUFDO1NBQ2hFO2FBQU07WUFDTCxJQUFJLENBQUMsSUFBSSxHQUFHLFFBQVEsQ0FBQztZQUNyQix3RUFBd0U7WUFDeEUsaUJBQWlCO1lBQ2pCLElBQUksQ0FBQyxRQUFRO2dCQUNULGVBQWUsQ0FBQyxJQUFJLENBQUMsY0FBYyxFQUFFLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7U0FDdkU7UUFFRCxJQUFJLENBQUMsVUFBVSxHQUFHLFVBQVUsQ0FBQztRQUM3QixJQUFJLENBQUMsU0FBUyxHQUFHLGFBQWEsSUFBSSxDQUFDLEVBQUUsSUFBSSxJQUFJLENBQUMsSUFBSSxFQUFFLENBQUM7SUFDdkQsQ0FBQztJQUVELFdBQVc7UUFDVCxNQUFNLGNBQWMsR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQzdDLE1BQU0sb0JBQW9CLEdBQUcsR0FBRyxFQUFFO1lBQ2hDLElBQUksSUFBSSxDQUFDLFVBQVUsQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO2dCQUNoQyxPQUFPLGlCQUFpQixDQUFDO2FBQzFCO2lCQUFNO2dCQUNMLE9BQU8sbUJBQW1CLFlBQVksQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDO2FBQ3RFO1FBQ0gsQ0FBQyxDQUFDO1FBRUYsTUFBTSxpQkFBaUIsR0FBRyxHQUFHLEVBQUU7WUFDN0IsSUFBSSxPQUFPLEdBQUcsRUFBRSxDQUFDO1lBQ2pCLElBQUksSUFBSSxDQUFDLFdBQVcsQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO2dCQUNqQyxJQUFJLElBQUksQ0FBQyxVQUFVLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtvQkFDaEMsT0FBTyxJQUFJLGVBQWUsQ0FBQztpQkFDNUI7YUFDRjtpQkFBTTtnQkFDTCxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7b0JBQ2hELE9BQU8sSUFBSSxnQkFBZ0IsWUFBWSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUM7aUJBQy9DO2FBQ0Y7WUFDRCxPQUFPLE9BQU8sQ0FBQztRQUNqQixDQUFDLENBQUM7UUFFRixJQUFJLElBQUksQ0FBQyxJQUFJLEtBQUssUUFBUSxFQUFFO1lBQzFCLE1BQU0sbUJBQW1CLEdBQUc7aURBQ2UsY0FBYztnREFDZixjQUFjO0tBQ3pELENBQUM7WUFDQSxNQUFNLFFBQVEsR0FBRzs7Ozs7UUFLZixtQkFBbUI7O1FBRW5CLElBQUksQ0FBQyxPQUFPLENBQUM7b0NBQ2UsY0FBYzs2QkFDckIsb0JBQW9CLEVBQUU7Ozs7OztzQkFNN0IsY0FBYztpQ0FDSCxpQkFBaUIsRUFBRTsrQ0FDTCxJQUFJLENBQUMsRUFBRTs7Ozs7Ozs7O2tEQVNKLGNBQWM7Ozs7Ozs0QkFNcEMsSUFBSSxDQUFDLEVBQUU7Ozs7Ozs7Ozs7Ozs7O0tBYzlCLENBQUM7WUFDQSxPQUFPLFFBQVEsQ0FBQztTQUNqQjthQUFNO1lBQ0wsTUFBTSxRQUFRLEdBQUc7UUFDZixJQUFJLENBQUMsT0FBTyxDQUFDOzs7O2lDQUlZLGlCQUFpQixFQUFFOytCQUNyQixvQkFBb0IsRUFBRTs7bUNBRWxCLGlCQUFpQixFQUFFOzRCQUMxQixJQUFJLENBQUMsRUFBRTs7Ozs7Ozs7T0FRNUIsQ0FBQztZQUNGLE9BQU8sUUFBUSxDQUFDO1NBQ2pCO0lBQ0gsQ0FBQztDQUNGIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuXG5pbXBvcnQge2JhY2tlbmRfdXRpbCwgdXRpbH0gZnJvbSAnQHRlbnNvcmZsb3cvdGZqcy1jb3JlJztcbmltcG9ydCB7Z2V0Q29vcmRzWFlaLCBnZXRNYWluSGVhZGVyU3RyaW5nIGFzIG1haW4sIFdlYkdQVVByb2dyYW19IGZyb20gJy4vd2ViZ3B1X3Byb2dyYW0nO1xuaW1wb3J0IHtjb21wdXRlRGlzcGF0Y2gsIGZsYXREaXNwYXRjaExheW91dH0gZnJvbSAnLi93ZWJncHVfdXRpbCc7XG5cbmV4cG9ydCBjbGFzcyBBcmdNaW5NYXhQcm9ncmFtIGltcGxlbWVudHMgV2ViR1BVUHJvZ3JhbSB7XG4gIG91dHB1dFNoYXBlOiBudW1iZXJbXTtcbiAgc2hhZGVyS2V5OiBzdHJpbmc7XG4gIGRpc3BhdGNoTGF5b3V0OiB7eDogbnVtYmVyW119O1xuICBkaXNwYXRjaDogW251bWJlciwgbnVtYmVyLCBudW1iZXJdO1xuICB3b3JrZ3JvdXBTaXplOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0gPSBbNjQsIDEsIDFdO1xuICB2YXJpYWJsZU5hbWVzID0gWyd4J107XG4gIHVuaWZvcm1zID0gJ2luZmluaXR5VmFsdWUgOiBmMzIsJztcbiAgaW5wdXRTaGFwZTogbnVtYmVyW107XG4gIHJlZHVjdGlvbkZhY3RvcjogbnVtYmVyO1xuICBvcDogc3RyaW5nO1xuICBzaXplID0gdHJ1ZTtcbiAgcHJpdmF0ZSB0eXBlOiBzdHJpbmc7XG5cbiAgY29uc3RydWN0b3IoaW5wdXRTaGFwZTogbnVtYmVyW10sIGF4aXM6IG51bWJlciwgcmVkdWNlVHlwZTogJ21pbid8J21heCcpIHtcbiAgICBjb25zdCBheGVzID0gW2F4aXNdO1xuXG4gICAgdGhpcy5vcCA9IHJlZHVjZVR5cGUgPT09ICdtaW4nID8gJzwnIDogJz4nO1xuXG4gICAgLy8gfG91dFNoYXBlfCBpcyB0aGUgc2hhcGUgd2l0aCB0aGUgcmVtb3ZlZCBheGlzXG4gICAgY29uc3QgW291dHB1dFNoYXBlLCByZWR1Y2VTaGFwZV0gPVxuICAgICAgICBiYWNrZW5kX3V0aWwuY29tcHV0ZU91dEFuZFJlZHVjZVNoYXBlcyhpbnB1dFNoYXBlLCBheGVzKTtcblxuICAgIHRoaXMub3V0cHV0U2hhcGUgPSBvdXRwdXRTaGFwZS5sZW5ndGggPT09IDAgPyBbMV0gOiBvdXRwdXRTaGFwZTtcbiAgICB0aGlzLmRpc3BhdGNoTGF5b3V0ID0gZmxhdERpc3BhdGNoTGF5b3V0KHRoaXMub3V0cHV0U2hhcGUpO1xuICAgIC8vIFRoZSBzaGFyZWQgYWxnb3JpdGhtIGlzIG1haW5seSB1c2VkIGZvciBsYXJnZSByZWR1Y2Ugc2l6ZS4gSXQgZnVsbHlcbiAgICAvLyB1dGlsaXplcyB0aGUgdGhyZWFkcyBpbiBvbmUgd29ya2dyb3VwIHRvIGRvIHRoZSByZWR1Y3Rpb24uIEhvd2V2ZXIsXG4gICAgLy8gd2hlbiB0aGUgcmVkdWNlIHNpemUgaXMgdmVyeSBzbWFsbCBvciB0aGUgb3V0cHV0IHNoYXBlIGlzIHRvbyBsYXJnZS4gSXQnc1xuICAgIC8vIGJldHRlciB0byB1c2UgdGhlIHBsYWluIGFsZ29yaXRobSB0byByZWR1Y2UgdGhlIG51bWJlciBvZiB3b3JrZ3JvdXBzIHRvXG4gICAgLy8gc3BlZWR1cC4gVGhlIHRocmV0aG9sZCBjYW4gYmUgZnVydGhlciB0dW5lZC5cbiAgICBpZiAodXRpbC5zaXplRnJvbVNoYXBlKHJlZHVjZVNoYXBlKSA8IDMyIHx8XG4gICAgICAgIHV0aWwuc2l6ZUZyb21TaGFwZShvdXRwdXRTaGFwZSkgPiAxMDAwKSB7XG4gICAgICB0aGlzLnR5cGUgPSAncGxhaW4nO1xuICAgICAgdGhpcy5kaXNwYXRjaCA9IGNvbXB1dGVEaXNwYXRjaChcbiAgICAgICAgICB0aGlzLmRpc3BhdGNoTGF5b3V0LCB0aGlzLm91dHB1dFNoYXBlLCB0aGlzLndvcmtncm91cFNpemUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnR5cGUgPSAnc2hhcmVkJztcbiAgICAgIC8vIEEgd29yayBncm91cCBvbmx5IG91dHB1dHMgYSBkYXRhLCBzbyB3ZSB0cmFuc2ZlciBbMSwgMSwgMV0gdG8gY29tcHV0ZVxuICAgICAgLy8gZGlzcGF0Y2ggc2l6ZS5cbiAgICAgIHRoaXMuZGlzcGF0Y2ggPVxuICAgICAgICAgIGNvbXB1dGVEaXNwYXRjaCh0aGlzLmRpc3BhdGNoTGF5b3V0LCB0aGlzLm91dHB1dFNoYXBlLCBbMSwgMSwgMV0pO1xuICAgIH1cblxuICAgIHRoaXMuaW5wdXRTaGFwZSA9IGlucHV0U2hhcGU7XG4gICAgdGhpcy5zaGFkZXJLZXkgPSBgYXJnTWluTWF4XyR7dGhpcy5vcH1fJHt0aGlzLnR5cGV9YDtcbiAgfVxuXG4gIGdldFVzZXJDb2RlKCk6IHN0cmluZyB7XG4gICAgY29uc3Qgd29ya2dyb3VwU2l6ZVggPSB0aGlzLndvcmtncm91cFNpemVbMF07XG4gICAgY29uc3QgZ2V0SW5wdXRTaGFwZUxhc3REaW0gPSAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5pbnB1dFNoYXBlLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gJ3VuaWZvcm1zLnhTaGFwZSc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gYHVuaWZvcm1zLnhTaGFwZS4ke2dldENvb3Jkc1hZWih0aGlzLmlucHV0U2hhcGUubGVuZ3RoIC0gMSl9YDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3Qgc3BsaXRPdXRwdXRDb29yZHMgPSAoKSA9PiB7XG4gICAgICBsZXQgc25pcHBldCA9ICcnO1xuICAgICAgaWYgKHRoaXMub3V0cHV0U2hhcGUubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGlmICh0aGlzLmlucHV0U2hhcGUubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgc25pcHBldCArPSAnb3V0cHV0Q29vcmRzLCc7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5vdXRwdXRTaGFwZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHNuaXBwZXQgKz0gYG91dHB1dENvb3Jkcy4ke2dldENvb3Jkc1hZWihpKX0sYDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHNuaXBwZXQ7XG4gICAgfTtcblxuICAgIGlmICh0aGlzLnR5cGUgPT09ICdzaGFyZWQnKSB7XG4gICAgICBjb25zdCBzaGFyZWRNZW1vcnlTbmlwcGV0ID0gYFxuICAgICAgdmFyPHdvcmtncm91cD4geEJlc3RJbmRpY2VzIDogYXJyYXk8aTMyLCAke3dvcmtncm91cFNpemVYfT47XG4gICAgICB2YXI8d29ya2dyb3VwPiB4QmVzdFZhbHVlcyA6IGFycmF5PGYzMiwgJHt3b3JrZ3JvdXBTaXplWH0+O1xuICAgIGA7XG4gICAgICBjb25zdCB1c2VyQ29kZSA9IGBcbiAgICAgIGZuIERJVl9DRUlMKGEgOiB1MzIsIGIgOiB1MzIpIC0+IHUzMiB7XG4gICAgICAgIHJldHVybiAoKGEgLSAxdSkgLyBiICsgMXUpO1xuICAgICAgfVxuXG4gICAgICAke3NoYXJlZE1lbW9yeVNuaXBwZXR9XG5cbiAgICAgICR7bWFpbignaW5kZXgnKX0ge1xuICAgICAgICBsZXQgb3V0cHV0SW5kZXggPSBpbmRleCAvICR7d29ya2dyb3VwU2l6ZVh9O1xuICAgICAgICBsZXQgcmVkdWNlTGVuZ3RoID0gJHtnZXRJbnB1dFNoYXBlTGFzdERpbSgpfTtcblxuICAgICAgICB2YXIgYmVzdEluZGV4ID0gaTMyKGxvY2FsSWQueCk7XG4gICAgICAgIHZhciBiZXN0VmFsdWUgPSB1bmlmb3Jtcy5pbmZpbml0eVZhbHVlO1xuICAgICAgICBsZXQgb3V0cHV0Q29vcmRzID0gZ2V0Q29vcmRzRnJvbUluZGV4KG91dHB1dEluZGV4KTtcbiAgICAgICAgZm9yICh2YXIgayA9IGkzMihsb2NhbElkLngpOyBrIDwgcmVkdWNlTGVuZ3RoICYmIG91dHB1dEluZGV4IDwgdW5pZm9ybXMuc2l6ZTtcbiAgICAgICAgICAgIGsgPSBrICsgJHt3b3JrZ3JvdXBTaXplWH0pIHtcbiAgICAgICAgICBsZXQgY2FuZGlkYXRlID0gZ2V0WCgke3NwbGl0T3V0cHV0Q29vcmRzKCl9IGspO1xuICAgICAgICAgIGlmICghaXNuYW4oY2FuZGlkYXRlKSAmJiBjYW5kaWRhdGUgJHt0aGlzLm9wfSBiZXN0VmFsdWUpIHtcbiAgICAgICAgICAgIGJlc3RWYWx1ZSA9IGNhbmRpZGF0ZTtcbiAgICAgICAgICAgIGJlc3RJbmRleCA9IGs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHhCZXN0VmFsdWVzW2xvY2FsSWQueF0gPSBiZXN0VmFsdWU7XG4gICAgICAgIHhCZXN0SW5kaWNlc1tsb2NhbElkLnhdID0gYmVzdEluZGV4O1xuICAgICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgICAgICAgdmFyIHJlZHVjZVNpemUgPSBtaW4odTMyKHJlZHVjZUxlbmd0aCksICR7d29ya2dyb3VwU2l6ZVh9dSk7XG4gICAgICAgIGZvciAodmFyIGN1cnJlbnRTaXplID0gcmVkdWNlU2l6ZSAvIDJ1OyByZWR1Y2VTaXplID4gMXU7XG4gICAgICAgICAgICBjdXJyZW50U2l6ZSA9IHJlZHVjZVNpemUgLyAydSkge1xuICAgICAgICAgIGxldCBpbnRlcnZhbCA9IERJVl9DRUlMKHJlZHVjZVNpemUsIDJ1KTtcbiAgICAgICAgICBpZiAobG9jYWxJZC54IDwgY3VycmVudFNpemUpIHtcbiAgICAgICAgICAgIGxldCBjYW5kaWRhdGUgPSB4QmVzdFZhbHVlc1tsb2NhbElkLnggKyBpbnRlcnZhbF07XG4gICAgICAgICAgICBpZiAoY2FuZGlkYXRlICR7dGhpcy5vcH0gYmVzdFZhbHVlKSB7XG4gICAgICAgICAgICAgIGJlc3RWYWx1ZSA9IGNhbmRpZGF0ZTtcbiAgICAgICAgICAgICAgeEJlc3RWYWx1ZXNbbG9jYWxJZC54XSA9IGJlc3RWYWx1ZTtcbiAgICAgICAgICAgICAgeEJlc3RJbmRpY2VzW2xvY2FsSWQueF0gPSB4QmVzdEluZGljZXNbbG9jYWxJZC54ICsgaW50ZXJ2YWxdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZWR1Y2VTaXplID0gaW50ZXJ2YWw7XG4gICAgICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxvY2FsSWQueCA9PSAwdSAmJiBvdXRwdXRJbmRleCA8IHVuaWZvcm1zLnNpemUpIHtcbiAgICAgICAgICBzZXRPdXRwdXRBdEluZGV4STMyKG91dHB1dEluZGV4LCB4QmVzdEluZGljZXNbbG9jYWxJZC54XSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBgO1xuICAgICAgcmV0dXJuIHVzZXJDb2RlO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB1c2VyQ29kZSA9IGBcbiAgICAgICR7bWFpbignaW5kZXgnKX0ge1xuICAgICAgICBpZiAoaW5kZXggPCB1bmlmb3Jtcy5zaXplKSB7XG4gICAgICAgICAgbGV0IG91dHB1dENvb3JkcyA9IGdldENvb3Jkc0Zyb21JbmRleChpbmRleCk7XG4gICAgICAgICAgdmFyIGJlc3RJbmRleCA9IDA7XG4gICAgICAgICAgdmFyIGJlc3RWYWx1ZSA9IGdldFgoJHtzcGxpdE91dHB1dENvb3JkcygpfSAwKTtcbiAgICAgICAgICBsZXQgcmVkdWNlTGVuZ3RoID0gJHtnZXRJbnB1dFNoYXBlTGFzdERpbSgpfTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHJlZHVjZUxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY2FuZGlkYXRlID0gZ2V0WCgke3NwbGl0T3V0cHV0Q29vcmRzKCl9IGkpO1xuICAgICAgICAgICAgaWYgKGNhbmRpZGF0ZSAke3RoaXMub3B9IGJlc3RWYWx1ZSkge1xuICAgICAgICAgICAgICBiZXN0VmFsdWUgPSBjYW5kaWRhdGU7XG4gICAgICAgICAgICAgIGJlc3RJbmRleCA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHNldE91dHB1dEF0SW5kZXhJMzIoaW5kZXgsIGJlc3RJbmRleCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGA7XG4gICAgICByZXR1cm4gdXNlckNvZGU7XG4gICAgfVxuICB9XG59XG4iXX0=