/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
import { backend_util, util } from '@tensorflow/tfjs-core';
import { symbolicallyComputeStrides } from './shader_util';
export const compileProgram = (device, program, inputsData, output) => {
    const outputData = { dtype: output.dtype, shape: output.shape };
    const source = makeShader(inputsData, outputData, program);
    const module = device.createShaderModule({ code: source, label: program.constructor.name });
    const pipeline = device.createComputePipeline({
        compute: { module, entryPoint: '_start' },
        label: program.constructor.name,
        layout: 'auto'
    });
    return pipeline;
};
export function getCoordsDataType(rank) {
    if (rank <= 1) {
        return 'i32';
    }
    else if (rank === 2) {
        return `vec2<i32>`;
    }
    else if (rank === 3) {
        return `vec3<i32>`;
    }
    else if (rank === 4) {
        return `vec4<i32>`;
    }
    else if (rank === 5) {
        return `vec5`;
    }
    else if (rank === 6) {
        return `vec6`;
    }
    else {
        throw Error(`GPU for rank ${rank} is not yet supported`);
    }
}
export function getCoordsXYZ(index) {
    if (index === 0) {
        return 'x';
    }
    else if (index === 1) {
        return 'y';
    }
    else if (index === 2) {
        return 'z';
    }
    else if (index === 3) {
        return 'w';
    }
    else if (index === 4) {
        return 'u';
    }
    else if (index === 5) {
        return 'v';
    }
    else {
        throw Error(`Index ${index} is not yet supported`);
    }
}
export function getMainHeaderString(...params) {
    let snippet;
    switch (params.length) {
        case 0:
            snippet = `
        fn main()
      `;
            break;
        case 1:
            snippet = `
        fn main(${params[0]} : i32)
      `;
            break;
        default:
            throw Error('Unreachable');
    }
    return snippet;
}
export function getStartHeaderString(useGlobalIndex, program) {
    let snippet;
    snippet = `
     ${getWorkgroupSizeString(program)}
      fn _start(@builtin(local_invocation_id) LocalId : vec3<u32>,
                @builtin(global_invocation_id) GlobalId : vec3<u32>,
                @builtin(local_invocation_index) LocalIndex: u32,
                @builtin(workgroup_id) WorkgroupId : vec3<u32>,
                @builtin(num_workgroups) NumWorkgroups : vec3<u32>) {
        localId = LocalId;
        localIndex = LocalIndex;
        globalId = GlobalId;
        numWorkgroups = NumWorkgroups;
        workgroupId = WorkgroupId;
        ${useGlobalIndex ? `main(getGlobalIndex());` : `main();`};
      }
    `;
    return snippet;
}
export function getWorkgroupSizeString(program) {
    return `
  @compute @workgroup_size(${program.workgroupSize[0]}, ${program.workgroupSize[1]}, ${program.workgroupSize[2]})
`;
}
function makeShader(inputInfo, outputData, program) {
    const prefixSnippets = [];
    const flatWorkgroupSize = program.workgroupSize[0] *
        program.workgroupSize[1] * program.workgroupSize[2];
    prefixSnippets.push(`

      var<private> localId: vec3<u32>;
      var<private> localIndex: u32;
      var<private> globalId: vec3<u32>;
      var<private> numWorkgroups: vec3<u32>;
      var<private> workgroupId: vec3<u32>;

      // Only used when the y/z dimension of workgroup size is 1.
      fn getGlobalIndex() -> i32 {
        ${isFlatDispatch(program) ?
        `  return i32(globalId.x);` :
        `  return i32((workgroupId.z * numWorkgroups.x * numWorkgroups.y +
                workgroupId.y * numWorkgroups.x + workgroupId.x) * ${flatWorkgroupSize}u +
                localIndex);
        `}
      }
    `);
    if (program.isFromPixels) {
        prefixSnippets.push(`
        struct Uniform {
          size            : i32,
          numChannels     : i32,
          outShapeStrides : vec2<i32>,
        };

        @group(0) @binding(0) var<storage, read_write> result: array<${mapToWgslTypes(outputData.dtype, program.isVec4)}>;
        @group(0) @binding(2) var<uniform> uniforms: Uniform;
      `);
        const useGlobalIndex = isFlatDispatchLayout(program);
        return [
            commonSnippet,
            prefixSnippets.join('\n'),
            getCoordsFromIndexSnippet(outputData.shape),
            program.getUserCode(),
            getStartHeaderString(useGlobalIndex, program),
        ].join('\n');
    }
    let uniformDeclaration = 'struct Uniforms { NAN : f32, INFINITY : f32, ';
    program.variableNames.forEach((x, i) => {
        const perDataType = getCoordsDataType(inputInfo[i].shape.length);
        uniformDeclaration +=
            `${x.charAt(0).toLowerCase() + x.slice(1)}Shape : ${perDataType}, `;
    });
    const outputDataType = getCoordsDataType(outputData.shape.length);
    uniformDeclaration += `outShape : ${outputDataType}, `;
    const stridesLength = outputData.shape.length - 1;
    const stridesDataType = getCoordsDataType(stridesLength);
    uniformDeclaration += `
         outShapeStrides: ${stridesDataType}, `;
    if (program.size) {
        uniformDeclaration += 'size : i32, ';
    }
    if (program.uniforms) {
        uniformDeclaration += program.uniforms;
    }
    uniformDeclaration += '};';
    uniformDeclaration = insertAlignment(uniformDeclaration);
    prefixSnippets.push(uniformDeclaration);
    // Output buffer.
    if (program.atomic) {
        prefixSnippets.push(`
      @group(0) @binding(0) var<storage, read_write> result: array<atomic<i32>>;
    `);
    }
    else {
        prefixSnippets.push(`
      @group(0) @binding(0) var<storage, read_write> result: array<${mapToWgslTypes(outputData.dtype, program.isVec4)}>;
    `);
    }
    program.variableNames.forEach((x, i) => {
        prefixSnippets.push(`
      @group(0) @binding(${1 + i}) var<storage, read> ${x}: array<${program.variableTypes ?
            program.variableTypes[i] :
            mapToWgslTypes(inputInfo[i].dtype, program.isVec4)}>;
        `);
    });
    if (uniformDeclaration !== '') {
        prefixSnippets.push(`
      @group(0) @binding(${1 + program.variableNames.length}) var<uniform> uniforms: Uniforms;
      `);
    }
    const coordsSnippet = getOutputCoordsSnippet(outputData.shape, program.dispatchLayout);
    const sources = [
        commonSnippet, prefixSnippets.join('\n') + isInfSnippet,
        getCoordsFromIndexSnippet(outputData.shape), coordsSnippet,
        getOutputIndexFromCoordsSnippet(outputData.shape.length)
    ];
    if (!program.atomic) {
        sources.push(setOutputSnippet(outputData.shape, outputData.dtype, program.isVec4));
    }
    const inputSnippet = inputInfo
        .map((x, i) => getInputSnippet(x, outputData.shape, program.variableTypes ?
        (program.variableTypes[i] === 'vec4<f32>') :
        program.isVec4, program.dispatchLayout.x.length === outputData.shape.length))
        .join('\n');
    sources.push(inputSnippet);
    sources.push(program.getUserCode());
    const useGlobalIndex = isFlatDispatchLayout(program);
    sources.push(getStartHeaderString(useGlobalIndex, program));
    const source = sources.join('\n');
    return source;
}
export function makeShaderKey(program, shapes, inputsData, output) {
    let key = program.shaderKey;
    if (program.isFromPixels) {
        return key;
    }
    const types = inputsData.map(d => d.dtype).concat(output.dtype);
    const broadcastDims = inputsData.map(d => backend_util.getBroadcastDims(d.shape, output.shape));
    const inputShapesEqualsOutShape = inputsData.map(d => util.arraysEqual(d.shape, output.shape)).join('_');
    const broadcastDimsKey = broadcastDims.map(d => d.join('_')).join(';');
    const flatDispatchString = isFlatDispatch(program) ? 'flatDispatch' : '';
    key += '_' + (program.workgroupSize ? program.workgroupSize.join(',') : '') +
        shapes.map(shape => shape.length).join(',') + types.join(',') +
        program.variableNames.join(',') + broadcastDimsKey +
        inputShapesEqualsOutShape + flatDispatchString;
    return key;
}
const commonSnippet = `
  struct vec5 {x: i32, y: i32, z: i32, w: i32, u: i32};
  struct vec6 {x: i32, y: i32, z: i32, w: i32, u: i32, v: i32};

  // Checks whether coordinates lie within the bounds of the shape.
  fn coordsInBounds2D(coord : vec2<i32>, shape : vec2<i32>) -> bool {
    return all(coord >= vec2<i32>(0)) && all(coord < shape);
  }
  fn coordsInBounds3D(coord : vec3<i32>, shape : vec3<i32>) -> bool {
    return all(coord >= vec3<i32>(0)) && all(coord < shape);
  }
  fn coordsInBounds4D(coord : vec4<i32>, shape : vec4<i32>) -> bool {
    return all(coord >= vec4<i32>(0)) && all(coord < shape);
  }

  fn getIndexFromCoords1D(coord : i32, shape : i32) -> i32 {
    return coord;
  }
  fn getIndexFromCoords2D(coords : vec2<i32>, shape : vec2<i32>) -> i32 {
    return dot(coords, vec2<i32>(shape.y, 1));
  }
  fn getIndexFromCoords3D(coords : vec3<i32>, shape : vec3<i32>) -> i32 {
    return dot(coords, vec3<i32>(shape.y * shape.z, shape.z, 1));
  }
  fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {
    return dot(coords, vec4<i32>(
        shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));
  }
  fn getIndexFromCoords5D(coords : vec5, shape : vec5) -> i32 {
    let shapeStrides: vec5 = vec5(shape.y * shape.z * shape.w * shape.u, shape.z * shape.w * shape.u, shape.w * shape.u, shape.u, 1);
    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u;
  }
  fn getIndexFromCoords6D(coords : vec6, shape : vec6) -> i32 {
    let shapeStrides: vec6 = vec6(shape.y * shape.z * shape.w * shape.u * shape.v, shape.z * shape.w * shape.u * shape.v, shape.w * shape.u * shape.v, shape.u * shape.v, shape.v, 1);
    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u + coords.v*shapeStrides.v;
  }

  fn idiv(a: i32, b: i32, sign: f32) -> i32 {
    var res: i32 = a / b;
    let modulo: i32 = a % b;
    if (sign < 0. && modulo != 0) {
      res = res - 1;
    }
    return res;
  }

  // NaN defination in IEEE 754-1985 is :
  //   - sign = either 0 or 1.
  //   - biased exponent = all 1 bits.
  //   - fraction = anything except all 0 bits (since all 0 bits represents infinity).
  // https://en.wikipedia.org/wiki/IEEE_754-1985#Representation_of_non-numbers
  fn isnan(val: f32) -> bool {
    let floatToUint: u32 = bitcast<u32>(val);
    return (floatToUint & 0x7fffffffu) > 0x7f800000u;
  }
  fn isnanVec4(val : vec4<f32>) -> vec4<bool> {
    let floatToUint: vec4<u32> = bitcast<vec4<u32>>(val);
    return (floatToUint & vec4<u32>(0x7fffffffu)) > vec4<u32>(0x7f800000u);
  }
`;
const isInfSnippet = `
  fn isinf(val: f32) -> bool {
    return abs(val) == uniforms.INFINITY;
  }
`;
/**
 * Derives logical coordinates from a flat index. Performs integer division
 * with each stride and decrements the index until the index equals the final
 * dimension coordinate.
 */
function getCoordsFromIndexSnippet(shape) {
    const rank = shape.length;
    if (rank <= 1) {
        return `fn getCoordsFromIndex(index : i32) -> i32 { return index; }`;
    }
    const strides = util.computeStrides(shape);
    const dtype = getCoordsDataType(rank);
    const coords = [];
    for (let i = 0; i < rank; i++) {
        coords.push(`d${i}`);
    }
    if (strides.length === 1) {
        return `    fn getCoordsFromIndex(index : i32) -> vec2<i32> {
      let d0 = index / uniforms.outShapeStrides; let d1 = index - d0 * uniforms.outShapeStrides;
      return vec2<i32>(d0, d1);
    }`;
    }
    let snippet;
    snippet = 'var index2 = index;' +
        strides
            .map((_, i) => {
            const line1 = `let ${coords[i]} = index2 / uniforms.outShapeStrides.${getCoordsXYZ(i)}`;
            const line2 = i === strides.length - 1 ?
                `let ${coords[i + 1]} = index2 - ${coords[i]} * uniforms.outShapeStrides.${getCoordsXYZ(i)}` :
                `index2 = index2 - ${coords[i]} * uniforms.outShapeStrides.${getCoordsXYZ(i)}`;
            return `${line1}; ${line2};`;
        })
            .join('');
    return `
    fn getCoordsFromIndex(index : i32) -> ${dtype} {
      ${snippet}
      return ${dtype}(${coords.join(',')});
    }
  `;
}
function getInputAtCoordsSnippet(inputInfo, isVec4) {
    const texName = inputInfo.name;
    const rank = inputInfo.shape.length;
    const type = getCoordsDataType(rank);
    const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);
    const dims = ['d0', 'd1', 'd2', 'd3', 'd4', 'd5'].slice(0, rank);
    const inputs = dims.map(d => `${d} : i32`).join(', ');
    if (rank < 1) {
        if (isVec4) {
            return `
        fn ${funcName}() -> vec4<f32> {
          return vec4<f32>(${texName}[0]);
        }
      `;
        }
        return `
      fn ${funcName}() ->f32 {
        return f32(${texName}[0]);
      }
    `;
    }
    const shapeStr = `uniforms.${texName.charAt(0).toLowerCase() + texName.slice(1)}Shape`;
    let rankStr = `${rank}D`;
    if (rank === 0) {
        rankStr = '1D';
    }
    if (isVec4) {
        return `
      fn ${funcName}(${inputs}) -> vec4<f32> {
        return vec4<f32>(${texName}[getIndexFromCoords${rankStr}(${type}(${dims.join(',')}),
          ${shapeStr}) / 4]);
      }
      `;
    }
    return `
    fn ${funcName}(${inputs}) -> f32 {
      return f32(${texName}[getIndexFromCoords${rankStr}(${type}(${dims.join(',')}),
        ${shapeStr})]);
    }
   `;
}
function getInputByOutputSnippet(inputInfo, outShape, isVec4, isFlatDispatchLayout) {
    const texName = inputInfo.name;
    const texFuncSnippet = texName.charAt(0).toUpperCase() + texName.slice(1);
    const funcName = 'get' + texFuncSnippet + 'ByOutput';
    const inRank = inputInfo.shape.length;
    const outRank = outShape.length;
    const type = getCoordsDataType(outRank);
    // If the inShape equals the outShape and the dispatch layout is flat, we can
    // directly use |gl_GlobalInvocationID.x| as the index and don't need coords
    // conversion between these two shapes.
    if (util.arraysEqual(inputInfo.shape, outShape) && isFlatDispatchLayout) {
        if (isVec4) {
            return `
      fn ${funcName}Index(globalIndex : i32) -> vec4<f32> {
        return vec4<f32>(${texName}[globalIndex]);
      }

      fn ${funcName}Coords(coords : ${type}) -> vec4<f32> {
        return vec4<f32>(${texName}[${outRank > 1 ? 'getOutputIndexFromCoords(coords)' : 'coords'} / 4]);
      }
      `;
        }
        else {
            return `
    fn ${funcName}Index(globalIndex : i32) -> f32 {
      return f32(${texName}[globalIndex]);
    }

    fn ${funcName}Coords(coords : ${type}) -> f32 {
      return f32(${texName}[${outRank > 1 ? 'getOutputIndexFromCoords(coords)' : 'coords'}]);
    }
    `;
        }
    }
    const broadcastDims = backend_util.getBroadcastDims(inputInfo.shape, outShape);
    const rankDiff = outRank - inRank;
    let coordsSnippet = '';
    if (inRank === 0) {
        if (isVec4) {
            return `
    fn ${funcName}Index(globalIndex : i32) -> vec4<f32> {
      return get${texFuncSnippet}();
    }

    fn ${funcName}Coords(coords : ${type}) -> vec4<f32> {
      return get${texFuncSnippet}();
    }
  `;
        }
        return `
    fn ${funcName}Index(globalIndex : i32) -> f32{
      return get${texFuncSnippet}();
    }

    fn ${funcName}Coords(coords : ${type}) -> f32{
      return get${texFuncSnippet}();
    }
  `;
    }
    else {
        if (outRank < 2 && broadcastDims.length >= 1) {
            coordsSnippet = 'coords = 0;';
        }
        else {
            coordsSnippet =
                broadcastDims.map(d => `coords.${getCoordsXYZ(d + rankDiff)} = 0;`)
                    .join('\n');
        }
    }
    let unpackedCoordsSnippet = '';
    if (outRank < 2 && inRank > 0) {
        unpackedCoordsSnippet = 'coords';
    }
    else {
        if (outRank > 1) {
            const coordsType = getCoordsDataType(inRank);
            const coordsValues = inputInfo.shape.map((s, i) => `coords.${getCoordsXYZ(i + rankDiff)}`)
                .join(', ');
            unpackedCoordsSnippet = `${coordsType}(${coordsValues})`;
        }
        else {
            unpackedCoordsSnippet = 'coords';
        }
    }
    const shapeStr = `uniforms.${texName.charAt(0).toLowerCase() + texName.slice(1)}Shape`;
    const rankStr = `${inRank}D`;
    if (isVec4) {
        return `
    fn ${funcName}Index(globalIndex : i32) -> vec4<f32> {
      var coords = getCoordsFromIndex(globalIndex);
      ${coordsSnippet}
      return ${texName}[getIndexFromCoords${rankStr}(${unpackedCoordsSnippet}, ${shapeStr}) / 4];
    }

    fn ${funcName}Coords(coordsIn : ${type}) -> vec4<f32> {
      var coords = coordsIn;
      ${coordsSnippet}
      return ${texName}[getIndexFromCoords${rankStr}(${unpackedCoordsSnippet}, ${shapeStr}) / 4];
    }
  `;
    }
    return `
  fn ${funcName}Index(globalIndex : i32) -> f32 {
    var coords = getCoordsFromIndex(globalIndex);
    ${coordsSnippet}
    return f32(${texName}[getIndexFromCoords${rankStr}(${unpackedCoordsSnippet}, ${shapeStr})]);
  }

  fn ${funcName}Coords(coordsIn : ${type}) -> f32 {
    var coords = coordsIn;
    ${coordsSnippet}
    return f32(${texName}[getIndexFromCoords${rankStr}(${unpackedCoordsSnippet}, ${shapeStr})]);
  }
`;
}
function getInputSnippet(inputInfo, outShape, isVec4, isFlatDispatchLayout) {
    let res = getInputAtCoordsSnippet(inputInfo, isVec4);
    const inShape = inputInfo.shape;
    if (inShape.length <= outShape.length) {
        res += getInputByOutputSnippet(inputInfo, outShape, isVec4, isFlatDispatchLayout);
    }
    return res;
}
/**
 * Generates getOutputCoords() function that computes output coordinates from
 * dispatch geometry to reduce arithmetic.
 */
function getOutputCoordsSnippet(outShape, dispatchLayout) {
    const { x, y = [], z = [] } = dispatchLayout;
    const outRank = outShape.length;
    const rank = x.length + y.length + z.length;
    // getOutputCoords is only meaningful when the output rank is same with
    // dispatch layout rank.
    if (rank !== outRank) {
        return '';
    }
    if (x.length === outRank) {
        const dtype = getCoordsDataType(outRank);
        const snippet = `fn getOutputCoords() -> ${dtype}{
    let globalIndex = getGlobalIndex();
    return getCoordsFromIndex(globalIndex);
  }
  `;
        return snippet;
    }
    let gatherDimensionsStr = '';
    const dims = [x, y, z];
    for (let i = 0; i < dims.length; i++) {
        const arr = dims[i];
        if (arr.length === 0) {
            continue;
        }
        if (arr.length === 1) {
            gatherDimensionsStr += `let d${arr[0]} = i32(globalId[${i}]);`;
        }
        else {
            const strides = symbolicallyComputeStrides(arr, 'uniforms.outShape');
            gatherDimensionsStr += `var index${i} = i32(globalId[${i}]);`;
            for (let j = 0; j < strides.length; j++) {
                gatherDimensionsStr += `let d${arr[j]} = index${i} / ${strides[j]};`;
                if (j === strides.length - 1) {
                    gatherDimensionsStr += `let d${arr[j + 1]} = ` +
                        `index${i} - d${arr[j]} * ${strides[j]};`;
                }
                else {
                    gatherDimensionsStr +=
                        `index${i} = index${i} - d${arr[j]} * ${strides[j]};`;
                }
            }
        }
    }
    const dimensions = [];
    for (let i = 0; i < rank; i++) {
        dimensions.push(`d${i}`);
    }
    const dtype = getCoordsDataType(rank);
    let snippet = `fn getOutputCoords() -> ${dtype} {
  ${gatherDimensionsStr}
`;
    if (dimensions.length === 0) {
        snippet += `return ${dtype}(0); }`;
    }
    else {
        snippet += `return ${dtype}(${dimensions.join(',')}); }`;
    }
    return snippet;
}
function getOutputIndexFromCoordsSnippet(outRank) {
    let snippet = '';
    switch (outRank) {
        case 0:
        case 1:
            snippet += `
        fn getOutputIndexFromCoords(coords : i32) -> i32 {
          return coords;
        }
        `;
            break;
        case 2:
            snippet += `
        fn getOutputIndexFromCoords(coords : vec2<i32>) -> i32 {
          return dot(coords, vec2<i32>(uniforms.outShapeStrides, 1));
        }
        `;
            break;
        case 3:
            snippet += `
        fn getOutputIndexFromCoords(coords : vec3<i32>) -> i32 {
          return dot(coords, vec3<i32>(uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, 1));
        }
        `;
            break;
        case 4:
            snippet += `
        fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {
          return dot(coords, vec4<i32>(
            uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, uniforms.outShapeStrides.z, 1));
        }
        `;
            break;
        case 5:
            snippet += `
        fn getOutputIndexFromCoords(coords : vec5) -> i32 {
          return coords.x * uniforms.outShapeStrides.x +
              coords.y * uniforms.outShapeStrides.y +
              coords.z * uniforms.outShapeStrides.z +
              coords.w * uniforms.outShapeStrides.w +
              coords.u;
        }
        `;
            break;
        case 6:
            snippet += `
        fn getOutputIndexFromCoords(coords : vec6) -> i32 {
          return coords.x * uniforms.outShapeStrides.x +
              coords.y * uniforms.outShapeStrides.y +
              coords.z * uniforms.outShapeStrides.z +
              coords.w * uniforms.outShapeStrides.w +
              coords.u * uniforms.outShapeStrides.u +
              coords.v;
        }
        `;
            break;
        default:
            util.assert(false, () => `Unsupported ${outRank}D shape`);
            break;
    }
    return snippet;
}
function isFlatDispatch(program) {
    return program.dispatch[1] === 1 && program.dispatch[2] === 1;
}
export function mapToWgslTypes(type, isVec4) {
    if (type === 'float32') {
        return isVec4 ? 'vec4<f32>' : 'f32';
    }
    else if (type === 'int32') {
        return isVec4 ? 'vec4<i32>' : 'i32';
    }
    else if (type === 'bool') {
        // Type 'bool' cannot be used in storage class,
        // https://www.w3.org/TR/WGSL/#host-shareable-types.
        return isVec4 ? 'vec4<i32>' : 'i32';
    }
    return type;
}
function setOutputSnippet(outShape, outBufferType, isVec4) {
    const outRank = outShape.length;
    const wgslType = mapToWgslTypes(outBufferType, isVec4);
    let snippet;
    if (isVec4) {
        snippet = `fn setOutputAtIndex(flatIndex : i32, value : vec4<f32>) {
      result[flatIndex] = ${wgslType}(value);
    }
    fn setOutputAtIndexI32(flatIndex : i32, value : vec4<i32>) {
      result[flatIndex] = ${wgslType}(value);
    }`;
    }
    else {
        snippet = `fn setOutputAtIndex(flatIndex : i32, value : f32) {
      result[flatIndex] = ${wgslType}(value);
    }
    fn setOutputAtIndexI32(flatIndex : i32, value : i32) {
      result[flatIndex] = ${wgslType}(value);
    }`;
    }
    if (outRank >= 2) {
        const dims = ['d0', 'd1', 'd2', 'd3', 'd4', 'd5'].slice(0, outRank);
        const type = getCoordsDataType(outRank);
        if (isVec4) {
            snippet += `
      fn setOutputAtCoords(${dims.map(d => `${d} : i32`).join(', ')}, value : vec4<f32>) {
        let flatIndex = getOutputIndexFromCoords(${type}(${dims.join(', ')}));
        setOutputAtIndex(flatIndex / 4, value);
      }
      fn setOutputAtCoordsI32(${dims.map(d => `${d} : i32`).join(', ')}, value : vec4<i32>) {
        let flatIndex = getOutputIndexFromCoords(${type}(${dims.join(', ')}));
        setOutputAtIndexI32(flatIndex / 4, value);
      }
    `;
        }
        else {
            snippet += `
      fn setOutputAtCoords(${dims.map(d => `${d} : i32`).join(', ')}, value : f32) {
        let flatIndex = getOutputIndexFromCoords(${type}(${dims.join(', ')}));
        setOutputAtIndex(flatIndex, value);
      }
      fn setOutputAtCoordsI32(${dims.map(d => `${d} : i32`).join(', ')}, value : i32) {
        let flatIndex = getOutputIndexFromCoords(${type}(${dims.join(', ')}));
        setOutputAtIndexI32(flatIndex, value);
      }
    `;
        }
    }
    return snippet;
}
function insertAlignment(uniformShader) {
    // insert alignment when current pattern is vec5 or vec6
    const curInsertRe = /(\w+)\s*:\s*vec(5|6)/g;
    uniformShader = uniformShader.replace(curInsertRe, (match) => {
        return '@align(16) ' + match;
    });
    // insert alignment when previous pattern is vec5 or vec6
    const preInsertRe = /vec(5|6)\s*,\s*(\w+)/g;
    uniformShader = uniformShader.replace(preInsertRe, (_, p1, p2) => {
        return `vec${p1}, @align(16) ${p2}`;
    });
    return uniformShader;
}
function isFlatDispatchLayout(program) {
    if (program.dispatchLayout.hasOwnProperty('y') &&
        program.dispatchLayout.y.length !== 0) {
        return false;
    }
    if (program.dispatchLayout.hasOwnProperty('z') &&
        program.dispatchLayout.z.length !== 0) {
        return false;
    }
    return true;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2ViZ3B1X3Byb2dyYW0uanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi90ZmpzLWJhY2tlbmQtd2ViZ3B1L3NyYy93ZWJncHVfcHJvZ3JhbS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7O0dBZUc7QUFFSCxPQUFPLEVBQUMsWUFBWSxFQUF3QyxJQUFJLEVBQUMsTUFBTSx1QkFBdUIsQ0FBQztBQUUvRixPQUFPLEVBQUMsMEJBQTBCLEVBQUMsTUFBTSxlQUFlLENBQUM7QUFrQ3pELE1BQU0sQ0FBQyxNQUFNLGNBQWMsR0FDdkIsQ0FBQyxNQUFpQixFQUFFLE9BQXNCLEVBQUUsVUFBdUIsRUFDbEUsTUFBa0IsRUFBc0IsRUFBRTtJQUN6QyxNQUFNLFVBQVUsR0FBRyxFQUFDLEtBQUssRUFBRSxNQUFNLENBQUMsS0FBSyxFQUFFLEtBQUssRUFBRSxNQUFNLENBQUMsS0FBSyxFQUFDLENBQUM7SUFDOUQsTUFBTSxNQUFNLEdBQUcsVUFBVSxDQUFDLFVBQVUsRUFBRSxVQUFVLEVBQUUsT0FBTyxDQUFDLENBQUM7SUFDM0QsTUFBTSxNQUFNLEdBQUcsTUFBTSxDQUFDLGtCQUFrQixDQUNwQyxFQUFDLElBQUksRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUFFLE9BQU8sQ0FBQyxXQUFXLENBQUMsSUFBSSxFQUFDLENBQUMsQ0FBQztJQUNyRCxNQUFNLFFBQVEsR0FBRyxNQUFNLENBQUMscUJBQXFCLENBQUM7UUFDNUMsT0FBTyxFQUFFLEVBQUMsTUFBTSxFQUFFLFVBQVUsRUFBRSxRQUFRLEVBQUM7UUFDdkMsS0FBSyxFQUFFLE9BQU8sQ0FBQyxXQUFXLENBQUMsSUFBSTtRQUMvQixNQUFNLEVBQUUsTUFBTTtLQUNmLENBQUMsQ0FBQztJQUVILE9BQU8sUUFBUSxDQUFDO0FBQ2xCLENBQUMsQ0FBQztBQUVOLE1BQU0sVUFBVSxpQkFBaUIsQ0FBQyxJQUFZO0lBQzVDLElBQUksSUFBSSxJQUFJLENBQUMs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LGFBQXFCO0lBQzVDLHdEQUF3RDtJQUN4RCxNQUFNLFdBQVcsR0FBRyx1QkFBdUIsQ0FBQztJQUM1QyxhQUFhLEdBQUcsYUFBYSxDQUFDLE9BQU8sQ0FBQyxXQUFXLEVBQUUsQ0FBQyxLQUFLLEVBQUUsRUFBRTtRQUMzRCxPQUFPLGFBQWEsR0FBRyxLQUFLLENBQUM7SUFDL0IsQ0FBQyxDQUFDLENBQUM7SUFFSCx5REFBeUQ7SUFDekQsTUFBTSxXQUFXLEdBQUcsdUJBQXVCLENBQUM7SUFDNUMsYUFBYSxHQUFHLGFBQWEsQ0FBQyxPQUFPLENBQUMsV0FBVyxFQUFFLENBQUMsQ0FBQyxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRTtRQUMvRCxPQUFPLE1BQU0sRUFBRSxnQkFBZ0IsRUFBRSxFQUFFLENBQUM7SUFDdEMsQ0FBQyxDQUFDLENBQUM7SUFDSCxPQUFPLGFBQWEsQ0FBQztBQUN2QixDQUFDO0FBQ0QsU0FBUyxvQkFBb0IsQ0FBQyxPQUFzQjtJQUNsRCxJQUFJLE9BQU8sQ0FBQyxjQUFjLENBQUMsY0FBYyxDQUFDLEdBQUcsQ0FBQztRQUMxQyxPQUFPLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO1FBQ3pDLE9BQU8sS0FBSyxDQUFDO0tBQ2Q7SUFDRCxJQUFJLE9BQU8sQ0FBQyxjQUFjLENBQUMsY0FBYyxDQUFDLEdBQUcsQ0FBQztRQUMxQyxPQUFPLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO1FBQ3pDLE9BQU8sS0FBSyxDQUFDO0tBQ2Q7SUFDRCxPQUFPLElBQUksQ0FBQztBQUNkLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMiBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbmltcG9ydCB7YmFja2VuZF91dGlsLCBEYXRhVHlwZSwgUmFuaywgU2hhcGVNYXAsIFRlbnNvckluZm8sIHV0aWx9IGZyb20gJ0B0ZW5zb3JmbG93L3RmanMtY29yZSc7XG5cbmltcG9ydCB7c3ltYm9saWNhbGx5Q29tcHV0ZVN0cmlkZXN9IGZyb20gJy4vc2hhZGVyX3V0aWwnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFdlYkdQVVByb2dyYW0ge1xuICAvLyBXaGV0aGVyIHRvIHVzZSBhdG9taWMgYnVpbHQtaW4gZnVuY3Rpb25zLlxuICBhdG9taWM/OiBib29sZWFuO1xuICAvLyBkaXNwYXRjaCBzcGVjaWZpZXMgZ2VvbWV0cnkgb2YgdGhyZWFkIGdyb3VwcyAtIGRlcml2ZWQgZnJvbSBkaXNwYXRjaExheW91dC5cbiAgZGlzcGF0Y2g6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXTtcbiAgLy8gZGlzcGF0Y2hMYXlvdXQgZW51bWVyYXRlcyBob3cgdGVuc29yIGRpbWVuc2lvbnMgYXJlIGRpc3RyaWJ1dGVkIGFtb25nXG4gIC8vIGRpc3BhdGNoIHgseSx6IGRpbWVuc2lvbnMuXG4gIGRpc3BhdGNoTGF5b3V0OiB7eDogbnVtYmVyW10sIHk/OiBudW1iZXJbXSwgej86IG51bWJlcltdfTtcbiAgaXNGcm9tUGl4ZWxzPzogYm9vbGVhbjtcbiAgaXNWZWM0PzogYm9vbGVhbjtcbiAgb3V0cHV0U2hhcGU6IG51bWJlcltdO1xuICAvLyBUaGUgdW5pcXVlIGtleSB0byBkaXN0aW5ndWlzaCBkaWZmZXJlbnQgc2hhZGVyIHNvdXJjZSBjb2RlLlxuICBzaGFkZXJLZXk6IHN0cmluZztcbiAgLy8gV2hldGhlciB0byB1c2Ugb3V0cHV0IHNpemUgZm9yIGJvdW5kcyBjaGVja2luZy5cbiAgc2l6ZT86IGJvb2xlYW47XG4gIHVuaWZvcm1zPzogc3RyaW5nO1xuICB2YXJpYWJsZU5hbWVzOiBzdHJpbmdbXTtcbiAgLy8gRGVzY3JpYmUgZWFjaCB2YXJpYWJsZSdzIHR5cGUgYW5kIG11c3QgaGF2ZSBvbmUtb25lIG1hcHBpbmcgd2l0aFxuICAvLyB2YXJpYWJsZU5hbWVzLiBJZiBub3Qgc2V0LCBhbGwgdmFyaWFibGVzIHR5cGUgd2lsbCBiZSBlaXRoZXIgZjMyIG9yXG4gIC8vIHZlYzQ8ZjMyPiBiYXNlZCBvbiBpc1ZlYzQgbWVtYmVyLlxuICB2YXJpYWJsZVR5cGVzPzogc3RyaW5nW107XG4gIC8vIHdvcmtncm91cFNpemUueCAqIHdvcmtncm91cFNpemUueSAqIHdvcmtncm91cFNpemUueiA9IHRoZSBudW1iZXIgb2YgdGhyZWFkc1xuICAvLyBpbiBhIHRocmVhZCBncm91cC4gSW5kaXZpZHVhbCBkaW1lbnNpb25zIGRldGVybWluZXMgdGhyZWFkIGxheW91dCB3aXRoaW5cbiAgLy8gdGhlIGdyb3VwLlxuICB3b3JrZ3JvdXBTaXplOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl07XG4gIC8vIFNpemUgb2YgcmVnaXN0ZXIgY2FjaGUgaW4gb25lIGRpbWVuc2lvbiAoYXNzdW1lcyBzcXVhcmUgY2FjaGUpLlxuICAvLyBFYWNoIHRocmVhZCB3cml0ZXMgdG8gd29ya1BlclRocmVhZCAqIHdvcmtQZXJUaHJlYWQgbG9jYXRpb25zIGluIHRoZSBvdXRwdXRcbiAgLy8gYnVmZmVyLlxuICB3b3JrUGVyVGhyZWFkPzogbnVtYmVyO1xuICBnZXRVc2VyQ29kZTogKCkgPT4gc3RyaW5nO1xufVxuXG5leHBvcnQgY29uc3QgY29tcGlsZVByb2dyYW0gPVxuICAgIChkZXZpY2U6IEdQVURldmljZSwgcHJvZ3JhbTogV2ViR1BVUHJvZ3JhbSwgaW5wdXRzRGF0YTogSW5wdXRJbmZvW10sXG4gICAgIG91dHB1dDogVGVuc29ySW5mbyk6IEdQVUNvbXB1dGVQaXBlbGluZSA9PiB7XG4gICAgICBjb25zdCBvdXRwdXREYXRhID0ge2R0eXBlOiBvdXRwdXQuZHR5cGUsIHNoYXBlOiBvdXRwdXQuc2hhcGV9O1xuICAgICAgY29uc3Qgc291cmNlID0gbWFrZVNoYWRlcihpbnB1dHNEYXRhLCBvdXRwdXREYXRhLCBwcm9ncmFtKTtcbiAgICAgIGNvbnN0IG1vZHVsZSA9IGRldmljZS5jcmVhdGVTaGFkZXJNb2R1bGUoXG4gICAgICAgICAge2NvZGU6IHNvdXJjZSwgbGFiZWw6IHByb2dyYW0uY29uc3RydWN0b3IubmFtZX0pO1xuICAgICAgY29uc3QgcGlwZWxpbmUgPSBkZXZpY2UuY3JlYXRlQ29tcHV0ZVBpcGVsaW5lKHtcbiAgICAgICAgY29tcHV0ZToge21vZHVsZSwgZW50cnlQb2ludDogJ19zdGFydCd9LFxuICAgICAgICBsYWJlbDogcHJvZ3JhbS5jb25zdHJ1Y3Rvci5uYW1lLFxuICAgICAgICBsYXlvdXQ6ICdhdXRvJ1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBwaXBlbGluZTtcbiAgICB9O1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q29vcmRzRGF0YVR5cGUocmFuazogbnVtYmVyKTogc3RyaW5nIHtcbiAgaWYgKHJhbmsgPD0gMSkge1xuICAgIHJldHVybiAnaTMyJztcbiAgfSBlbHNlIGlmIChyYW5rID09PSAyKSB7XG4gICAgcmV0dXJuIGB2ZWMyPGkzMj5gO1xuICB9IGVsc2UgaWYgKHJhbmsgPT09IDMpIHtcbiAgICByZXR1cm4gYHZlYzM8aTMyPmA7XG4gIH0gZWxzZSBpZiAocmFuayA9PT0gNCkge1xuICAgIHJldHVybiBgdmVjNDxpMzI+YDtcbiAgfSBlbHNlIGlmIChyYW5rID09PSA1KSB7XG4gICAgcmV0dXJuIGB2ZWM1YDtcbiAgfSBlbHNlIGlmIChyYW5rID09PSA2KSB7XG4gICAgcmV0dXJuIGB2ZWM2YDtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBFcnJvcihgR1BVIGZvciByYW5rICR7cmFua30gaXMgbm90IHlldCBzdXBwb3J0ZWRgKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q29vcmRzWFlaKGluZGV4OiBudW1iZXIpOiBzdHJpbmcge1xuICBpZiAoaW5kZXggPT09IDApIHtcbiAgICByZXR1cm4gJ3gnO1xuICB9IGVsc2UgaWYgKGluZGV4ID09PSAxKSB7XG4gICAgcmV0dXJuICd5JztcbiAgfSBlbHNlIGlmIChpbmRleCA9PT0gMikge1xuICAgIHJldHVybiAneic7XG4gIH0gZWxzZSBpZiAoaW5kZXggPT09IDMpIHtcbiAgICByZXR1cm4gJ3cnO1xuICB9IGVsc2UgaWYgKGluZGV4ID09PSA0KSB7XG4gICAgcmV0dXJuICd1JztcbiAgfSBlbHNlIGlmIChpbmRleCA9PT0gNSkge1xuICAgIHJldHVybiAndic7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgRXJyb3IoYEluZGV4ICR7aW5kZXh9IGlzIG5vdCB5ZXQgc3VwcG9ydGVkYCk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldE1haW5IZWFkZXJTdHJpbmcoKTogc3RyaW5nO1xuZXhwb3J0IGZ1bmN0aW9uIGdldE1haW5IZWFkZXJTdHJpbmcoaW5kZXg6IHN0cmluZyk6IHN0cmluZztcbmV4cG9ydCBmdW5jdGlvbiBnZXRNYWluSGVhZGVyU3RyaW5nKC4uLnBhcmFtczogc3RyaW5nW10pOiBzdHJpbmcge1xuICBsZXQgc25pcHBldDogc3RyaW5nO1xuICBzd2l0Y2ggKHBhcmFtcy5sZW5ndGgpIHtcbiAgICBjYXNlIDA6XG4gICAgICBzbmlwcGV0ID0gYFxuICAgICAgICBmbiBtYWluKClcbiAgICAgIGA7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDE6XG4gICAgICBzbmlwcGV0ID0gYFxuICAgICAgICBmbiBtYWluKCR7cGFyYW1zWzBdfSA6IGkzMilcbiAgICAgIGA7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgRXJyb3IoJ1VucmVhY2hhYmxlJyk7XG4gIH1cbiAgcmV0dXJuIHNuaXBwZXQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRTdGFydEhlYWRlclN0cmluZyhcbiAgICB1c2VHbG9iYWxJbmRleDogYm9vbGVhbiwgcHJvZ3JhbTogV2ViR1BVUHJvZ3JhbSk6IHN0cmluZyB7XG4gIGxldCBzbmlwcGV0OiBzdHJpbmc7XG4gIHNuaXBwZXQgPSBgXG4gICAgICR7Z2V0V29ya2dyb3VwU2l6ZVN0cmluZyhwcm9ncmFtKX1cbiAgICAgIGZuIF9zdGFydChAYnVpbHRpbihsb2NhbF9pbnZvY2F0aW9uX2lkKSBMb2NhbElkIDogdmVjMzx1MzI+LFxuICAgICAgICAgICAgICAgIEBidWlsdGluKGdsb2JhbF9pbnZvY2F0aW9uX2lkKSBHbG9iYWxJZCA6IHZlYzM8dTMyPixcbiAgICAgICAgICAgICAgICBAYnVpbHRpbihsb2NhbF9pbnZvY2F0aW9uX2luZGV4KSBMb2NhbEluZGV4OiB1MzIsXG4gICAgICAgICAgICAgICAgQGJ1aWx0aW4od29ya2dyb3VwX2lkKSBXb3JrZ3JvdXBJZCA6IHZlYzM8dTMyPixcbiAgICAgICAgICAgICAgICBAYnVpbHRpbihudW1fd29ya2dyb3VwcykgTnVtV29ya2dyb3VwcyA6IHZlYzM8dTMyPikge1xuICAgICAgICBsb2NhbElkID0gTG9jYWxJZDtcbiAgICAgICAgbG9jYWxJbmRleCA9IExvY2FsSW5kZXg7XG4gICAgICAgIGdsb2JhbElkID0gR2xvYmFsSWQ7XG4gICAgICAgIG51bVdvcmtncm91cHMgPSBOdW1Xb3JrZ3JvdXBzO1xuICAgICAgICB3b3JrZ3JvdXBJZCA9IFdvcmtncm91cElkO1xuICAgICAgICAke3VzZUdsb2JhbEluZGV4ID8gYG1haW4oZ2V0R2xvYmFsSW5kZXgoKSk7YCA6IGBtYWluKCk7YH07XG4gICAgICB9XG4gICAgYDtcbiAgcmV0dXJuIHNuaXBwZXQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRXb3JrZ3JvdXBTaXplU3RyaW5nKHByb2dyYW06IFdlYkdQVVByb2dyYW0pOiBzdHJpbmcge1xuICByZXR1cm4gYFxuICBAY29tcHV0ZSBAd29ya2dyb3VwX3NpemUoJHtwcm9ncmFtLndvcmtncm91cFNpemVbMF19LCAke1xuICAgICAgcHJvZ3JhbS53b3JrZ3JvdXBTaXplWzFdfSwgJHtwcm9ncmFtLndvcmtncm91cFNpemVbMl19KVxuYDtcbn1cblxuZnVuY3Rpb24gbWFrZVNoYWRlcihcbiAgICBpbnB1dEluZm86IElucHV0SW5mb1tdLCBvdXRwdXREYXRhOiB7ZHR5cGU6IERhdGFUeXBlLCBzaGFwZTogbnVtYmVyW119LFxuICAgIHByb2dyYW06IFdlYkdQVVByb2dyYW0pOiBzdHJpbmcge1xuICBjb25zdCBwcmVmaXhTbmlwcGV0czogc3RyaW5nW10gPSBbXTtcbiAgY29uc3QgZmxhdFdvcmtncm91cFNpemUgPSBwcm9ncmFtLndvcmtncm91cFNpemVbMF0gKlxuICAgICAgcHJvZ3JhbS53b3JrZ3JvdXBTaXplWzFdICogcHJvZ3JhbS53b3JrZ3JvdXBTaXplWzJdO1xuICBwcmVmaXhTbmlwcGV0cy5wdXNoKGBcblxuICAgICAgdmFyPHByaXZhdGU+IGxvY2FsSWQ6IHZlYzM8dTMyPjtcbiAgICAgIHZhcjxwcml2YXRlPiBsb2NhbEluZGV4OiB1MzI7XG4gICAgICB2YXI8cHJpdmF0ZT4gZ2xvYmFsSWQ6IHZlYzM8dTMyPjtcbiAgICAgIHZhcjxwcml2YXRlPiBudW1Xb3JrZ3JvdXBzOiB2ZWMzPHUzMj47XG4gICAgICB2YXI8cHJpdmF0ZT4gd29ya2dyb3VwSWQ6IHZlYzM8dTMyPjtcblxuICAgICAgLy8gT25seSB1c2VkIHdoZW4gdGhlIHkveiBkaW1lbnNpb24gb2Ygd29ya2dyb3VwIHNpemUgaXMgMS5cbiAgICAgIGZuIGdldEdsb2JhbEluZGV4KCkgLT4gaTMyIHtcbiAgICAgICAgJHtcbiAgICAgIGlzRmxhdERpc3BhdGNoKHByb2dyYW0pID9cbiAgICAgICAgICBgICByZXR1cm4gaTMyKGdsb2JhbElkLngpO2AgOlxuICAgICAgICAgIGAgIHJldHVybiBpMzIoKHdvcmtncm91cElkLnogKiBudW1Xb3JrZ3JvdXBzLnggKiBudW1Xb3JrZ3JvdXBzLnkgK1xuICAgICAgICAgICAgICAgIHdvcmtncm91cElkLnkgKiBudW1Xb3JrZ3JvdXBzLnggKyB3b3JrZ3JvdXBJZC54KSAqICR7XG4gICAgICAgICAgICAgIGZsYXRXb3JrZ3JvdXBTaXplfXUgK1xuICAgICAgICAgICAgICAgIGxvY2FsSW5kZXgpO1xuICAgICAgICBgfVxuICAgICAgfVxuICAgIGApO1xuXG4gIGlmIChwcm9ncmFtLmlzRnJvbVBpeGVscykge1xuICAgIHByZWZpeFNuaXBwZXRzLnB1c2goYFxuICAgICAgICBzdHJ1Y3QgVW5pZm9ybSB7XG4gICAgICAgICAgc2l6ZSAgICAgICAgICAgIDogaTMyLFxuICAgICAgICAgIG51bUNoYW5uZWxzICAgICA6IGkzMixcbiAgICAgICAgICBvdXRTaGFwZVN0cmlkZXMgOiB2ZWMyPGkzMj4sXG4gICAgICAgIH07XG5cbiAgICAgICAgQGdyb3VwKDApIEBiaW5kaW5nKDApIHZhcjxzdG9yYWdlLCByZWFkX3dyaXRlPiByZXN1bHQ6IGFycmF5PCR7XG4gICAgICAgIG1hcFRvV2dzbFR5cGVzKG91dHB1dERhdGEuZHR5cGUsIHByb2dyYW0uaXNWZWM0KX0+O1xuICAgICAgICBAZ3JvdXAoMCkgQGJpbmRpbmcoMikgdmFyPHVuaWZvcm0+IHVuaWZvcm1zOiBVbmlmb3JtO1xuICAgICAgYCk7XG4gICAgY29uc3QgdXNlR2xvYmFsSW5kZXggPSBpc0ZsYXREaXNwYXRjaExheW91dChwcm9ncmFtKTtcbiAgICByZXR1cm4gW1xuICAgICAgY29tbW9uU25pcHBldCxcbiAgICAgIHByZWZpeFNuaXBwZXRzLmpvaW4oJ1xcbicpLFxuICAgICAgZ2V0Q29vcmRzRnJvbUluZGV4U25pcHBldChvdXRwdXREYXRhLnNoYXBlKSxcbiAgICAgIHByb2dyYW0uZ2V0VXNlckNvZGUoKSxcbiAgICAgIGdldFN0YXJ0SGVhZGVyU3RyaW5nKHVzZUdsb2JhbEluZGV4LCBwcm9ncmFtKSxcbiAgICBdLmpvaW4oJ1xcbicpO1xuICB9XG5cbiAgbGV0IHVuaWZvcm1EZWNsYXJhdGlvbiA9ICdzdHJ1Y3QgVW5pZm9ybXMgeyBOQU4gOiBmMzIsIElORklOSVRZIDogZjMyLCAnO1xuICBwcm9ncmFtLnZhcmlhYmxlTmFtZXMuZm9yRWFjaCgoeCwgaSkgPT4ge1xuICAgIGNvbnN0IHBlckRhdGFUeXBlID0gZ2V0Q29vcmRzRGF0YVR5cGUoaW5wdXRJbmZvW2ldLnNoYXBlLmxlbmd0aCk7XG4gICAgdW5pZm9ybURlY2xhcmF0aW9uICs9XG4gICAgICAgIGAke3guY2hhckF0KDApLnRvTG93ZXJDYXNlKCkgKyB4LnNsaWNlKDEpfVNoYXBlIDogJHtwZXJEYXRhVHlwZX0sIGA7XG4gIH0pO1xuICBjb25zdCBvdXRwdXREYXRhVHlwZSA9IGdldENvb3Jkc0RhdGFUeXBlKG91dHB1dERhdGEuc2hhcGUubGVuZ3RoKTtcbiAgdW5pZm9ybURlY2xhcmF0aW9uICs9IGBvdXRTaGFwZSA6ICR7b3V0cHV0RGF0YVR5cGV9LCBgO1xuICBjb25zdCBzdHJpZGVzTGVuZ3RoID0gb3V0cHV0RGF0YS5zaGFwZS5sZW5ndGggLSAxO1xuICBjb25zdCBzdHJpZGVzRGF0YVR5cGUgPSBnZXRDb29yZHNEYXRhVHlwZShzdHJpZGVzTGVuZ3RoKTtcbiAgdW5pZm9ybURlY2xhcmF0aW9uICs9IGBcbiAgICAgICAgIG91dFNoYXBlU3RyaWRlczogJHtzdHJpZGVzRGF0YVR5cGV9LCBgO1xuXG4gIGlmIChwcm9ncmFtLnNpemUpIHtcbiAgICB1bmlmb3JtRGVjbGFyYXRpb24gKz0gJ3NpemUgOiBpMzIsICc7XG4gIH1cblxuICBpZiAocHJvZ3JhbS51bmlmb3Jtcykge1xuICAgIHVuaWZvcm1EZWNsYXJhdGlvbiArPSBwcm9ncmFtLnVuaWZvcm1zO1xuICB9XG4gIHVuaWZvcm1EZWNsYXJhdGlvbiArPSAnfTsnO1xuICB1bmlmb3JtRGVjbGFyYXRpb24gPSBpbnNlcnRBbGlnbm1lbnQodW5pZm9ybURlY2xhcmF0aW9uKTtcblxuICBwcmVmaXhTbmlwcGV0cy5wdXNoKHVuaWZvcm1EZWNsYXJhdGlvbik7XG5cbiAgLy8gT3V0cHV0IGJ1ZmZlci5cbiAgaWYgKHByb2dyYW0uYXRvbWljKSB7XG4gICAgcHJlZml4U25pcHBldHMucHVzaChgXG4gICAgICBAZ3JvdXAoMCkgQGJpbmRpbmcoMCkgdmFyPHN0b3JhZ2UsIHJlYWRfd3JpdGU+IHJlc3VsdDogYXJyYXk8YXRvbWljPGkzMj4+O1xuICAgIGApO1xuICB9IGVsc2Uge1xuICAgIHByZWZpeFNuaXBwZXRzLnB1c2goYFxuICAgICAgQGdyb3VwKDApIEBiaW5kaW5nKDApIHZhcjxzdG9yYWdlLCByZWFkX3dyaXRlPiByZXN1bHQ6IGFycmF5PCR7XG4gICAgICAgIG1hcFRvV2dzbFR5cGVzKG91dHB1dERhdGEuZHR5cGUsIHByb2dyYW0uaXNWZWM0KX0+O1xuICAgIGApO1xuICB9XG4gIHByb2dyYW0udmFyaWFibGVOYW1lcy5mb3JFYWNoKCh4LCBpKSA9PiB7XG4gICAgcHJlZml4U25pcHBldHMucHVzaChgXG4gICAgICBAZ3JvdXAoMCkgQGJpbmRpbmcoJHsxICsgaX0pIHZhcjxzdG9yYWdlLCByZWFkPiAke3h9OiBhcnJheTwke1xuICAgICAgICBwcm9ncmFtLnZhcmlhYmxlVHlwZXMgP1xuICAgICAgICAgICAgcHJvZ3JhbS52YXJpYWJsZVR5cGVzW2ldIDpcbiAgICAgICAgICAgIG1hcFRvV2dzbFR5cGVzKGlucHV0SW5mb1tpXS5kdHlwZSwgcHJvZ3JhbS5pc1ZlYzQpfT47XG4gICAgICAgIGApO1xuICB9KTtcblxuICBpZiAodW5pZm9ybURlY2xhcmF0aW9uICE9PSAnJykge1xuICAgIHByZWZpeFNuaXBwZXRzLnB1c2goYFxuICAgICAgQGdyb3VwKDApIEBiaW5kaW5nKCR7XG4gICAgICAgIDEgKyBwcm9ncmFtLnZhcmlhYmxlTmFtZXMubGVuZ3RofSkgdmFyPHVuaWZvcm0+IHVuaWZvcm1zOiBVbmlmb3JtcztcbiAgICAgIGApO1xuICB9XG5cbiAgY29uc3QgY29vcmRzU25pcHBldCA9XG4gICAgICBnZXRPdXRwdXRDb29yZHNTbmlwcGV0KG91dHB1dERhdGEuc2hhcGUsIHByb2dyYW0uZGlzcGF0Y2hMYXlvdXQpO1xuXG4gIGNvbnN0IHNvdXJjZXMgPSBbXG4gICAgY29tbW9uU25pcHBldCwgcHJlZml4U25pcHBldHMuam9pbignXFxuJykgKyBpc0luZlNuaXBwZXQsXG4gICAgZ2V0Q29vcmRzRnJvbUluZGV4U25pcHBldChvdXRwdXREYXRhLnNoYXBlKSwgY29vcmRzU25pcHBldCxcbiAgICBnZXRPdXRwdXRJbmRleEZyb21Db29yZHNTbmlwcGV0KG91dHB1dERhdGEuc2hhcGUubGVuZ3RoKVxuICBdO1xuICBpZiAoIXByb2dyYW0uYXRvbWljKSB7XG4gICAgc291cmNlcy5wdXNoKFxuICAgICAgICBzZXRPdXRwdXRTbmlwcGV0KG91dHB1dERhdGEuc2hhcGUsIG91dHB1dERhdGEuZHR5cGUsIHByb2dyYW0uaXNWZWM0KSk7XG4gIH1cblxuICBjb25zdCBpbnB1dFNuaXBwZXQgPVxuICAgICAgaW5wdXRJbmZvXG4gICAgICAgICAgLm1hcChcbiAgICAgICAgICAgICAgKHgsIGkpID0+IGdldElucHV0U25pcHBldChcbiAgICAgICAgICAgICAgICAgIHgsIG91dHB1dERhdGEuc2hhcGUsXG4gICAgICAgICAgICAgICAgICBwcm9ncmFtLnZhcmlhYmxlVHlwZXMgP1xuICAgICAgICAgICAgICAgICAgICAgIChwcm9ncmFtLnZhcmlhYmxlVHlwZXNbaV0gPT09ICd2ZWM0PGYzMj4nKSA6XG4gICAgICAgICAgICAgICAgICAgICAgcHJvZ3JhbS5pc1ZlYzQsXG4gICAgICAgICAgICAgICAgICBwcm9ncmFtLmRpc3BhdGNoTGF5b3V0LngubGVuZ3RoID09PSBvdXRwdXREYXRhLnNoYXBlLmxlbmd0aCkpXG4gICAgICAgICAgLmpvaW4oJ1xcbicpO1xuICBzb3VyY2VzLnB1c2goaW5wdXRTbmlwcGV0KTtcbiAgc291cmNlcy5wdXNoKHByb2dyYW0uZ2V0VXNlckNvZGUoKSk7XG4gIGNvbnN0IHVzZUdsb2JhbEluZGV4ID0gaXNGbGF0RGlzcGF0Y2hMYXlvdXQocHJvZ3JhbSk7XG4gIHNvdXJjZXMucHVzaChnZXRTdGFydEhlYWRlclN0cmluZyh1c2VHbG9iYWxJbmRleCwgcHJvZ3JhbSkpO1xuICBjb25zdCBzb3VyY2UgPSBzb3VyY2VzLmpvaW4oJ1xcbicpO1xuICByZXR1cm4gc291cmNlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWFrZVNoYWRlcktleTxSIGV4dGVuZHMgUmFuaz4oXG4gICAgcHJvZ3JhbTogV2ViR1BVUHJvZ3JhbSwgc2hhcGVzOiBBcnJheTxTaGFwZU1hcFtSXT4sIGlucHV0c0RhdGE6IElucHV0SW5mb1tdLFxuICAgIG91dHB1dDogVGVuc29ySW5mbyk6IHN0cmluZyB7XG4gIGxldCBrZXkgPSBwcm9ncmFtLnNoYWRlcktleTtcbiAgaWYgKHByb2dyYW0uaXNGcm9tUGl4ZWxzKSB7XG4gICAgcmV0dXJuIGtleTtcbiAgfVxuXG4gIGNvbnN0IHR5cGVzID0gaW5wdXRzRGF0YS5tYXAoZCA9PiBkLmR0eXBlKS5jb25jYXQob3V0cHV0LmR0eXBlKTtcbiAgY29uc3QgYnJvYWRjYXN0RGltcyA9XG4gICAgICBpbnB1dHNEYXRhLm1hcChkID0+IGJhY2tlbmRfdXRpbC5nZXRCcm9hZGNhc3REaW1zKGQuc2hhcGUsIG91dHB1dC5zaGFwZSkpO1xuICBjb25zdCBpbnB1dFNoYXBlc0VxdWFsc091dFNoYXBlID1cbiAgICAgIGlucHV0c0RhdGEubWFwKGQgPT4gdXRpbC5hcnJheXNFcXVhbChkLnNoYXBlLCBvdXRwdXQuc2hhcGUpKS5qb2luKCdfJyk7XG4gIGNvbnN0IGJyb2FkY2FzdERpbXNLZXkgPSBicm9hZGNhc3REaW1zLm1hcChkID0+IGQuam9pbignXycpKS5qb2luKCc7Jyk7XG5cbiAgY29uc3QgZmxhdERpc3BhdGNoU3RyaW5nID0gaXNGbGF0RGlzcGF0Y2gocHJvZ3JhbSkgPyAnZmxhdERpc3BhdGNoJyA6ICcnO1xuXG4gIGtleSArPSAnXycgKyAocHJvZ3JhbS53b3JrZ3JvdXBTaXplID8gcHJvZ3JhbS53b3JrZ3JvdXBTaXplLmpvaW4oJywnKSA6ICcnKSArXG4gICAgICBzaGFwZXMubWFwKHNoYXBlID0+IHNoYXBlLmxlbmd0aCkuam9pbignLCcpICsgdHlwZXMuam9pbignLCcpICtcbiAgICAgIHByb2dyYW0udmFyaWFibGVOYW1lcy5qb2luKCcsJykgKyBicm9hZGNhc3REaW1zS2V5ICtcbiAgICAgIGlucHV0U2hhcGVzRXF1YWxzT3V0U2hhcGUgKyBmbGF0RGlzcGF0Y2hTdHJpbmc7XG5cbiAgcmV0dXJuIGtleTtcbn1cblxuY29uc3QgY29tbW9uU25pcHBldCA9IGBcbiAgc3RydWN0IHZlYzUge3g6IGkzMiwgeTogaTMyLCB6OiBpMzIsIHc6IGkzMiwgdTogaTMyfTtcbiAgc3RydWN0IHZlYzYge3g6IGkzMiwgeTogaTMyLCB6OiBpMzIsIHc6IGkzMiwgdTogaTMyLCB2OiBpMzJ9O1xuXG4gIC8vIENoZWNrcyB3aGV0aGVyIGNvb3JkaW5hdGVzIGxpZSB3aXRoaW4gdGhlIGJvdW5kcyBvZiB0aGUgc2hhcGUuXG4gIGZuIGNvb3Jkc0luQm91bmRzMkQoY29vcmQgOiB2ZWMyPGkzMj4sIHNoYXBlIDogdmVjMjxpMzI+KSAtPiBib29sIHtcbiAgICByZXR1cm4gYWxsKGNvb3JkID49IHZlYzI8aTMyPigwKSkgJiYgYWxsKGNvb3JkIDwgc2hhcGUpO1xuICB9XG4gIGZuIGNvb3Jkc0luQm91bmRzM0QoY29vcmQgOiB2ZWMzPGkzMj4sIHNoYXBlIDogdmVjMzxpMzI+KSAtPiBib29sIHtcbiAgICByZXR1cm4gYWxsKGNvb3JkID49IHZlYzM8aTMyPigwKSkgJiYgYWxsKGNvb3JkIDwgc2hhcGUpO1xuICB9XG4gIGZuIGNvb3Jkc0luQm91bmRzNEQoY29vcmQgOiB2ZWM0PGkzMj4sIHNoYXBlIDogdmVjNDxpMzI+KSAtPiBib29sIHtcbiAgICByZXR1cm4gYWxsKGNvb3JkID49IHZlYzQ8aTMyPigwKSkgJiYgYWxsKGNvb3JkIDwgc2hhcGUpO1xuICB9XG5cbiAgZm4gZ2V0SW5kZXhGcm9tQ29vcmRzMUQoY29vcmQgOiBpMzIsIHNoYXBlIDogaTMyKSAtPiBpMzIge1xuICAgIHJldHVybiBjb29yZDtcbiAgfVxuICBmbiBnZXRJbmRleEZyb21Db29yZHMyRChjb29yZHMgOiB2ZWMyPGkzMj4sIHNoYXBlIDogdmVjMjxpMzI+KSAtPiBpMzIge1xuICAgIHJldHVybiBkb3QoY29vcmRzLCB2ZWMyPGkzMj4oc2hhcGUueSwgMSkpO1xuICB9XG4gIGZuIGdldEluZGV4RnJvbUNvb3JkczNEKGNvb3JkcyA6IHZlYzM8aTMyPiwgc2hhcGUgOiB2ZWMzPGkzMj4pIC0+IGkzMiB7XG4gICAgcmV0dXJuIGRvdChjb29yZHMsIHZlYzM8aTMyPihzaGFwZS55ICogc2hhcGUueiwgc2hhcGUueiwgMSkpO1xuICB9XG4gIGZuIGdldEluZGV4RnJvbUNvb3JkczREKGNvb3JkcyA6IHZlYzQ8aTMyPiwgc2hhcGUgOiB2ZWM0PGkzMj4pIC0+IGkzMiB7XG4gICAgcmV0dXJuIGRvdChjb29yZHMsIHZlYzQ8aTMyPihcbiAgICAgICAgc2hhcGUueSAqIHNoYXBlLnogKiBzaGFwZS53LCBzaGFwZS56ICogc2hhcGUudywgc2hhcGUudywgMSkpO1xuICB9XG4gIGZuIGdldEluZGV4RnJvbUNvb3JkczVEKGNvb3JkcyA6IHZlYzUsIHNoYXBlIDogdmVjNSkgLT4gaTMyIHtcbiAgICBsZXQgc2hhcGVTdHJpZGVzOiB2ZWM1ID0gdmVjNShzaGFwZS55ICogc2hhcGUueiAqIHNoYXBlLncgKiBzaGFwZS51LCBzaGFwZS56ICogc2hhcGUudyAqIHNoYXBlLnUsIHNoYXBlLncgKiBzaGFwZS51LCBzaGFwZS51LCAxKTtcbiAgICByZXR1cm4gY29vcmRzLngqc2hhcGVTdHJpZGVzLnggKyBjb29yZHMueSpzaGFwZVN0cmlkZXMueSArIGNvb3Jkcy56KnNoYXBlU3RyaWRlcy56ICsgY29vcmRzLncqc2hhcGVTdHJpZGVzLncgKyBjb29yZHMudSpzaGFwZVN0cmlkZXMudTtcbiAgfVxuICBmbiBnZXRJbmRleEZyb21Db29yZHM2RChjb29yZHMgOiB2ZWM2LCBzaGFwZSA6IHZlYzYpIC0+IGkzMiB7XG4gICAgbGV0IHNoYXBlU3RyaWRlczogdmVjNiA9IHZlYzYoc2hhcGUueSAqIHNoYXBlLnogKiBzaGFwZS53ICogc2hhcGUudSAqIHNoYXBlLnYsIHNoYXBlLnogKiBzaGFwZS53ICogc2hhcGUudSAqIHNoYXBlLnYsIHNoYXBlLncgKiBzaGFwZS51ICogc2hhcGUudiwgc2hhcGUudSAqIHNoYXBlLnYsIHNoYXBlLnYsIDEpO1xuICAgIHJldHVybiBjb29yZHMueCpzaGFwZVN0cmlkZXMueCArIGNvb3Jkcy55KnNoYXBlU3RyaWRlcy55ICsgY29vcmRzLnoqc2hhcGVTdHJpZGVzLnogKyBjb29yZHMudypzaGFwZVN0cmlkZXMudyArIGNvb3Jkcy51KnNoYXBlU3RyaWRlcy51ICsgY29vcmRzLnYqc2hhcGVTdHJpZGVzLnY7XG4gIH1cblxuICBmbiBpZGl2KGE6IGkzMiwgYjogaTMyLCBzaWduOiBmMzIpIC0+IGkzMiB7XG4gICAgdmFyIHJlczogaTMyID0gYSAvIGI7XG4gICAgbGV0IG1vZHVsbzogaTMyID0gYSAlIGI7XG4gICAgaWYgKHNpZ24gPCAwLiAmJiBtb2R1bG8gIT0gMCkge1xuICAgICAgcmVzID0gcmVzIC0gMTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuXG4gIC8vIE5hTiBkZWZpbmF0aW9uIGluIElFRUUgNzU0LTE5ODUgaXMgOlxuICAvLyAgIC0gc2lnbiA9IGVpdGhlciAwIG9yIDEuXG4gIC8vICAgLSBiaWFzZWQgZXhwb25lbnQgPSBhbGwgMSBiaXRzLlxuICAvLyAgIC0gZnJhY3Rpb24gPSBhbnl0aGluZyBleGNlcHQgYWxsIDAgYml0cyAoc2luY2UgYWxsIDAgYml0cyByZXByZXNlbnRzIGluZmluaXR5KS5cbiAgLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSUVFRV83NTQtMTk4NSNSZXByZXNlbnRhdGlvbl9vZl9ub24tbnVtYmVyc1xuICBmbiBpc25hbih2YWw6IGYzMikgLT4gYm9vbCB7XG4gICAgbGV0IGZsb2F0VG9VaW50OiB1MzIgPSBiaXRjYXN0PHUzMj4odmFsKTtcbiAgICByZXR1cm4gKGZsb2F0VG9VaW50ICYgMHg3ZmZmZmZmZnUpID4gMHg3ZjgwMDAwMHU7XG4gIH1cbiAgZm4gaXNuYW5WZWM0KHZhbCA6IHZlYzQ8ZjMyPikgLT4gdmVjNDxib29sPiB7XG4gICAgbGV0IGZsb2F0VG9VaW50OiB2ZWM0PHUzMj4gPSBiaXRjYXN0PHZlYzQ8dTMyPj4odmFsKTtcbiAgICByZXR1cm4gKGZsb2F0VG9VaW50ICYgdmVjNDx1MzI+KDB4N2ZmZmZmZmZ1KSkgPiB2ZWM0PHUzMj4oMHg3ZjgwMDAwMHUpO1xuICB9XG5gO1xuXG5jb25zdCBpc0luZlNuaXBwZXQgPSBgXG4gIGZuIGlzaW5mKHZhbDogZjMyKSAtPiBib29sIHtcbiAgICByZXR1cm4gYWJzKHZhbCkgPT0gdW5pZm9ybXMuSU5GSU5JVFk7XG4gIH1cbmA7XG5cbnR5cGUgSW5wdXRJbmZvID0ge1xuICBkdHlwZTogRGF0YVR5cGU7IHNoYXBlOiBudW1iZXJbXTsgbmFtZTogc3RyaW5nO1xufTtcbmV4cG9ydCB0eXBlIFdHU0xEYXRhVHlwZSA9ICdmMzInfCdpMzInfCd2ZWM0PGYzMj4nfCd2ZWM0PGkzMj4nfCd2ZWM0PGJvb2w+JztcblxuLyoqXG4gKiBEZXJpdmVzIGxvZ2ljYWwgY29vcmRpbmF0ZXMgZnJvbSBhIGZsYXQgaW5kZXguIFBlcmZvcm1zIGludGVnZXIgZGl2aXNpb25cbiAqIHdpdGggZWFjaCBzdHJpZGUgYW5kIGRlY3JlbWVudHMgdGhlIGluZGV4IHVudGlsIHRoZSBpbmRleCBlcXVhbHMgdGhlIGZpbmFsXG4gKiBkaW1lbnNpb24gY29vcmRpbmF0ZS5cbiAqL1xuZnVuY3Rpb24gZ2V0Q29vcmRzRnJvbUluZGV4U25pcHBldChzaGFwZTogbnVtYmVyW10pOiBzdHJpbmcge1xuICBjb25zdCByYW5rID0gc2hhcGUubGVuZ3RoO1xuXG4gIGlmIChyYW5rIDw9IDEpIHtcbiAgICByZXR1cm4gYGZuIGdldENvb3Jkc0Zyb21JbmRleChpbmRleCA6IGkzMikgLT4gaTMyIHsgcmV0dXJuIGluZGV4OyB9YDtcbiAgfVxuXG4gIGNvbnN0IHN0cmlkZXMgPSB1dGlsLmNvbXB1dGVTdHJpZGVzKHNoYXBlKTtcbiAgY29uc3QgZHR5cGUgPSBnZXRDb29yZHNEYXRhVHlwZShyYW5rKTtcblxuICBjb25zdCBjb29yZHM6IHN0cmluZ1tdID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuazsgaSsrKSB7XG4gICAgY29vcmRzLnB1c2goYGQke2l9YCk7XG4gIH1cblxuICBpZiAoc3RyaWRlcy5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gYCAgICBmbiBnZXRDb29yZHNGcm9tSW5kZXgoaW5kZXggOiBpMzIpIC0+IHZlYzI8aTMyPiB7XG4gICAgICBsZXQgZDAgPSBpbmRleCAvIHVuaWZvcm1zLm91dFNoYXBlU3RyaWRlczsgbGV0IGQxID0gaW5kZXggLSBkMCAqIHVuaWZvcm1zLm91dFNoYXBlU3RyaWRlcztcbiAgICAgIHJldHVybiB2ZWMyPGkzMj4oZDAsIGQxKTtcbiAgICB9YDtcbiAgfVxuICBsZXQgc25pcHBldDtcbiAgc25pcHBldCA9ICd2YXIgaW5kZXgyID0gaW5kZXg7JyArXG4gICAgICBzdHJpZGVzXG4gICAgICAgICAgLm1hcCgoXywgaSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbGluZTEgPVxuICAgICAgICAgICAgICAgIGBsZXQgJHtjb29yZHNbaV19ID0gaW5kZXgyIC8gdW5pZm9ybXMub3V0U2hhcGVTdHJpZGVzLiR7XG4gICAgICAgICAgICAgICAgICAgIGdldENvb3Jkc1hZWihpKX1gO1xuICAgICAgICAgICAgY29uc3QgbGluZTIgPSBpID09PSBzdHJpZGVzLmxlbmd0aCAtIDEgP1xuICAgICAgICAgICAgICAgIGBsZXQgJHtjb29yZHNbaSArIDFdfSA9IGluZGV4MiAtICR7XG4gICAgICAgICAgICAgICAgICAgIGNvb3Jkc1tpXX0gKiB1bmlmb3Jtcy5vdXRTaGFwZVN0cmlkZXMuJHtnZXRDb29yZHNYWVooaSl9YCA6XG4gICAgICAgICAgICAgICAgYGluZGV4MiA9IGluZGV4MiAtICR7Y29vcmRzW2ldfSAqIHVuaWZvcm1zLm91dFNoYXBlU3RyaWRlcy4ke1xuICAgICAgICAgICAgICAgICAgICBnZXRDb29yZHNYWVooaSl9YDtcbiAgICAgICAgICAgIHJldHVybiBgJHtsaW5lMX07ICR7bGluZTJ9O2A7XG4gICAgICAgICAgfSlcbiAgICAgICAgICAuam9pbignJyk7XG5cbiAgcmV0dXJuIGBcbiAgICBmbiBnZXRDb29yZHNGcm9tSW5kZXgoaW5kZXggOiBpMzIpIC0+ICR7ZHR5cGV9IHtcbiAgICAgICR7c25pcHBldH1cbiAgICAgIHJldHVybiAke2R0eXBlfSgke2Nvb3Jkcy5qb2luKCcsJyl9KTtcbiAgICB9XG4gIGA7XG59XG5cbmZ1bmN0aW9uIGdldElucHV0QXRDb29yZHNTbmlwcGV0KFxuICAgIGlucHV0SW5mbzogSW5wdXRJbmZvLCBpc1ZlYzQ6IGJvb2xlYW4pOiBzdHJpbmcge1xuICBjb25zdCB0ZXhOYW1lID0gaW5wdXRJbmZvLm5hbWU7XG4gIGNvbnN0IHJhbmsgPSBpbnB1dEluZm8uc2hhcGUubGVuZ3RoO1xuICBjb25zdCB0eXBlID0gZ2V0Q29vcmRzRGF0YVR5cGUocmFuayk7XG4gIGNvbnN0IGZ1bmNOYW1lID0gJ2dldCcgKyB0ZXhOYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgdGV4TmFtZS5zbGljZSgxKTtcbiAgY29uc3QgZGltcyA9IFsnZDAnLCAnZDEnLCAnZDInLCAnZDMnLCAnZDQnLCAnZDUnXS5zbGljZSgwLCByYW5rKTtcbiAgY29uc3QgaW5wdXRzID0gZGltcy5tYXAoZCA9PiBgJHtkfSA6IGkzMmApLmpvaW4oJywgJyk7XG5cbiAgaWYgKHJhbmsgPCAxKSB7XG4gICAgaWYgKGlzVmVjNCkge1xuICAgICAgcmV0dXJuIGBcbiAgICAgICAgZm4gJHtmdW5jTmFtZX0oKSAtPiB2ZWM0PGYzMj4ge1xuICAgICAgICAgIHJldHVybiB2ZWM0PGYzMj4oJHt0ZXhOYW1lfVswXSk7XG4gICAgICAgIH1cbiAgICAgIGA7XG4gICAgfVxuXG4gICAgcmV0dXJuIGBcbiAgICAgIGZuICR7ZnVuY05hbWV9KCkgLT5mMzIge1xuICAgICAgICByZXR1cm4gZjMyKCR7dGV4TmFtZX1bMF0pO1xuICAgICAgfVxuICAgIGA7XG4gIH1cblxuICBjb25zdCBzaGFwZVN0ciA9XG4gICAgICBgdW5pZm9ybXMuJHt0ZXhOYW1lLmNoYXJBdCgwKS50b0xvd2VyQ2FzZSgpICsgdGV4TmFtZS5zbGljZSgxKX1TaGFwZWA7XG4gIGxldCByYW5rU3RyID0gYCR7cmFua31EYDtcbiAgaWYgKHJhbmsgPT09IDApIHtcbiAgICByYW5rU3RyID0gJzFEJztcbiAgfVxuXG4gIGlmIChpc1ZlYzQpIHtcbiAgICByZXR1cm4gYFxuICAgICAgZm4gJHtmdW5jTmFtZX0oJHtpbnB1dHN9KSAtPiB2ZWM0PGYzMj4ge1xuICAgICAgICByZXR1cm4gdmVjNDxmMzI+KCR7dGV4TmFtZX1bZ2V0SW5kZXhGcm9tQ29vcmRzJHtyYW5rU3RyfSgke3R5cGV9KCR7XG4gICAgICAgIGRpbXMuam9pbignLCcpfSksXG4gICAgICAgICAgJHtzaGFwZVN0cn0pIC8gNF0pO1xuICAgICAgfVxuICAgICAgYDtcbiAgfVxuXG4gIHJldHVybiBgXG4gICAgZm4gJHtmdW5jTmFtZX0oJHtpbnB1dHN9KSAtPiBmMzIge1xuICAgICAgcmV0dXJuIGYzMigke3RleE5hbWV9W2dldEluZGV4RnJvbUNvb3JkcyR7cmFua1N0cn0oJHt0eXBlfSgke1xuICAgICAgZGltcy5qb2luKCcsJyl9KSxcbiAgICAgICAgJHtzaGFwZVN0cn0pXSk7XG4gICAgfVxuICAgYDtcbn1cblxuZnVuY3Rpb24gZ2V0SW5wdXRCeU91dHB1dFNuaXBwZXQoXG4gICAgaW5wdXRJbmZvOiBJbnB1dEluZm8sIG91dFNoYXBlOiBudW1iZXJbXSwgaXNWZWM0OiBib29sZWFuLFxuICAgIGlzRmxhdERpc3BhdGNoTGF5b3V0OiBib29sZWFuKTogc3RyaW5nIHtcbiAgY29uc3QgdGV4TmFtZSA9IGlucHV0SW5mby5uYW1lO1xuICBjb25zdCB0ZXhGdW5jU25pcHBldCA9IHRleE5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyB0ZXhOYW1lLnNsaWNlKDEpO1xuXG4gIGNvbnN0IGZ1bmNOYW1lID0gJ2dldCcgKyB0ZXhGdW5jU25pcHBldCArICdCeU91dHB1dCc7XG5cbiAgY29uc3QgaW5SYW5rID0gaW5wdXRJbmZvLnNoYXBlLmxlbmd0aDtcbiAgY29uc3Qgb3V0UmFuayA9IG91dFNoYXBlLmxlbmd0aDtcbiAgY29uc3QgdHlwZSA9IGdldENvb3Jkc0RhdGFUeXBlKG91dFJhbmspO1xuXG4gIC8vIElmIHRoZSBpblNoYXBlIGVxdWFscyB0aGUgb3V0U2hhcGUgYW5kIHRoZSBkaXNwYXRjaCBsYXlvdXQgaXMgZmxhdCwgd2UgY2FuXG4gIC8vIGRpcmVjdGx5IHVzZSB8Z2xfR2xvYmFsSW52b2NhdGlvbklELnh8IGFzIHRoZSBpbmRleCBhbmQgZG9uJ3QgbmVlZCBjb29yZHNcbiAgLy8gY29udmVyc2lvbiBiZXR3ZWVuIHRoZXNlIHR3byBzaGFwZXMuXG4gIGlmICh1dGlsLmFycmF5c0VxdWFsKGlucHV0SW5mby5zaGFwZSwgb3V0U2hhcGUpICYmIGlzRmxhdERpc3BhdGNoTGF5b3V0KSB7XG4gICAgaWYgKGlzVmVjNCkge1xuICAgICAgcmV0dXJuIGBcbiAgICAgIGZuICR7ZnVuY05hbWV9SW5kZXgoZ2xvYmFsSW5kZXggOiBpMzIpIC0+IHZlYzQ8ZjMyPiB7XG4gICAgICAgIHJldHVybiB2ZWM0PGYzMj4oJHt0ZXhOYW1lfVtnbG9iYWxJbmRleF0pO1xuICAgICAgfVxuXG4gICAgICBmbiAke2Z1bmNOYW1lfUNvb3Jkcyhjb29yZHMgOiAke3R5cGV9KSAtPiB2ZWM0PGYzMj4ge1xuICAgICAgICByZXR1cm4gdmVjNDxmMzI+KCR7dGV4TmFtZX1bJHtcbiAgICAgICAgICBvdXRSYW5rID4gMSA/ICdnZXRPdXRwdXRJbmRleEZyb21Db29yZHMoY29vcmRzKScgOiAnY29vcmRzJ30gLyA0XSk7XG4gICAgICB9XG4gICAgICBgO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYFxuICAgIGZuICR7ZnVuY05hbWV9SW5kZXgoZ2xvYmFsSW5kZXggOiBpMzIpIC0+IGYzMiB7XG4gICAgICByZXR1cm4gZjMyKCR7dGV4TmFtZX1bZ2xvYmFsSW5kZXhdKTtcbiAgICB9XG5cbiAgICBmbiAke2Z1bmNOYW1lfUNvb3Jkcyhjb29yZHMgOiAke3R5cGV9KSAtPiBmMzIge1xuICAgICAgcmV0dXJuIGYzMigke3RleE5hbWV9WyR7XG4gICAgICAgICAgb3V0UmFuayA+IDEgPyAnZ2V0T3V0cHV0SW5kZXhGcm9tQ29vcmRzKGNvb3JkcyknIDogJ2Nvb3Jkcyd9XSk7XG4gICAgfVxuICAgIGA7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgYnJvYWRjYXN0RGltcyA9XG4gICAgICBiYWNrZW5kX3V0aWwuZ2V0QnJvYWRjYXN0RGltcyhpbnB1dEluZm8uc2hhcGUsIG91dFNoYXBlKTtcbiAgY29uc3QgcmFua0RpZmYgPSBvdXRSYW5rIC0gaW5SYW5rO1xuXG4gIGxldCBjb29yZHNTbmlwcGV0ID0gJyc7XG5cbiAgaWYgKGluUmFuayA9PT0gMCkge1xuICAgIGlmIChpc1ZlYzQpIHtcbiAgICAgIHJldHVybiBgXG4gICAgZm4gJHtmdW5jTmFtZX1JbmRleChnbG9iYWxJbmRleCA6IGkzMikgLT4gdmVjNDxmMzI+IHtcbiAgICAgIHJldHVybiBnZXQke3RleEZ1bmNTbmlwcGV0fSgpO1xuICAgIH1cblxuICAgIGZuICR7ZnVuY05hbWV9Q29vcmRzKGNvb3JkcyA6ICR7dHlwZX0pIC0+IHZlYzQ8ZjMyPiB7XG4gICAgICByZXR1cm4gZ2V0JHt0ZXhGdW5jU25pcHBldH0oKTtcbiAgICB9XG4gIGA7XG4gICAgfVxuICAgIHJldHVybiBgXG4gICAgZm4gJHtmdW5jTmFtZX1JbmRleChnbG9iYWxJbmRleCA6IGkzMikgLT4gZjMye1xuICAgICAgcmV0dXJuIGdldCR7dGV4RnVuY1NuaXBwZXR9KCk7XG4gICAgfVxuXG4gICAgZm4gJHtmdW5jTmFtZX1Db29yZHMoY29vcmRzIDogJHt0eXBlfSkgLT4gZjMye1xuICAgICAgcmV0dXJuIGdldCR7dGV4RnVuY1NuaXBwZXR9KCk7XG4gICAgfVxuICBgO1xuICB9IGVsc2Uge1xuICAgIGlmIChvdXRSYW5rIDwgMiAmJiBicm9hZGNhc3REaW1zLmxlbmd0aCA+PSAxKSB7XG4gICAgICBjb29yZHNTbmlwcGV0ID0gJ2Nvb3JkcyA9IDA7JztcbiAgICB9IGVsc2Uge1xuICAgICAgY29vcmRzU25pcHBldCA9XG4gICAgICAgICAgYnJvYWRjYXN0RGltcy5tYXAoZCA9PiBgY29vcmRzLiR7Z2V0Q29vcmRzWFlaKGQgKyByYW5rRGlmZil9ID0gMDtgKVxuICAgICAgICAgICAgICAuam9pbignXFxuJyk7XG4gICAgfVxuICB9XG5cbiAgbGV0IHVucGFja2VkQ29vcmRzU25pcHBldCA9ICcnO1xuICBpZiAob3V0UmFuayA8IDIgJiYgaW5SYW5rID4gMCkge1xuICAgIHVucGFja2VkQ29vcmRzU25pcHBldCA9ICdjb29yZHMnO1xuICB9IGVsc2Uge1xuICAgIGlmIChvdXRSYW5rID4gMSkge1xuICAgICAgY29uc3QgY29vcmRzVHlwZSA9IGdldENvb3Jkc0RhdGFUeXBlKGluUmFuayk7XG4gICAgICBjb25zdCBjb29yZHNWYWx1ZXMgPVxuICAgICAgICAgIGlucHV0SW5mby5zaGFwZS5tYXAoKHMsIGkpID0+IGBjb29yZHMuJHtnZXRDb29yZHNYWVooaSArIHJhbmtEaWZmKX1gKVxuICAgICAgICAgICAgICAuam9pbignLCAnKTtcbiAgICAgIHVucGFja2VkQ29vcmRzU25pcHBldCA9IGAke2Nvb3Jkc1R5cGV9KCR7Y29vcmRzVmFsdWVzfSlgO1xuICAgIH0gZWxzZSB7XG4gICAgICB1bnBhY2tlZENvb3Jkc1NuaXBwZXQgPSAnY29vcmRzJztcbiAgICB9XG4gIH1cblxuICBjb25zdCBzaGFwZVN0ciA9XG4gICAgICBgdW5pZm9ybXMuJHt0ZXhOYW1lLmNoYXJBdCgwKS50b0xvd2VyQ2FzZSgpICsgdGV4TmFtZS5zbGljZSgxKX1TaGFwZWA7XG4gIGNvbnN0IHJhbmtTdHIgPSBgJHtpblJhbmt9RGA7XG4gIGlmIChpc1ZlYzQpIHtcbiAgICByZXR1cm4gYFxuICAgIGZuICR7ZnVuY05hbWV9SW5kZXgoZ2xvYmFsSW5kZXggOiBpMzIpIC0+IHZlYzQ8ZjMyPiB7XG4gICAgICB2YXIgY29vcmRzID0gZ2V0Q29vcmRzRnJvbUluZGV4KGdsb2JhbEluZGV4KTtcbiAgICAgICR7Y29vcmRzU25pcHBldH1cbiAgICAgIHJldHVybiAke3RleE5hbWV9W2dldEluZGV4RnJvbUNvb3JkcyR7cmFua1N0cn0oJHtcbiAgICAgICAgdW5wYWNrZWRDb29yZHNTbmlwcGV0fSwgJHtzaGFwZVN0cn0pIC8gNF07XG4gICAgfVxuXG4gICAgZm4gJHtmdW5jTmFtZX1Db29yZHMoY29vcmRzSW4gOiAke3R5cGV9KSAtPiB2ZWM0PGYzMj4ge1xuICAgICAgdmFyIGNvb3JkcyA9IGNvb3Jkc0luO1xuICAgICAgJHtjb29yZHNTbmlwcGV0fVxuICAgICAgcmV0dXJuICR7dGV4TmFtZX1bZ2V0SW5kZXhGcm9tQ29vcmRzJHtyYW5rU3RyfSgke1xuICAgICAgICB1bnBhY2tlZENvb3Jkc1NuaXBwZXR9LCAke3NoYXBlU3RyfSkgLyA0XTtcbiAgICB9XG4gIGA7XG4gIH1cblxuICByZXR1cm4gYFxuICBmbiAke2Z1bmNOYW1lfUluZGV4KGdsb2JhbEluZGV4IDogaTMyKSAtPiBmMzIge1xuICAgIHZhciBjb29yZHMgPSBnZXRDb29yZHNGcm9tSW5kZXgoZ2xvYmFsSW5kZXgpO1xuICAgICR7Y29vcmRzU25pcHBldH1cbiAgICByZXR1cm4gZjMyKCR7dGV4TmFtZX1bZ2V0SW5kZXhGcm9tQ29vcmRzJHtyYW5rU3RyfSgke1xuICAgICAgdW5wYWNrZWRDb29yZHNTbmlwcGV0fSwgJHtzaGFwZVN0cn0pXSk7XG4gIH1cblxuICBmbiAke2Z1bmNOYW1lfUNvb3Jkcyhjb29yZHNJbiA6ICR7dHlwZX0pIC0+IGYzMiB7XG4gICAgdmFyIGNvb3JkcyA9IGNvb3Jkc0luO1xuICAgICR7Y29vcmRzU25pcHBldH1cbiAgICByZXR1cm4gZjMyKCR7dGV4TmFtZX1bZ2V0SW5kZXhGcm9tQ29vcmRzJHtyYW5rU3RyfSgke1xuICAgICAgdW5wYWNrZWRDb29yZHNTbmlwcGV0fSwgJHtzaGFwZVN0cn0pXSk7XG4gIH1cbmA7XG59XG5cbmZ1bmN0aW9uIGdldElucHV0U25pcHBldChcbiAgICBpbnB1dEluZm86IElucHV0SW5mbywgb3V0U2hhcGU6IG51bWJlcltdLCBpc1ZlYzQ6IGJvb2xlYW4sXG4gICAgaXNGbGF0RGlzcGF0Y2hMYXlvdXQ6IGJvb2xlYW4pOiBzdHJpbmcge1xuICBsZXQgcmVzID0gZ2V0SW5wdXRBdENvb3Jkc1NuaXBwZXQoaW5wdXRJbmZvLCBpc1ZlYzQpO1xuXG4gIGNvbnN0IGluU2hhcGUgPSBpbnB1dEluZm8uc2hhcGU7XG4gIGlmIChpblNoYXBlLmxlbmd0aCA8PSBvdXRTaGFwZS5sZW5ndGgpIHtcbiAgICByZXMgKz0gZ2V0SW5wdXRCeU91dHB1dFNuaXBwZXQoXG4gICAgICAgIGlucHV0SW5mbywgb3V0U2hhcGUsIGlzVmVjNCwgaXNGbGF0RGlzcGF0Y2hMYXlvdXQpO1xuICB9XG5cbiAgcmV0dXJuIHJlcztcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZXMgZ2V0T3V0cHV0Q29vcmRzKCkgZnVuY3Rpb24gdGhhdCBjb21wdXRlcyBvdXRwdXQgY29vcmRpbmF0ZXMgZnJvbVxuICogZGlzcGF0Y2ggZ2VvbWV0cnkgdG8gcmVkdWNlIGFyaXRobWV0aWMuXG4gKi9cbmZ1bmN0aW9uIGdldE91dHB1dENvb3Jkc1NuaXBwZXQoXG4gICAgb3V0U2hhcGU6IG51bWJlcltdLFxuICAgIGRpc3BhdGNoTGF5b3V0OiB7eDogbnVtYmVyW10sIHk/OiBudW1iZXJbXSwgej86IG51bWJlcltdfSk6IHN0cmluZyB7XG4gIGNvbnN0IHt4LCB5ID0gW10sIHogPSBbXX0gPSBkaXNwYXRjaExheW91dDtcblxuICBjb25zdCBvdXRSYW5rID0gb3V0U2hhcGUubGVuZ3RoO1xuICBjb25zdCByYW5rID0geC5sZW5ndGggKyB5Lmxlbmd0aCArIHoubGVuZ3RoO1xuICAvLyBnZXRPdXRwdXRDb29yZHMgaXMgb25seSBtZWFuaW5nZnVsIHdoZW4gdGhlIG91dHB1dCByYW5rIGlzIHNhbWUgd2l0aFxuICAvLyBkaXNwYXRjaCBsYXlvdXQgcmFuay5cbiAgaWYgKHJhbmsgIT09IG91dFJhbmspIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBpZiAoeC5sZW5ndGggPT09IG91dFJhbmspIHtcbiAgICBjb25zdCBkdHlwZSA9IGdldENvb3Jkc0RhdGFUeXBlKG91dFJhbmspO1xuICAgIGNvbnN0IHNuaXBwZXQgPSBgZm4gZ2V0T3V0cHV0Q29vcmRzKCkgLT4gJHtkdHlwZX17XG4gICAgbGV0IGdsb2JhbEluZGV4ID0gZ2V0R2xvYmFsSW5kZXgoKTtcbiAgICByZXR1cm4gZ2V0Q29vcmRzRnJvbUluZGV4KGdsb2JhbEluZGV4KTtcbiAgfVxuICBgO1xuICAgIHJldHVybiBzbmlwcGV0O1xuICB9XG5cbiAgbGV0IGdhdGhlckRpbWVuc2lvbnNTdHIgPSAnJztcbiAgY29uc3QgZGltcyA9IFt4LCB5LCB6XTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGRpbXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBhcnIgPSBkaW1zW2ldO1xuXG4gICAgaWYgKGFyci5sZW5ndGggPT09IDApIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChhcnIubGVuZ3RoID09PSAxKSB7XG4gICAgICBnYXRoZXJEaW1lbnNpb25zU3RyICs9IGBsZXQgZCR7YXJyWzBdfSA9IGkzMihnbG9iYWxJZFske2l9XSk7YDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgc3RyaWRlcyA9IHN5bWJvbGljYWxseUNvbXB1dGVTdHJpZGVzKGFyciwgJ3VuaWZvcm1zLm91dFNoYXBlJyk7XG4gICAgICBnYXRoZXJEaW1lbnNpb25zU3RyICs9IGB2YXIgaW5kZXgke2l9ID0gaTMyKGdsb2JhbElkWyR7aX1dKTtgO1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBzdHJpZGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGdhdGhlckRpbWVuc2lvbnNTdHIgKz0gYGxldCBkJHthcnJbal19ID0gaW5kZXgke2l9IC8gJHtzdHJpZGVzW2pdfTtgO1xuXG4gICAgICAgIGlmIChqID09PSBzdHJpZGVzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICBnYXRoZXJEaW1lbnNpb25zU3RyICs9IGBsZXQgZCR7YXJyW2ogKyAxXX0gPSBgICtcbiAgICAgICAgICAgICAgYGluZGV4JHtpfSAtIGQke2FycltqXX0gKiAke3N0cmlkZXNbal19O2A7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZ2F0aGVyRGltZW5zaW9uc1N0ciArPVxuICAgICAgICAgICAgICBgaW5kZXgke2l9ID0gaW5kZXgke2l9IC0gZCR7YXJyW2pdfSAqICR7c3RyaWRlc1tqXX07YDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGRpbWVuc2lvbnMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5rOyBpKyspIHtcbiAgICBkaW1lbnNpb25zLnB1c2goYGQke2l9YCk7XG4gIH1cblxuICBjb25zdCBkdHlwZSA9IGdldENvb3Jkc0RhdGFUeXBlKHJhbmspO1xuICBsZXQgc25pcHBldCA9IGBmbiBnZXRPdXRwdXRDb29yZHMoKSAtPiAke2R0eXBlfSB7XG4gICR7Z2F0aGVyRGltZW5zaW9uc1N0cn1cbmA7XG4gIGlmIChkaW1lbnNpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgIHNuaXBwZXQgKz0gYHJldHVybiAke2R0eXBlfSgwKTsgfWA7XG4gIH0gZWxzZSB7XG4gICAgc25pcHBldCArPSBgcmV0dXJuICR7ZHR5cGV9KCR7ZGltZW5zaW9ucy5qb2luKCcsJyl9KTsgfWA7XG4gIH1cblxuICByZXR1cm4gc25pcHBldDtcbn1cblxuZnVuY3Rpb24gZ2V0T3V0cHV0SW5kZXhGcm9tQ29vcmRzU25pcHBldChvdXRSYW5rOiBudW1iZXIpIHtcbiAgbGV0IHNuaXBwZXQgPSAnJztcbiAgc3dpdGNoIChvdXRSYW5rKSB7XG4gICAgY2FzZSAwOlxuICAgIGNhc2UgMTpcbiAgICAgIHNuaXBwZXQgKz0gYFxuICAgICAgICBmbiBnZXRPdXRwdXRJbmRleEZyb21Db29yZHMoY29vcmRzIDogaTMyKSAtPiBpMzIge1xuICAgICAgICAgIHJldHVybiBjb29yZHM7XG4gICAgICAgIH1cbiAgICAgICAgYDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMjpcbiAgICAgIHNuaXBwZXQgKz0gYFxuICAgICAgICBmbiBnZXRPdXRwdXRJbmRleEZyb21Db29yZHMoY29vcmRzIDogdmVjMjxpMzI+KSAtPiBpMzIge1xuICAgICAgICAgIHJldHVybiBkb3QoY29vcmRzLCB2ZWMyPGkzMj4odW5pZm9ybXMub3V0U2hhcGVTdHJpZGVzLCAxKSk7XG4gICAgICAgIH1cbiAgICAgICAgYDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMzpcbiAgICAgIHNuaXBwZXQgKz0gYFxuICAgICAgICBmbiBnZXRPdXRwdXRJbmRleEZyb21Db29yZHMoY29vcmRzIDogdmVjMzxpMzI+KSAtPiBpMzIge1xuICAgICAgICAgIHJldHVybiBkb3QoY29vcmRzLCB2ZWMzPGkzMj4odW5pZm9ybXMub3V0U2hhcGVTdHJpZGVzLngsIHVuaWZvcm1zLm91dFNoYXBlU3RyaWRlcy55LCAxKSk7XG4gICAgICAgIH1cbiAgICAgICAgYDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgNDpcbiAgICAgIHNuaXBwZXQgKz0gYFxuICAgICAgICBmbiBnZXRPdXRwdXRJbmRleEZyb21Db29yZHMoY29vcmRzIDogdmVjNDxpMzI+KSAtPiBpMzIge1xuICAgICAgICAgIHJldHVybiBkb3QoY29vcmRzLCB2ZWM0PGkzMj4oXG4gICAgICAgICAgICB1bmlmb3Jtcy5vdXRTaGFwZVN0cmlkZXMueCwgdW5pZm9ybXMub3V0U2hhcGVTdHJpZGVzLnksIHVuaWZvcm1zLm91dFNoYXBlU3RyaWRlcy56LCAxKSk7XG4gICAgICAgIH1cbiAgICAgICAgYDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgNTpcbiAgICAgIHNuaXBwZXQgKz0gYFxuICAgICAgICBmbiBnZXRPdXRwdXRJbmRleEZyb21Db29yZHMoY29vcmRzIDogdmVjNSkgLT4gaTMyIHtcbiAgICAgICAgICByZXR1cm4gY29vcmRzLnggKiB1bmlmb3Jtcy5vdXRTaGFwZVN0cmlkZXMueCArXG4gICAgICAgICAgICAgIGNvb3Jkcy55ICogdW5pZm9ybXMub3V0U2hhcGVTdHJpZGVzLnkgK1xuICAgICAgICAgICAgICBjb29yZHMueiAqIHVuaWZvcm1zLm91dFNoYXBlU3RyaWRlcy56ICtcbiAgICAgICAgICAgICAgY29vcmRzLncgKiB1bmlmb3Jtcy5vdXRTaGFwZVN0cmlkZXMudyArXG4gICAgICAgICAgICAgIGNvb3Jkcy51O1xuICAgICAgICB9XG4gICAgICAgIGA7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDY6XG4gICAgICBzbmlwcGV0ICs9IGBcbiAgICAgICAgZm4gZ2V0T3V0cHV0SW5kZXhGcm9tQ29vcmRzKGNvb3JkcyA6IHZlYzYpIC0+IGkzMiB7XG4gICAgICAgICAgcmV0dXJuIGNvb3Jkcy54ICogdW5pZm9ybXMub3V0U2hhcGVTdHJpZGVzLnggK1xuICAgICAgICAgICAgICBjb29yZHMueSAqIHVuaWZvcm1zLm91dFNoYXBlU3RyaWRlcy55ICtcbiAgICAgICAgICAgICAgY29vcmRzLnogKiB1bmlmb3Jtcy5vdXRTaGFwZVN0cmlkZXMueiArXG4gICAgICAgICAgICAgIGNvb3Jkcy53ICogdW5pZm9ybXMub3V0U2hhcGVTdHJpZGVzLncgK1xuICAgICAgICAgICAgICBjb29yZHMudSAqIHVuaWZvcm1zLm91dFNoYXBlU3RyaWRlcy51ICtcbiAgICAgICAgICAgICAgY29vcmRzLnY7XG4gICAgICAgIH1cbiAgICAgICAgYDtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB1dGlsLmFzc2VydChmYWxzZSwgKCkgPT4gYFVuc3VwcG9ydGVkICR7b3V0UmFua31EIHNoYXBlYCk7XG4gICAgICBicmVhaztcbiAgfVxuICByZXR1cm4gc25pcHBldDtcbn1cblxuZnVuY3Rpb24gaXNGbGF0RGlzcGF0Y2gocHJvZ3JhbTogV2ViR1BVUHJvZ3JhbSk6IGJvb2xlYW4ge1xuICByZXR1cm4gcHJvZ3JhbS5kaXNwYXRjaFsxXSA9PT0gMSAmJiBwcm9ncmFtLmRpc3BhdGNoWzJdID09PSAxO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWFwVG9XZ3NsVHlwZXModHlwZTogRGF0YVR5cGUsIGlzVmVjNDogYm9vbGVhbik6IFdHU0xEYXRhVHlwZXxcbiAgICBEYXRhVHlwZSB7XG4gIGlmICh0eXBlID09PSAnZmxvYXQzMicpIHtcbiAgICByZXR1cm4gaXNWZWM0ID8gJ3ZlYzQ8ZjMyPicgOiAnZjMyJztcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnaW50MzInKSB7XG4gICAgcmV0dXJuIGlzVmVjNCA/ICd2ZWM0PGkzMj4nIDogJ2kzMic7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2Jvb2wnKSB7XG4gICAgLy8gVHlwZSAnYm9vbCcgY2Fubm90IGJlIHVzZWQgaW4gc3RvcmFnZSBjbGFzcyxcbiAgICAvLyBodHRwczovL3d3dy53My5vcmcvVFIvV0dTTC8jaG9zdC1zaGFyZWFibGUtdHlwZXMuXG4gICAgcmV0dXJuIGlzVmVjNCA/ICd2ZWM0PGkzMj4nIDogJ2kzMic7XG4gIH1cblxuICByZXR1cm4gdHlwZTtcbn1cblxuZnVuY3Rpb24gc2V0T3V0cHV0U25pcHBldChcbiAgICBvdXRTaGFwZTogbnVtYmVyW10sIG91dEJ1ZmZlclR5cGU6IERhdGFUeXBlLCBpc1ZlYzQ6IGJvb2xlYW4pOiBzdHJpbmcge1xuICBjb25zdCBvdXRSYW5rID0gb3V0U2hhcGUubGVuZ3RoO1xuICBjb25zdCB3Z3NsVHlwZSA9IG1hcFRvV2dzbFR5cGVzKG91dEJ1ZmZlclR5cGUsIGlzVmVjNCk7XG4gIGxldCBzbmlwcGV0O1xuICBpZiAoaXNWZWM0KSB7XG4gICAgc25pcHBldCA9IGBmbiBzZXRPdXRwdXRBdEluZGV4KGZsYXRJbmRleCA6IGkzMiwgdmFsdWUgOiB2ZWM0PGYzMj4pIHtcbiAgICAgIHJlc3VsdFtmbGF0SW5kZXhdID0gJHt3Z3NsVHlwZX0odmFsdWUpO1xuICAgIH1cbiAgICBmbiBzZXRPdXRwdXRBdEluZGV4STMyKGZsYXRJbmRleCA6IGkzMiwgdmFsdWUgOiB2ZWM0PGkzMj4pIHtcbiAgICAgIHJlc3VsdFtmbGF0SW5kZXhdID0gJHt3Z3NsVHlwZX0odmFsdWUpO1xuICAgIH1gO1xuICB9IGVsc2Uge1xuICAgIHNuaXBwZXQgPSBgZm4gc2V0T3V0cHV0QXRJbmRleChmbGF0SW5kZXggOiBpMzIsIHZhbHVlIDogZjMyKSB7XG4gICAgICByZXN1bHRbZmxhdEluZGV4XSA9ICR7d2dzbFR5cGV9KHZhbHVlKTtcbiAgICB9XG4gICAgZm4gc2V0T3V0cHV0QXRJbmRleEkzMihmbGF0SW5kZXggOiBpMzIsIHZhbHVlIDogaTMyKSB7XG4gICAgICByZXN1bHRbZmxhdEluZGV4XSA9ICR7d2dzbFR5cGV9KHZhbHVlKTtcbiAgICB9YDtcbiAgfVxuICBpZiAob3V0UmFuayA+PSAyKSB7XG4gICAgY29uc3QgZGltcyA9IFsnZDAnLCAnZDEnLCAnZDInLCAnZDMnLCAnZDQnLCAnZDUnXS5zbGljZSgwLCBvdXRSYW5rKTtcbiAgICBjb25zdCB0eXBlID0gZ2V0Q29vcmRzRGF0YVR5cGUob3V0UmFuayk7XG5cbiAgICBpZiAoaXNWZWM0KSB7XG4gICAgICBzbmlwcGV0ICs9IGBcbiAgICAgIGZuIHNldE91dHB1dEF0Q29vcmRzKCR7XG4gICAgICAgICAgZGltcy5tYXAoZCA9PiBgJHtkfSA6IGkzMmApLmpvaW4oJywgJyl9LCB2YWx1ZSA6IHZlYzQ8ZjMyPikge1xuICAgICAgICBsZXQgZmxhdEluZGV4ID0gZ2V0T3V0cHV0SW5kZXhGcm9tQ29vcmRzKCR7dHlwZX0oJHtkaW1zLmpvaW4oJywgJyl9KSk7XG4gICAgICAgIHNldE91dHB1dEF0SW5kZXgoZmxhdEluZGV4IC8gNCwgdmFsdWUpO1xuICAgICAgfVxuICAgICAgZm4gc2V0T3V0cHV0QXRDb29yZHNJMzIoJHtcbiAgICAgICAgICBkaW1zLm1hcChkID0+IGAke2R9IDogaTMyYCkuam9pbignLCAnKX0sIHZhbHVlIDogdmVjNDxpMzI+KSB7XG4gICAgICAgIGxldCBmbGF0SW5kZXggPSBnZXRPdXRwdXRJbmRleEZyb21Db29yZHMoJHt0eXBlfSgke2RpbXMuam9pbignLCAnKX0pKTtcbiAgICAgICAgc2V0T3V0cHV0QXRJbmRleEkzMihmbGF0SW5kZXggLyA0LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgYDtcbiAgICB9IGVsc2Uge1xuICAgICAgc25pcHBldCArPSBgXG4gICAgICBmbiBzZXRPdXRwdXRBdENvb3Jkcygke1xuICAgICAgICAgIGRpbXMubWFwKGQgPT4gYCR7ZH0gOiBpMzJgKS5qb2luKCcsICcpfSwgdmFsdWUgOiBmMzIpIHtcbiAgICAgICAgbGV0IGZsYXRJbmRleCA9IGdldE91dHB1dEluZGV4RnJvbUNvb3Jkcygke3R5cGV9KCR7ZGltcy5qb2luKCcsICcpfSkpO1xuICAgICAgICBzZXRPdXRwdXRBdEluZGV4KGZsYXRJbmRleCwgdmFsdWUpO1xuICAgICAgfVxuICAgICAgZm4gc2V0T3V0cHV0QXRDb29yZHNJMzIoJHtcbiAgICAgICAgICBkaW1zLm1hcChkID0+IGAke2R9IDogaTMyYCkuam9pbignLCAnKX0sIHZhbHVlIDogaTMyKSB7XG4gICAgICAgIGxldCBmbGF0SW5kZXggPSBnZXRPdXRwdXRJbmRleEZyb21Db29yZHMoJHt0eXBlfSgke2RpbXMuam9pbignLCAnKX0pKTtcbiAgICAgICAgc2V0T3V0cHV0QXRJbmRleEkzMihmbGF0SW5kZXgsIHZhbHVlKTtcbiAgICAgIH1cbiAgICBgO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzbmlwcGV0O1xufVxuXG5mdW5jdGlvbiBpbnNlcnRBbGlnbm1lbnQodW5pZm9ybVNoYWRlcjogc3RyaW5nKSB7XG4gIC8vIGluc2VydCBhbGlnbm1lbnQgd2hlbiBjdXJyZW50IHBhdHRlcm4gaXMgdmVjNSBvciB2ZWM2XG4gIGNvbnN0IGN1ckluc2VydFJlID0gLyhcXHcrKVxccyo6XFxzKnZlYyg1fDYpL2c7XG4gIHVuaWZvcm1TaGFkZXIgPSB1bmlmb3JtU2hhZGVyLnJlcGxhY2UoY3VySW5zZXJ0UmUsIChtYXRjaCkgPT4ge1xuICAgIHJldHVybiAnQGFsaWduKDE2KSAnICsgbWF0Y2g7XG4gIH0pO1xuXG4gIC8vIGluc2VydCBhbGlnbm1lbnQgd2hlbiBwcmV2aW91cyBwYXR0ZXJuIGlzIHZlYzUgb3IgdmVjNlxuICBjb25zdCBwcmVJbnNlcnRSZSA9IC92ZWMoNXw2KVxccyosXFxzKihcXHcrKS9nO1xuICB1bmlmb3JtU2hhZGVyID0gdW5pZm9ybVNoYWRlci5yZXBsYWNlKHByZUluc2VydFJlLCAoXywgcDEsIHAyKSA9PiB7XG4gICAgcmV0dXJuIGB2ZWMke3AxfSwgQGFsaWduKDE2KSAke3AyfWA7XG4gIH0pO1xuICByZXR1cm4gdW5pZm9ybVNoYWRlcjtcbn1cbmZ1bmN0aW9uIGlzRmxhdERpc3BhdGNoTGF5b3V0KHByb2dyYW06IFdlYkdQVVByb2dyYW0pOiBib29sZWFuIHtcbiAgaWYgKHByb2dyYW0uZGlzcGF0Y2hMYXlvdXQuaGFzT3duUHJvcGVydHkoJ3knKSAmJlxuICAgICAgcHJvZ3JhbS5kaXNwYXRjaExheW91dC55Lmxlbmd0aCAhPT0gMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAocHJvZ3JhbS5kaXNwYXRjaExheW91dC5oYXNPd25Qcm9wZXJ0eSgneicpICYmXG4gICAgICBwcm9ncmFtLmRpc3BhdGNoTGF5b3V0LnoubGVuZ3RoICE9PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuIl19