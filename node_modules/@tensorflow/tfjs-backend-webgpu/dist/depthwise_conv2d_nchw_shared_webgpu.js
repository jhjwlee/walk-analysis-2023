/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
import { activationFnSnippet, biasActivationSnippet } from './activation_util';
import { getMainHeaderString as main } from './webgpu_program';
import { computeDispatch } from './webgpu_util';
export class DepthwiseConv2DNCHWSharedProgram {
    constructor(outputShape, filterHeight, filterWidth, addBias = false, activation = null, hasPreluActivation = false) {
        this.variableNames = ['x', 'W'];
        this.uniforms = `pad : vec2<i32>, inDims : vec2<i32>,`;
        this.workgroupSize = [16, 16, 1];
        this.outputShape = outputShape;
        this.dispatchLayout = { x: [3], y: [2], z: [0, 1] };
        this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workgroupSize);
        if (addBias) {
            this.variableNames.push('bias');
        }
        if (hasPreluActivation) {
            this.variableNames.push('preluActivationWeights');
        }
        this.addBias = addBias;
        this.activation = activation;
        this.hasPreluActivation = hasPreluActivation;
        this.filterHeight = filterHeight;
        this.filterWidth = filterWidth;
        this.shaderKey = `depthwiseNCHW_${this.activation}_${this.filterHeight}_${this.filterWidth}`;
    }
    getUserCode() {
        const filterSize = this.filterWidth * this.filterHeight;
        const flatWorkgroupSize = this.workgroupSize[0] * this.workgroupSize[1] * this.workgroupSize[2];
        const tileAHeight = this.workgroupSize[1] + this.filterHeight - 1;
        const tileAWidth = this.workgroupSize[0] + this.filterWidth - 1;
        const userCode = `
      ${activationFnSnippet(this.activation, this.hasPreluActivation, false, 4)}

      var<workgroup> mm_Asub : array<array<f32, ${tileAWidth}>, ${tileAHeight}>;
      var<workgroup> mm_Bsub : array<array<f32, ${this.filterWidth}>, ${this.filterHeight}>;
      fn readX(batch : i32, channel : i32, row : i32, col : i32) -> f32 {
        var value = 0.0;
        if (row >=0 && row < uniforms.inDims[0] && col >=0 && col < uniforms.inDims[1])
        {
          value = getX(batch, channel, row, col);
        }
        return value;
      }

      ${main()} {
        let coords = getOutputCoords();
        let batch = coords[0];
        let xRCCorner = vec2<i32>(coords.zw) - uniforms.pad;
        let channelMul = uniforms.wShape[3];
        let d1 = coords[1] / channelMul;
        let q = coords[1] % channelMul;

        let inputRowStart = xRCCorner.x;
        let inputColStart = xRCCorner.y;

        let localRow = i32(localId.y);
        let localCol = i32(localId.x);

        // Load one tile of X into local memory.
        for (var inputRow = localRow; inputRow < ${tileAHeight}; inputRow = inputRow + ${this.workgroupSize[1]}) {
          for (var inputCol = localCol; inputCol < ${tileAWidth}; inputCol = inputCol + ${this.workgroupSize[0]}) {
            let rowOffset = inputRow - localRow;
            let colOffset = inputCol - localCol;
            mm_Asub[inputRow][inputCol] = readX(batch, d1, inputRowStart + rowOffset, inputColStart + colOffset);
          }
        }

        // Load one tile of W into local memory.
        var wIndex = i32(localIndex);
        ${filterSize < flatWorkgroupSize ?
            `if (wIndex < ${filterSize})` :
            `for(; wIndex < ${filterSize}; wIndex = wIndex + ${flatWorkgroupSize})`}

        {
          let wRow = wIndex / ${this.filterWidth};
          let wCol = wIndex % ${this.filterWidth};
          mm_Bsub[wRow][wCol] = getW(wRow, wCol, d1, q);
        }

        workgroupBarrier();

        var value = 0.0;
        for (var wR = 0; wR < ${this.filterHeight}; wR = wR + 1) {
          for (var wC = 0; wC < ${this.filterWidth}; wC = wC + 1) {
            let xVal = mm_Asub[localRow + wR][localCol + wC];
            let wVal = mm_Bsub[wR][wC];
            value = fma(xVal, wVal, value);
          }
        }
        ${biasActivationSnippet(this.addBias, this.activation)}
        if (coordsInBounds4D(coords, uniforms.outShape)) {
          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
        }
      }
    `;
        return userCode;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGVwdGh3aXNlX2NvbnYyZF9uY2h3X3NoYXJlZF93ZWJncHUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi90ZmpzLWJhY2tlbmQtd2ViZ3B1L3NyYy9kZXB0aHdpc2VfY29udjJkX25jaHdfc2hhcmVkX3dlYmdwdS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7O0dBZUc7QUFJSCxPQUFPLEVBQUMsbUJBQW1CLEVBQUUscUJBQXFCLEVBQUMsTUFBTSxtQkFBbUIsQ0FBQztBQUM3RSxPQUFPLEVBQUMsbUJBQW1CLElBQUksSUFBSSxFQUFnQixNQUFNLGtCQUFrQixDQUFDO0FBQzVFLE9BQU8sRUFBQyxlQUFlLEVBQUMsTUFBTSxlQUFlLENBQUM7QUFFOUMsTUFBTSxPQUFPLGdDQUFnQztJQWMzQyxZQUNJLFdBQXFCLEVBQUUsWUFBb0IsRUFBRSxXQUFtQixFQUNoRSxPQUFPLEdBQUcsS0FBSyxFQUFFLGFBQXNDLElBQUksRUFDM0Qsa0JBQWtCLEdBQUcsS0FBSztRQVo5QixrQkFBYSxHQUFHLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxDQUFDO1FBQzNCLGFBQVEsR0FBRyxzQ0FBc0MsQ0FBQztRQUNsRCxrQkFBYSxHQUE2QixDQUFDLEVBQUUsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFXcEQsSUFBSSxDQUFDLFdBQVcsR0FBRyxXQUFXLENBQUM7UUFDL0IsSUFBSSxDQUFDLGNBQWMsR0FBRyxFQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBQyxDQUFDO1FBQ2xELElBQUksQ0FBQyxRQUFRLEdBQUcsZUFBZSxDQUMzQixJQUFJLENBQUMsY0FBYyxFQUFFLElBQUksQ0FBQyxXQUFXLEVBQUUsSUFBSSxDQUFDLGFBQWEsQ0FBQyxDQUFDO1FBRS9ELElBQUksT0FBTyxFQUFFO1lBQ1gsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7U0FDakM7UUFDRCxJQUFJLGtCQUFrQixFQUFFO1lBQ3RCLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLHdCQUF3QixDQUFDLENBQUM7U0FDbkQ7UUFFRCxJQUFJLENBQUMsT0FBTyxHQUFHLE9BQU8sQ0FBQztRQUN2QixJQUFJLENBQUMsVUFBVSxHQUFHLFVBQVUsQ0FBQztRQUM3QixJQUFJLENBQUMsa0JBQWtCLEdBQUcsa0JBQWtCLENBQUM7UUFDN0MsSUFBSSxDQUFDLFlBQVksR0FBRyxZQUFZLENBQUM7UUFDakMsSUFBSSxDQUFDLFdBQVcsR0FBRyxXQUFXLENBQUM7UUFDL0IsSUFBSSxDQUFDLFNBQVMsR0FBRyxpQkFBaUIsSUFBSSxDQUFDLFVBQVUsSUFBSSxJQUFJLENBQUMsWUFBWSxJQUNsRSxJQUFJLENBQUMsV0FBVyxFQUFFLENBQUM7SUFDekIsQ0FBQztJQUVELFdBQVc7UUFDVCxNQUFNLFVBQVUsR0FBRyxJQUFJLENBQUMsV0FBVyxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUM7UUFDeEQsTUFBTSxpQkFBaUIsR0FDbkIsSUFBSSxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDMUUsTUFBTSxXQUFXLEdBQUcsSUFBSSxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsWUFBWSxHQUFHLENBQUMsQ0FBQztRQUNsRSxNQUFNLFVBQVUsR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxXQUFXLEdBQUcsQ0FBQyxDQUFDO1FBRWhFLE1BQU0sUUFBUSxHQUFHO1FBRWIsbUJBQW1CLENBQ2YsSUFBSSxDQUFDLFVBQVUsRUFBRSxJQUFJLENBQUMsa0JBQWtCLEVBQUUsS0FBSyxFQUFFLENBQUMsQ0FBQzs7a0RBRWIsVUFBVSxNQUNwRCxXQUFXO2tEQUMrQixJQUFJLENBQUMsV0FBVyxNQUMxRCxJQUFJLENBQUMsWUFBWTs7Ozs7Ozs7OztRQVVqQixJQUFJLEVBQUU7Ozs7Ozs7Ozs7Ozs7OzttREFnQk4sV0FBVywyQkFBMkIsSUFBSSxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUM7cURBRTNELFVBQVUsMkJBQTJCLElBQUksQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDOzs7Ozs7Ozs7VUFVMUQsVUFBVSxHQUFHLGlCQUFpQixDQUFDLENBQUM7WUFDNUIsZ0JBQWdCLFVBQVUsR0FBRyxDQUFDLENBQUM7WUFDL0Isa0JBQWtCLFVBQVUsdUJBQ3hCLGlCQUFpQixHQUFHOzs7Z0NBR0osSUFBSSxDQUFDLFdBQVc7Z0NBQ2hCLElBQUksQ0FBQyxXQUFXOzs7Ozs7O2dDQU9oQixJQUFJLENBQUMsWUFBWTtrQ0FDZixJQUFJLENBQUMsV0FBVzs7Ozs7O1VBTXhDLHFCQUFxQixDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsSUFBSSxDQUFDLFVBQVUsQ0FBQzs7Ozs7S0FLekQsQ0FBQztRQUNGLE9BQU8sUUFBUSxDQUFDO0lBQ2xCLENBQUM7Q0FDRiIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIyIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cblxuaW1wb3J0IHtiYWNrZW5kX3V0aWx9IGZyb20gJ0B0ZW5zb3JmbG93L3RmanMtY29yZSc7XG5cbmltcG9ydCB7YWN0aXZhdGlvbkZuU25pcHBldCwgYmlhc0FjdGl2YXRpb25TbmlwcGV0fSBmcm9tICcuL2FjdGl2YXRpb25fdXRpbCc7XG5pbXBvcnQge2dldE1haW5IZWFkZXJTdHJpbmcgYXMgbWFpbiwgV2ViR1BVUHJvZ3JhbX0gZnJvbSAnLi93ZWJncHVfcHJvZ3JhbSc7XG5pbXBvcnQge2NvbXB1dGVEaXNwYXRjaH0gZnJvbSAnLi93ZWJncHVfdXRpbCc7XG5cbmV4cG9ydCBjbGFzcyBEZXB0aHdpc2VDb252MkROQ0hXU2hhcmVkUHJvZ3JhbSBpbXBsZW1lbnRzIFdlYkdQVVByb2dyYW0ge1xuICBvdXRwdXRTaGFwZTogbnVtYmVyW107XG4gIHNoYWRlcktleTogc3RyaW5nO1xuICBkaXNwYXRjaExheW91dDoge3g6IG51bWJlcltdLCB5OiBudW1iZXJbXSwgejogbnVtYmVyW119O1xuICBkaXNwYXRjaDogW251bWJlciwgbnVtYmVyLCBudW1iZXJdO1xuICB2YXJpYWJsZU5hbWVzID0gWyd4JywgJ1cnXTtcbiAgdW5pZm9ybXMgPSBgcGFkIDogdmVjMjxpMzI+LCBpbkRpbXMgOiB2ZWMyPGkzMj4sYDtcbiAgd29ya2dyb3VwU2l6ZTogW251bWJlciwgbnVtYmVyLCBudW1iZXJdID0gWzE2LCAxNiwgMV07XG4gIGFkZEJpYXM6IGJvb2xlYW47XG4gIGFjdGl2YXRpb246IGJhY2tlbmRfdXRpbC5BY3RpdmF0aW9uO1xuICBoYXNQcmVsdUFjdGl2YXRpb246IGJvb2xlYW47XG4gIGZpbHRlckhlaWdodDogbnVtYmVyO1xuICBmaWx0ZXJXaWR0aDogbnVtYmVyO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgICAgb3V0cHV0U2hhcGU6IG51bWJlcltdLCBmaWx0ZXJIZWlnaHQ6IG51bWJlciwgZmlsdGVyV2lkdGg6IG51bWJlcixcbiAgICAgIGFkZEJpYXMgPSBmYWxzZSwgYWN0aXZhdGlvbjogYmFja2VuZF91dGlsLkFjdGl2YXRpb24gPSBudWxsLFxuICAgICAgaGFzUHJlbHVBY3RpdmF0aW9uID0gZmFsc2UpIHtcbiAgICB0aGlzLm91dHB1dFNoYXBlID0gb3V0cHV0U2hhcGU7XG4gICAgdGhpcy5kaXNwYXRjaExheW91dCA9IHt4OiBbM10sIHk6IFsyXSwgejogWzAsIDFdfTtcbiAgICB0aGlzLmRpc3BhdGNoID0gY29tcHV0ZURpc3BhdGNoKFxuICAgICAgICB0aGlzLmRpc3BhdGNoTGF5b3V0LCB0aGlzLm91dHB1dFNoYXBlLCB0aGlzLndvcmtncm91cFNpemUpO1xuXG4gICAgaWYgKGFkZEJpYXMpIHtcbiAgICAgIHRoaXMudmFyaWFibGVOYW1lcy5wdXNoKCdiaWFzJyk7XG4gICAgfVxuICAgIGlmIChoYXNQcmVsdUFjdGl2YXRpb24pIHtcbiAgICAgIHRoaXMudmFyaWFibGVOYW1lcy5wdXNoKCdwcmVsdUFjdGl2YXRpb25XZWlnaHRzJyk7XG4gICAgfVxuXG4gICAgdGhpcy5hZGRCaWFzID0gYWRkQmlhcztcbiAgICB0aGlzLmFjdGl2YXRpb24gPSBhY3RpdmF0aW9uO1xuICAgIHRoaXMuaGFzUHJlbHVBY3RpdmF0aW9uID0gaGFzUHJlbHVBY3RpdmF0aW9uO1xuICAgIHRoaXMuZmlsdGVySGVpZ2h0ID0gZmlsdGVySGVpZ2h0O1xuICAgIHRoaXMuZmlsdGVyV2lkdGggPSBmaWx0ZXJXaWR0aDtcbiAgICB0aGlzLnNoYWRlcktleSA9IGBkZXB0aHdpc2VOQ0hXXyR7dGhpcy5hY3RpdmF0aW9ufV8ke3RoaXMuZmlsdGVySGVpZ2h0fV8ke1xuICAgICAgICB0aGlzLmZpbHRlcldpZHRofWA7XG4gIH1cblxuICBnZXRVc2VyQ29kZSgpOiBzdHJpbmcge1xuICAgIGNvbnN0IGZpbHRlclNpemUgPSB0aGlzLmZpbHRlcldpZHRoICogdGhpcy5maWx0ZXJIZWlnaHQ7XG4gICAgY29uc3QgZmxhdFdvcmtncm91cFNpemUgPVxuICAgICAgICB0aGlzLndvcmtncm91cFNpemVbMF0gKiB0aGlzLndvcmtncm91cFNpemVbMV0gKiB0aGlzLndvcmtncm91cFNpemVbMl07XG4gICAgY29uc3QgdGlsZUFIZWlnaHQgPSB0aGlzLndvcmtncm91cFNpemVbMV0gKyB0aGlzLmZpbHRlckhlaWdodCAtIDE7XG4gICAgY29uc3QgdGlsZUFXaWR0aCA9IHRoaXMud29ya2dyb3VwU2l6ZVswXSArIHRoaXMuZmlsdGVyV2lkdGggLSAxO1xuXG4gICAgY29uc3QgdXNlckNvZGUgPSBgXG4gICAgICAke1xuICAgICAgICBhY3RpdmF0aW9uRm5TbmlwcGV0KFxuICAgICAgICAgICAgdGhpcy5hY3RpdmF0aW9uLCB0aGlzLmhhc1ByZWx1QWN0aXZhdGlvbiwgZmFsc2UsIDQpfVxuXG4gICAgICB2YXI8d29ya2dyb3VwPiBtbV9Bc3ViIDogYXJyYXk8YXJyYXk8ZjMyLCAke3RpbGVBV2lkdGh9PiwgJHtcbiAgICAgICAgdGlsZUFIZWlnaHR9PjtcbiAgICAgIHZhcjx3b3JrZ3JvdXA+IG1tX0JzdWIgOiBhcnJheTxhcnJheTxmMzIsICR7dGhpcy5maWx0ZXJXaWR0aH0+LCAke1xuICAgICAgICB0aGlzLmZpbHRlckhlaWdodH0+O1xuICAgICAgZm4gcmVhZFgoYmF0Y2ggOiBpMzIsIGNoYW5uZWwgOiBpMzIsIHJvdyA6IGkzMiwgY29sIDogaTMyKSAtPiBmMzIge1xuICAgICAgICB2YXIgdmFsdWUgPSAwLjA7XG4gICAgICAgIGlmIChyb3cgPj0wICYmIHJvdyA8IHVuaWZvcm1zLmluRGltc1swXSAmJiBjb2wgPj0wICYmIGNvbCA8IHVuaWZvcm1zLmluRGltc1sxXSlcbiAgICAgICAge1xuICAgICAgICAgIHZhbHVlID0gZ2V0WChiYXRjaCwgY2hhbm5lbCwgcm93LCBjb2wpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgJHttYWluKCl9IHtcbiAgICAgICAgbGV0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xuICAgICAgICBsZXQgYmF0Y2ggPSBjb29yZHNbMF07XG4gICAgICAgIGxldCB4UkNDb3JuZXIgPSB2ZWMyPGkzMj4oY29vcmRzLnp3KSAtIHVuaWZvcm1zLnBhZDtcbiAgICAgICAgbGV0IGNoYW5uZWxNdWwgPSB1bmlmb3Jtcy53U2hhcGVbM107XG4gICAgICAgIGxldCBkMSA9IGNvb3Jkc1sxXSAvIGNoYW5uZWxNdWw7XG4gICAgICAgIGxldCBxID0gY29vcmRzWzFdICUgY2hhbm5lbE11bDtcblxuICAgICAgICBsZXQgaW5wdXRSb3dTdGFydCA9IHhSQ0Nvcm5lci54O1xuICAgICAgICBsZXQgaW5wdXRDb2xTdGFydCA9IHhSQ0Nvcm5lci55O1xuXG4gICAgICAgIGxldCBsb2NhbFJvdyA9IGkzMihsb2NhbElkLnkpO1xuICAgICAgICBsZXQgbG9jYWxDb2wgPSBpMzIobG9jYWxJZC54KTtcblxuICAgICAgICAvLyBMb2FkIG9uZSB0aWxlIG9mIFggaW50byBsb2NhbCBtZW1vcnkuXG4gICAgICAgIGZvciAodmFyIGlucHV0Um93ID0gbG9jYWxSb3c7IGlucHV0Um93IDwgJHtcbiAgICAgICAgdGlsZUFIZWlnaHR9OyBpbnB1dFJvdyA9IGlucHV0Um93ICsgJHt0aGlzLndvcmtncm91cFNpemVbMV19KSB7XG4gICAgICAgICAgZm9yICh2YXIgaW5wdXRDb2wgPSBsb2NhbENvbDsgaW5wdXRDb2wgPCAke1xuICAgICAgICB0aWxlQVdpZHRofTsgaW5wdXRDb2wgPSBpbnB1dENvbCArICR7dGhpcy53b3JrZ3JvdXBTaXplWzBdfSkge1xuICAgICAgICAgICAgbGV0IHJvd09mZnNldCA9IGlucHV0Um93IC0gbG9jYWxSb3c7XG4gICAgICAgICAgICBsZXQgY29sT2Zmc2V0ID0gaW5wdXRDb2wgLSBsb2NhbENvbDtcbiAgICAgICAgICAgIG1tX0FzdWJbaW5wdXRSb3ddW2lucHV0Q29sXSA9IHJlYWRYKGJhdGNoLCBkMSwgaW5wdXRSb3dTdGFydCArIHJvd09mZnNldCwgaW5wdXRDb2xTdGFydCArIGNvbE9mZnNldCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gTG9hZCBvbmUgdGlsZSBvZiBXIGludG8gbG9jYWwgbWVtb3J5LlxuICAgICAgICB2YXIgd0luZGV4ID0gaTMyKGxvY2FsSW5kZXgpO1xuICAgICAgICAke1xuICAgICAgICBmaWx0ZXJTaXplIDwgZmxhdFdvcmtncm91cFNpemUgP1xuICAgICAgICAgICAgYGlmICh3SW5kZXggPCAke2ZpbHRlclNpemV9KWAgOlxuICAgICAgICAgICAgYGZvcig7IHdJbmRleCA8ICR7ZmlsdGVyU2l6ZX07IHdJbmRleCA9IHdJbmRleCArICR7XG4gICAgICAgICAgICAgICAgZmxhdFdvcmtncm91cFNpemV9KWB9XG5cbiAgICAgICAge1xuICAgICAgICAgIGxldCB3Um93ID0gd0luZGV4IC8gJHt0aGlzLmZpbHRlcldpZHRofTtcbiAgICAgICAgICBsZXQgd0NvbCA9IHdJbmRleCAlICR7dGhpcy5maWx0ZXJXaWR0aH07XG4gICAgICAgICAgbW1fQnN1Ylt3Um93XVt3Q29sXSA9IGdldFcod1Jvdywgd0NvbCwgZDEsIHEpO1xuICAgICAgICB9XG5cbiAgICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gICAgICAgIHZhciB2YWx1ZSA9IDAuMDtcbiAgICAgICAgZm9yICh2YXIgd1IgPSAwOyB3UiA8ICR7dGhpcy5maWx0ZXJIZWlnaHR9OyB3UiA9IHdSICsgMSkge1xuICAgICAgICAgIGZvciAodmFyIHdDID0gMDsgd0MgPCAke3RoaXMuZmlsdGVyV2lkdGh9OyB3QyA9IHdDICsgMSkge1xuICAgICAgICAgICAgbGV0IHhWYWwgPSBtbV9Bc3ViW2xvY2FsUm93ICsgd1JdW2xvY2FsQ29sICsgd0NdO1xuICAgICAgICAgICAgbGV0IHdWYWwgPSBtbV9Cc3ViW3dSXVt3Q107XG4gICAgICAgICAgICB2YWx1ZSA9IGZtYSh4VmFsLCB3VmFsLCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgICR7Ymlhc0FjdGl2YXRpb25TbmlwcGV0KHRoaXMuYWRkQmlhcywgdGhpcy5hY3RpdmF0aW9uKX1cbiAgICAgICAgaWYgKGNvb3Jkc0luQm91bmRzNEQoY29vcmRzLCB1bmlmb3Jtcy5vdXRTaGFwZSkpIHtcbiAgICAgICAgICBzZXRPdXRwdXRBdENvb3Jkcyhjb29yZHNbMF0sIGNvb3Jkc1sxXSwgY29vcmRzWzJdLCBjb29yZHNbM10sIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIGA7XG4gICAgcmV0dXJuIHVzZXJDb2RlO1xuICB9XG59XG4iXX0=