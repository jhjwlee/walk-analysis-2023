/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
import { backend_util, util } from '@tensorflow/tfjs-core';
import { getBinaryOpString } from './binary_op_util';
import { getMainHeaderString as main } from './webgpu_program';
import { computeDispatch, flatDispatchLayout } from './webgpu_util';
export class BinaryOpProgram {
    constructor(op, aShape, bShape) {
        this.size = true;
        this.variableNames = ['A', 'B'];
        this.outputShape = backend_util.assertAndGetBroadcastShape(aShape, bShape);
        this.dispatchLayout = flatDispatchLayout(this.outputShape);
        this.op = op;
        this.useSharedMemoryWithA =
            aShape.length <= 1 && bShape.length > 1 && aShape[0] < 128;
        this.useSharedMemoryWithB =
            bShape.length <= 1 && aShape.length > 1 && bShape[0] < 128;
        if (this.useSharedMemoryWithA || this.useSharedMemoryWithB) {
            this.isVec4 = false;
            // lastDimensionSize is used as sharedBuf array size, so can not be
            // used as uniform.
            this.lastDimensionSize =
                this.useSharedMemoryWithB ? bShape[0] : aShape[0];
            this.shaderKey = `binary_${this.type}_${op}_${this.lastDimensionSize}_${this.useSharedMemoryWithB}`;
            this.type = 'shared';
            // This is an experimental value when using shared memory.
            // Note that the maximum of workgroup X dimension is 256.
            this.workgroupSize = [256, 1, 1];
            this.workPerThread = 1;
        }
        else {
            if (util.arraysEqual(aShape, bShape) &&
                util.sizeFromShape(aShape) % 4 === 0) {
                this.isVec4 = true;
                this.type = 'vec4';
                this.workPerThread = 4;
            }
            else {
                this.isVec4 = false;
                this.type = 'plain';
                this.workPerThread = 1;
            }
            this.shaderKey = `binary_${this.type}_${op}`;
            // TODO(jiajia.qin@intel.com): Heuristically select a good work group
            // size.
            this.workgroupSize = [128, 1, 1];
        }
        this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workgroupSize, [this.workPerThread, 1, 1]);
    }
    getUserCode() {
        let userCode;
        const dType = this.isVec4 ? 'vec4<f32>' : 'f32';
        const opFnStr = `
    fn binaryOperation(a : ${dType}, b : ${dType}) -> ${dType} {
      let isNaN = false;
      {
        ${getBinaryOpString(this.op, this.isVec4)}
      }
    };
    `;
        if (this.type === 'shared') {
            const sharedIndexSnippet = this.lastDimensionSize > 1 ?
                `coords[${this.outputShape.length - 1}]` :
                '0';
            const accessDataSnippet = this.useSharedMemoryWithB ?
                `let a = getAByOutputIndex(index);
          let b = sharedBuf[${sharedIndexSnippet}];` :
                `let a = sharedBuf[${sharedIndexSnippet}];
          let b = getBByOutputIndex(index);`;
            userCode = `
        ${opFnStr}
        var<workgroup> sharedBuf : array<f32, ${this.lastDimensionSize}>;
        ${main('index')} {
          // Fill in the shared memory buffer.
          let localIndex = i32(localId.x);
          if(localIndex < ${this.lastDimensionSize}) {
            sharedBuf[localIndex] = f32(${this.useSharedMemoryWithB ? 'B' : 'A'}[localIndex]);
          }
          workgroupBarrier();

          if(index < uniforms.size) {
            let coords = getCoordsFromIndex(index);
            ${accessDataSnippet}
            setOutputAtIndex(index, binaryOperation(a, b));
          }
        }
        `;
        }
        else {
            userCode = `
       ${opFnStr}
       ${main('index')} {
         if (index < uniforms.size) {
           let a = getAByOutputIndex(index);
           let b = getBByOutputIndex(index);
           setOutputAtIndex(index, binaryOperation(a, b));
         }
       }
       `;
        }
        return userCode;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmluYXJ5X29wX3dlYmdwdS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3RmanMtYmFja2VuZC13ZWJncHUvc3JjL2JpbmFyeV9vcF93ZWJncHUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7OztHQWVHO0FBRUgsT0FBTyxFQUFDLFlBQVksRUFBRSxJQUFJLEVBQUMsTUFBTSx1QkFBdUIsQ0FBQztBQUV6RCxPQUFPLEVBQWUsaUJBQWlCLEVBQUMsTUFBTSxrQkFBa0IsQ0FBQztBQUNqRSxPQUFPLEVBQUMsbUJBQW1CLElBQUksSUFBSSxFQUFnQixNQUFNLGtCQUFrQixDQUFDO0FBQzVFLE9BQU8sRUFBQyxlQUFlLEVBQUUsa0JBQWtCLEVBQUMsTUFBTSxlQUFlLENBQUM7QUFFbEUsTUFBTSxPQUFPLGVBQWU7SUFpQjFCLFlBQVksRUFBZ0IsRUFBRSxNQUFnQixFQUFFLE1BQWdCO1FBVmhFLFNBQUksR0FBRyxJQUFJLENBQUM7UUFDWixrQkFBYSxHQUFHLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxDQUFDO1FBVXpCLElBQUksQ0FBQyxXQUFXLEdBQUcsWUFBWSxDQUFDLDBCQUEwQixDQUFDLE1BQU0sRUFBRSxNQUFNLENBQUMsQ0FBQztRQUMzRSxJQUFJLENBQUMsY0FBYyxHQUFHLGtCQUFrQixDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQztRQUMzRCxJQUFJLENBQUMsRUFBRSxHQUFHLEVBQUUsQ0FBQztRQUViLElBQUksQ0FBQyxvQkFBb0I7WUFDckIsTUFBTSxDQUFDLE1BQU0sSUFBSSxDQUFDLElBQUksTUFBTSxDQUFDLE1BQU0sR0FBRyxDQUFDLElBQUksTUFBTSxDQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQztRQUMvRCxJQUFJLENBQUMsb0JBQW9CO1lBQ3JCLE1BQU0sQ0FBQyxNQUFNLElBQUksQ0FBQyxJQUFJLE1BQU0sQ0FBQyxNQUFNLEdBQUcsQ0FBQyxJQUFJ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QUFJLENBQUMsaUJBQWlCO1VBQzVELElBQUksQ0FBQyxPQUFPLENBQUM7Ozs0QkFHSyxJQUFJLENBQUMsaUJBQWlCOzBDQUV4QyxJQUFJLENBQUMsb0JBQW9CLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRzs7Ozs7O2NBTWpDLGlCQUFpQjs7OztTQUl0QixDQUFDO1NBQ0w7YUFBTTtZQUNMLFFBQVEsR0FBRztTQUNSLE9BQU87U0FDUCxJQUFJLENBQUMsT0FBTyxDQUFDOzs7Ozs7O1FBT2QsQ0FBQztTQUNKO1FBRUQsT0FBTyxRQUFRLENBQUM7SUFDbEIsQ0FBQztDQUNGIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuXG5pbXBvcnQge2JhY2tlbmRfdXRpbCwgdXRpbH0gZnJvbSAnQHRlbnNvcmZsb3cvdGZqcy1jb3JlJztcblxuaW1wb3J0IHtCaW5hcnlPcFR5cGUsIGdldEJpbmFyeU9wU3RyaW5nfSBmcm9tICcuL2JpbmFyeV9vcF91dGlsJztcbmltcG9ydCB7Z2V0TWFpbkhlYWRlclN0cmluZyBhcyBtYWluLCBXZWJHUFVQcm9ncmFtfSBmcm9tICcuL3dlYmdwdV9wcm9ncmFtJztcbmltcG9ydCB7Y29tcHV0ZURpc3BhdGNoLCBmbGF0RGlzcGF0Y2hMYXlvdXR9IGZyb20gJy4vd2ViZ3B1X3V0aWwnO1xuXG5leHBvcnQgY2xhc3MgQmluYXJ5T3BQcm9ncmFtIGltcGxlbWVudHMgV2ViR1BVUHJvZ3JhbSB7XG4gIGRpc3BhdGNoOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl07XG4gIGRpc3BhdGNoTGF5b3V0OiB7eDogbnVtYmVyW119O1xuICBpc1ZlYzQ6IGJvb2xlYW47XG4gIG9wOiBCaW5hcnlPcFR5cGU7XG4gIG91dHB1dFNoYXBlOiBudW1iZXJbXTtcbiAgc2hhZGVyS2V5OiBzdHJpbmc7XG4gIHNpemUgPSB0cnVlO1xuICB2YXJpYWJsZU5hbWVzID0gWydBJywgJ0InXTtcbiAgd29ya2dyb3VwU2l6ZTogW251bWJlciwgbnVtYmVyLCBudW1iZXJdO1xuICB3b3JrUGVyVGhyZWFkOiBudW1iZXI7XG5cbiAgcHJpdmF0ZSBsYXN0RGltZW5zaW9uU2l6ZTogbnVtYmVyO1xuICBwcml2YXRlIHVzZVNoYXJlZE1lbW9yeVdpdGhBOiBib29sZWFuO1xuICBwcml2YXRlIHVzZVNoYXJlZE1lbW9yeVdpdGhCOiBib29sZWFuO1xuICBwcml2YXRlIHR5cGU6IHN0cmluZztcblxuICBjb25zdHJ1Y3RvcihvcDogQmluYXJ5T3BUeXBlLCBhU2hhcGU6IG51bWJlcltdLCBiU2hhcGU6IG51bWJlcltdKSB7XG4gICAgdGhpcy5vdXRwdXRTaGFwZSA9IGJhY2tlbmRfdXRpbC5hc3NlcnRBbmRHZXRCcm9hZGNhc3RTaGFwZShhU2hhcGUsIGJTaGFwZSk7XG4gICAgdGhpcy5kaXNwYXRjaExheW91dCA9IGZsYXREaXNwYXRjaExheW91dCh0aGlzLm91dHB1dFNoYXBlKTtcbiAgICB0aGlzLm9wID0gb3A7XG5cbiAgICB0aGlzLnVzZVNoYXJlZE1lbW9yeVdpdGhBID1cbiAgICAgICAgYVNoYXBlLmxlbmd0aCA8PSAxICYmIGJTaGFwZS5sZW5ndGggPiAxICYmIGFTaGFwZVswXSA8IDEyODtcbiAgICB0aGlzLnVzZVNoYXJlZE1lbW9yeVdpdGhCID1cbiAgICAgICAgYlNoYXBlLmxlbmd0aCA8PSAxICYmIGFTaGFwZS5sZW5ndGggPiAxICYmIGJTaGFwZVswXSA8IDEyODtcblxuICAgIGlmICh0aGlzLnVzZVNoYXJlZE1lbW9yeVdpdGhBIHx8IHRoaXMudXNlU2hhcmVkTWVtb3J5V2l0aEIpIHtcbiAgICAgIHRoaXMuaXNWZWM0ID0gZmFsc2U7XG4gICAgICAvLyBsYXN0RGltZW5zaW9uU2l6ZSBpcyB1c2VkIGFzIHNoYXJlZEJ1ZiBhcnJheSBzaXplLCBzbyBjYW4gbm90IGJlXG4gICAgICAvLyB1c2VkIGFzIHVuaWZvcm0uXG4gICAgICB0aGlzLmxhc3REaW1lbnNpb25TaXplID1cbiAgICAgICAgICB0aGlzLnVzZVNoYXJlZE1lbW9yeVdpdGhCID8gYlNoYXBlWzBdIDogYVNoYXBlWzBdO1xuICAgICAgdGhpcy5zaGFkZXJLZXkgPSBgYmluYXJ5XyR7dGhpcy50eXBlfV8ke29wfV8ke3RoaXMubGFzdERpbWVuc2lvblNpemV9XyR7XG4gICAgICAgICAgdGhpcy51c2VTaGFyZWRNZW1vcnlXaXRoQn1gO1xuICAgICAgdGhpcy50eXBlID0gJ3NoYXJlZCc7XG4gICAgICAvLyBUaGlzIGlzIGFuIGV4cGVyaW1lbnRhbCB2YWx1ZSB3aGVuIHVzaW5nIHNoYXJlZCBtZW1vcnkuXG4gICAgICAvLyBOb3RlIHRoYXQgdGhlIG1heGltdW0gb2Ygd29ya2dyb3VwIFggZGltZW5zaW9uIGlzIDI1Ni5cbiAgICAgIHRoaXMud29ya2dyb3VwU2l6ZSA9IFsyNTYsIDEsIDFdO1xuICAgICAgdGhpcy53b3JrUGVyVGhyZWFkID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHV0aWwuYXJyYXlzRXF1YWwoYVNoYXBlLCBiU2hhcGUpICYmXG4gICAgICAgICAgdXRpbC5zaXplRnJvbVNoYXBlKGFTaGFwZSkgJSA0ID09PSAwKSB7XG4gICAgICAgIHRoaXMuaXNWZWM0ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy50eXBlID0gJ3ZlYzQnO1xuICAgICAgICB0aGlzLndvcmtQZXJUaHJlYWQgPSA0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5pc1ZlYzQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy50eXBlID0gJ3BsYWluJztcbiAgICAgICAgdGhpcy53b3JrUGVyVGhyZWFkID0gMTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2hhZGVyS2V5ID0gYGJpbmFyeV8ke3RoaXMudHlwZX1fJHtvcH1gO1xuICAgICAgLy8gVE9ETyhqaWFqaWEucWluQGludGVsLmNvbSk6IEhldXJpc3RpY2FsbHkgc2VsZWN0IGEgZ29vZCB3b3JrIGdyb3VwXG4gICAgICAvLyBzaXplLlxuICAgICAgdGhpcy53b3JrZ3JvdXBTaXplID0gWzEyOCwgMSwgMV07XG4gICAgfVxuICAgIHRoaXMuZGlzcGF0Y2ggPSBjb21wdXRlRGlzcGF0Y2goXG4gICAgICAgIHRoaXMuZGlzcGF0Y2hMYXlvdXQsIHRoaXMub3V0cHV0U2hhcGUsIHRoaXMud29ya2dyb3VwU2l6ZSxcbiAgICAgICAgW3RoaXMud29ya1BlclRocmVhZCwgMSwgMV0pO1xuICB9XG5cbiAgZ2V0VXNlckNvZGUoKTogc3RyaW5nIHtcbiAgICBsZXQgdXNlckNvZGU7XG4gICAgY29uc3QgZFR5cGUgPSB0aGlzLmlzVmVjNCA/ICd2ZWM0PGYzMj4nIDogJ2YzMic7XG4gICAgY29uc3Qgb3BGblN0ciA9IGBcbiAgICBmbiBiaW5hcnlPcGVyYXRpb24oYSA6ICR7ZFR5cGV9LCBiIDogJHtkVHlwZX0pIC0+ICR7ZFR5cGV9IHtcbiAgICAgIGxldCBpc05hTiA9IGZhbHNlO1xuICAgICAge1xuICAgICAgICAke2dldEJpbmFyeU9wU3RyaW5nKHRoaXMub3AsIHRoaXMuaXNWZWM0KX1cbiAgICAgIH1cbiAgICB9O1xuICAgIGA7XG5cbiAgICBpZiAodGhpcy50eXBlID09PSAnc2hhcmVkJykge1xuICAgICAgY29uc3Qgc2hhcmVkSW5kZXhTbmlwcGV0ID0gdGhpcy5sYXN0RGltZW5zaW9uU2l6ZSA+IDEgP1xuICAgICAgICAgIGBjb29yZHNbJHt0aGlzLm91dHB1dFNoYXBlLmxlbmd0aCAtIDF9XWAgOlxuICAgICAgICAgICcwJztcbiAgICAgIGNvbnN0IGFjY2Vzc0RhdGFTbmlwcGV0ID0gdGhpcy51c2VTaGFyZWRNZW1vcnlXaXRoQiA/XG4gICAgICAgICAgYGxldCBhID0gZ2V0QUJ5T3V0cHV0SW5kZXgoaW5kZXgpO1xuICAgICAgICAgIGxldCBiID0gc2hhcmVkQnVmWyR7c2hhcmVkSW5kZXhTbmlwcGV0fV07YCA6XG4gICAgICAgICAgYGxldCBhID0gc2hhcmVkQnVmWyR7c2hhcmVkSW5kZXhTbmlwcGV0fV07XG4gICAgICAgICAgbGV0IGIgPSBnZXRCQnlPdXRwdXRJbmRleChpbmRleCk7YDtcbiAgICAgIHVzZXJDb2RlID0gYFxuICAgICAgICAke29wRm5TdHJ9XG4gICAgICAgIHZhcjx3b3JrZ3JvdXA+IHNoYXJlZEJ1ZiA6IGFycmF5PGYzMiwgJHt0aGlzLmxhc3REaW1lbnNpb25TaXplfT47XG4gICAgICAgICR7bWFpbignaW5kZXgnKX0ge1xuICAgICAgICAgIC8vIEZpbGwgaW4gdGhlIHNoYXJlZCBtZW1vcnkgYnVmZmVyLlxuICAgICAgICAgIGxldCBsb2NhbEluZGV4ID0gaTMyKGxvY2FsSWQueCk7XG4gICAgICAgICAgaWYobG9jYWxJbmRleCA8ICR7dGhpcy5sYXN0RGltZW5zaW9uU2l6ZX0pIHtcbiAgICAgICAgICAgIHNoYXJlZEJ1Zltsb2NhbEluZGV4XSA9IGYzMigke1xuICAgICAgICAgIHRoaXMudXNlU2hhcmVkTWVtb3J5V2l0aEIgPyAnQicgOiAnQSd9W2xvY2FsSW5kZXhdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gICAgICAgICAgaWYoaW5kZXggPCB1bmlmb3Jtcy5zaXplKSB7XG4gICAgICAgICAgICBsZXQgY29vcmRzID0gZ2V0Q29vcmRzRnJvbUluZGV4KGluZGV4KTtcbiAgICAgICAgICAgICR7YWNjZXNzRGF0YVNuaXBwZXR9XG4gICAgICAgICAgICBzZXRPdXRwdXRBdEluZGV4KGluZGV4LCBiaW5hcnlPcGVyYXRpb24oYSwgYikpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBgO1xuICAgIH0gZWxzZSB7XG4gICAgICB1c2VyQ29kZSA9IGBcbiAgICAgICAke29wRm5TdHJ9XG4gICAgICAgJHttYWluKCdpbmRleCcpfSB7XG4gICAgICAgICBpZiAoaW5kZXggPCB1bmlmb3Jtcy5zaXplKSB7XG4gICAgICAgICAgIGxldCBhID0gZ2V0QUJ5T3V0cHV0SW5kZXgoaW5kZXgpO1xuICAgICAgICAgICBsZXQgYiA9IGdldEJCeU91dHB1dEluZGV4KGluZGV4KTtcbiAgICAgICAgICAgc2V0T3V0cHV0QXRJbmRleChpbmRleCwgYmluYXJ5T3BlcmF0aW9uKGEsIGIpKTtcbiAgICAgICAgIH1cbiAgICAgICB9XG4gICAgICAgYDtcbiAgICB9XG5cbiAgICByZXR1cm4gdXNlckNvZGU7XG4gIH1cbn1cbiJdfQ==