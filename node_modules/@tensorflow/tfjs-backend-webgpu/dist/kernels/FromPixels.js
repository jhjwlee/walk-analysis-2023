/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use backend file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
import { env } from '@tensorflow/tfjs-core';
import { FromPixels, util } from '@tensorflow/tfjs-core';
import { FromPixelsProgram } from '../from_pixels_webgpu';
export const fromPixelsConfig = {
    kernelName: FromPixels,
    backendName: 'webgpu',
    kernelFunc: fromPixels,
};
let fromPixels2DContext;
let willReadFrequently = env().getBool('CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU');
const videoToTextureMap = new Map();
export function fromPixels(args) {
    const { inputs, backend, attrs } = args;
    let { pixels } = inputs;
    const { numChannels } = attrs;
    if (pixels == null) {
        throw new Error('pixels passed to tf.browser.fromPixels() can not be null');
    }
    const isVideo = typeof (HTMLVideoElement) !== 'undefined' &&
        pixels instanceof HTMLVideoElement;
    const isImage = typeof (HTMLImageElement) !== 'undefined' &&
        pixels instanceof HTMLImageElement;
    const isCanvas = (typeof (HTMLCanvasElement) !== 'undefined' &&
        pixels instanceof HTMLCanvasElement) ||
        (typeof (OffscreenCanvas) !== 'undefined' &&
            pixels instanceof OffscreenCanvas);
    const isImageBitmap = typeof (ImageBitmap) !== 'undefined' && pixels instanceof ImageBitmap;
    const [width, height] = isVideo ?
        [
            pixels.videoWidth,
            pixels.videoHeight
        ] :
        [pixels.width, pixels.height];
    const outputShape = [height, width, numChannels];
    // Disable importExternalTexture temporarily as it has problem in spec and
    // browser impl
    const importVideo = false && env().getBool('WEBGPU_IMPORT_EXTERNAL_TEXTURE') && isVideo;
    const isVideoOrImage = isVideo || isImage;
    if (isImageBitmap || isCanvas || isVideoOrImage) {
        let textureInfo;
        if (importVideo) {
            const videoElement = pixels;
            if (!(videoToTextureMap.has(videoElement)) ||
                videoToTextureMap.get(videoElement).expired) {
                const externalTextureDescriptor = { source: videoElement };
                videoToTextureMap.set(videoElement, backend.device.importExternalTexture(externalTextureDescriptor));
            }
            textureInfo = {
                width,
                height,
                format: null,
                usage: null,
                texture: videoToTextureMap.get(videoElement)
            };
        }
        else {
            if (isVideoOrImage) {
                const newWillReadFrequently = env().getBool('CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU');
                if (fromPixels2DContext == null ||
                    newWillReadFrequently !== willReadFrequently) {
                    willReadFrequently = newWillReadFrequently;
                    fromPixels2DContext =
                        document.createElement('canvas').getContext('2d', { willReadFrequently });
                }
                fromPixels2DContext.canvas.width = width;
                fromPixels2DContext.canvas.height = height;
                fromPixels2DContext.drawImage(pixels, 0, 0, width, height);
                pixels = fromPixels2DContext.canvas;
            }
            const usage = GPUTextureUsage.COPY_DST |
                GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING;
            const format = 'rgba8unorm';
            const texture = backend.textureManager.acquireTexture(outputShape[1], outputShape[0], format, usage);
            backend.queue.copyExternalImageToTexture({ source: pixels }, { texture }, [outputShape[1], outputShape[0]]);
            textureInfo = { width, height, format, usage, texture };
        }
        const size = util.sizeFromShape(outputShape);
        const strides = util.computeStrides(outputShape);
        const program = new FromPixelsProgram(outputShape, numChannels, importVideo);
        const uniformData = [
            { type: 'uint32', data: [size] }, { type: 'uint32', data: [numChannels] },
            { type: 'uint32', data: [...strides] }
        ];
        const input = backend.makeTensorInfo([height, width], 'int32');
        const info = backend.tensorMap.get(input.dataId);
        info.resourceInfo = textureInfo;
        const result = backend.runWebGPUProgram(program, [input], 'int32', uniformData);
        backend.disposeData(input.dataId);
        return result;
    }
    // TODO: Encoding should happen on GPU once we no longer have to download
    // image data to the CPU.
    const imageData = pixels.data;
    let pixelArray = imageData;
    if (numChannels != null && numChannels !== 4) {
        pixelArray = new Uint8Array(pixels.width * pixels.height * numChannels);
        const dataLength = imageData.length;
        let j = 0;
        for (let i = 0; i < dataLength; i++) {
            if (i % 4 < numChannels) {
                pixelArray[j++] = imageData[i];
            }
        }
    }
    const output = backend.makeTensorInfo(outputShape, 'int32', new Int32Array(pixelArray));
    backend.uploadToGPU(output.dataId);
    return output;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRnJvbVBpeGVscy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3RmanMtYmFja2VuZC13ZWJncHUvc3JjL2tlcm5lbHMvRnJvbVBpeGVscy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7O0dBZUc7QUFFSCxPQUFPLEVBQUMsR0FBRyxFQUEyQixNQUFNLHVCQUF1QixDQUFDO0FBQ3BFLE9BQU8sRUFBQyxVQUFVLEVBQXFDLElBQUksRUFBQyxNQUFNLHVCQUF1QixDQUFDO0FBSTFGLE9BQU8sRUFBQyxpQkFBaUIsRUFBQyxNQUFNLHVCQUF1QixDQUFDO0FBRXhELE1BQU0sQ0FBQyxNQUFNLGdCQUFnQixHQUFpQjtJQUM1QyxVQUFVLEVBQUUsVUFBVTtJQUN0QixXQUFXLEVBQUUsUUFBUTtJQUNyQixVQUFVLEVBQUUsVUFBbUM7Q0FDaEQsQ0FBQztBQUVGLElBQUksbUJBQTZDLENBQUM7QUFDbEQsSUFBSSxrQkFBa0IsR0FBRyxHQUFHLEVBQUUsQ0FBQyxPQUFPLENBQUMsdUNBQXVDLENBQUMsQ0FBQztBQUNoRixNQUFNLGlCQUFpQixHQUFHLElBQUksR0FBRyxFQUFrQixDQUFDO0FBRXBELE1BQU0sVUFBVSxVQUFVLENBQUMsSUFJMUI7SUFDQyxNQUFNLEVBQUMsTUFBTSxFQUFFLE9BQU8sRUFBRSxLQUFLLEVBQUMsR0FBRyxJQUFJLENBQUM7SUFDdEMsSUFBSSxFQUFDLE1BQU0sRUFBQyxHQUFHLE1BQU0sQ0FBQztJQUN0QixNQUFNLEVBQUMsV0FBVyxFQUFDLEdBQUcsS0FBSyxDQUFDO0lBRTVCLElBQUksTUFBTSxJQUFJLElBQUksRUFBRTtRQUNsQixNQUFNLElBQUksS0FBSyxDQUFDLDBEQUEwRCxDQUFDLENBQUM7S0FDN0U7SUFFRCxNQUFNLE9BQU8sR0FBRyxPQUFPLENBQUMsZ0JBQWdCLENBQUMsS0FBSyxXQUFXO1FBQ3JELE1BQU0sWUFBWSxnQkFBZ0IsQ0FBQztJQUN2QyxN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QyxXQUFXLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQ25DLE9BQU8sTUFBTSxDQUFDO0FBQ2hCLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSBiYWNrZW5kIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbmltcG9ydCB7ZW52LCBLZXJuZWxDb25maWcsIEtlcm5lbEZ1bmN9IGZyb20gJ0B0ZW5zb3JmbG93L3RmanMtY29yZSc7XG5pbXBvcnQge0Zyb21QaXhlbHMsIEZyb21QaXhlbHNBdHRycywgRnJvbVBpeGVsc0lucHV0cywgdXRpbH0gZnJvbSAnQHRlbnNvcmZsb3cvdGZqcy1jb3JlJztcbmltcG9ydCB7YmFja2VuZF91dGlsLCBUZW5zb3JJbmZvfSBmcm9tICdAdGVuc29yZmxvdy90ZmpzLWNvcmUnO1xuXG5pbXBvcnQge1RleHR1cmVJbmZvLCBXZWJHUFVCYWNrZW5kfSBmcm9tICcuLi9iYWNrZW5kX3dlYmdwdSc7XG5pbXBvcnQge0Zyb21QaXhlbHNQcm9ncmFtfSBmcm9tICcuLi9mcm9tX3BpeGVsc193ZWJncHUnO1xuXG5leHBvcnQgY29uc3QgZnJvbVBpeGVsc0NvbmZpZzogS2VybmVsQ29uZmlnID0ge1xuICBrZXJuZWxOYW1lOiBGcm9tUGl4ZWxzLFxuICBiYWNrZW5kTmFtZTogJ3dlYmdwdScsXG4gIGtlcm5lbEZ1bmM6IGZyb21QaXhlbHMgYXMgdW5rbm93biBhcyBLZXJuZWxGdW5jLFxufTtcblxubGV0IGZyb21QaXhlbHMyRENvbnRleHQ6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRDtcbmxldCB3aWxsUmVhZEZyZXF1ZW50bHkgPSBlbnYoKS5nZXRCb29sKCdDQU5WQVMyRF9XSUxMX1JFQURfRlJFUVVFTlRMWV9GT1JfR1BVJyk7XG5jb25zdCB2aWRlb1RvVGV4dHVyZU1hcCA9IG5ldyBNYXA8b2JqZWN0LCBvYmplY3Q+KCk7XG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tUGl4ZWxzKGFyZ3M6IHtcbiAgaW5wdXRzOiBGcm9tUGl4ZWxzSW5wdXRzLFxuICBiYWNrZW5kOiBXZWJHUFVCYWNrZW5kLFxuICBhdHRyczogRnJvbVBpeGVsc0F0dHJzXG59KTogVGVuc29ySW5mbyB7XG4gIGNvbnN0IHtpbnB1dHMsIGJhY2tlbmQsIGF0dHJzfSA9IGFyZ3M7XG4gIGxldCB7cGl4ZWxzfSA9IGlucHV0cztcbiAgY29uc3Qge251bUNoYW5uZWxzfSA9IGF0dHJzO1xuXG4gIGlmIChwaXhlbHMgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcigncGl4ZWxzIHBhc3NlZCB0byB0Zi5icm93c2VyLmZyb21QaXhlbHMoKSBjYW4gbm90IGJlIG51bGwnKTtcbiAgfVxuXG4gIGNvbnN0IGlzVmlkZW8gPSB0eXBlb2YgKEhUTUxWaWRlb0VsZW1lbnQpICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgcGl4ZWxzIGluc3RhbmNlb2YgSFRNTFZpZGVvRWxlbWVudDtcbiAgY29uc3QgaXNJbWFnZSA9IHR5cGVvZiAoSFRNTEltYWdlRWxlbWVudCkgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICBwaXhlbHMgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50O1xuICBjb25zdCBpc0NhbnZhcyA9ICh0eXBlb2YgKEhUTUxDYW52YXNFbGVtZW50KSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgICAgICAgICAgcGl4ZWxzIGluc3RhbmNlb2YgSFRNTENhbnZhc0VsZW1lbnQpIHx8XG4gICAgICAodHlwZW9mIChPZmZzY3JlZW5DYW52YXMpICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgIHBpeGVscyBpbnN0YW5jZW9mIE9mZnNjcmVlbkNhbnZhcyk7XG4gIGNvbnN0IGlzSW1hZ2VCaXRtYXAgPVxuICAgICAgdHlwZW9mIChJbWFnZUJpdG1hcCkgIT09ICd1bmRlZmluZWQnICYmIHBpeGVscyBpbnN0YW5jZW9mIEltYWdlQml0bWFwO1xuXG4gIGNvbnN0IFt3aWR0aCwgaGVpZ2h0XSA9IGlzVmlkZW8gP1xuICAgICAgW1xuICAgICAgICAocGl4ZWxzIGFzIEhUTUxWaWRlb0VsZW1lbnQpLnZpZGVvV2lkdGgsXG4gICAgICAgIChwaXhlbHMgYXMgSFRNTFZpZGVvRWxlbWVudCkudmlkZW9IZWlnaHRcbiAgICAgIF0gOlxuICAgICAgW3BpeGVscy53aWR0aCwgcGl4ZWxzLmhlaWdodF07XG4gIGNvbnN0IG91dHB1dFNoYXBlID0gW2hlaWdodCwgd2lkdGgsIG51bUNoYW5uZWxzXTtcblxuICAvLyBEaXNhYmxlIGltcG9ydEV4dGVybmFsVGV4dHVyZSB0ZW1wb3JhcmlseSBhcyBpdCBoYXMgcHJvYmxlbSBpbiBzcGVjIGFuZFxuICAvLyBicm93c2VyIGltcGxcbiAgY29uc3QgaW1wb3J0VmlkZW8gPVxuICAgICAgZmFsc2UgJiYgZW52KCkuZ2V0Qm9vbCgnV0VCR1BVX0lNUE9SVF9FWFRFUk5BTF9URVhUVVJFJykgJiYgaXNWaWRlbztcbiAgY29uc3QgaXNWaWRlb09ySW1hZ2UgPSBpc1ZpZGVvIHx8IGlzSW1hZ2U7XG4gIGlmIChpc0ltYWdlQml0bWFwIHx8IGlzQ2FudmFzIHx8IGlzVmlkZW9PckltYWdlKSB7XG4gICAgbGV0IHRleHR1cmVJbmZvOiBUZXh0dXJlSW5mbztcbiAgICBpZiAoaW1wb3J0VmlkZW8pIHtcbiAgICAgIGNvbnN0IHZpZGVvRWxlbWVudCA9IHBpeGVscyBhcyBIVE1MVmlkZW9FbGVtZW50O1xuICAgICAgaWYgKCEodmlkZW9Ub1RleHR1cmVNYXAuaGFzKHZpZGVvRWxlbWVudCkpIHx8XG4gICAgICAgICAgKHZpZGVvVG9UZXh0dXJlTWFwLmdldCh2aWRlb0VsZW1lbnQpIGFzIEdQVUV4dGVybmFsVGV4dHVyZSkuZXhwaXJlZCkge1xuICAgICAgICBjb25zdCBleHRlcm5hbFRleHR1cmVEZXNjcmlwdG9yID0ge3NvdXJjZTogdmlkZW9FbGVtZW50fTtcbiAgICAgICAgdmlkZW9Ub1RleHR1cmVNYXAuc2V0KFxuICAgICAgICAgICAgdmlkZW9FbGVtZW50LFxuICAgICAgICAgICAgYmFja2VuZC5kZXZpY2UuaW1wb3J0RXh0ZXJuYWxUZXh0dXJlKGV4dGVybmFsVGV4dHVyZURlc2NyaXB0b3IpKTtcbiAgICAgIH1cblxuICAgICAgdGV4dHVyZUluZm8gPSB7XG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHQsXG4gICAgICAgIGZvcm1hdDogbnVsbCxcbiAgICAgICAgdXNhZ2U6IG51bGwsXG4gICAgICAgIHRleHR1cmU6IHZpZGVvVG9UZXh0dXJlTWFwLmdldCh2aWRlb0VsZW1lbnQpIGFzIEdQVUV4dGVybmFsVGV4dHVyZVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGlzVmlkZW9PckltYWdlKSB7XG4gICAgICAgIGNvbnN0IG5ld1dpbGxSZWFkRnJlcXVlbnRseSA9XG4gICAgICAgICAgICBlbnYoKS5nZXRCb29sKCdDQU5WQVMyRF9XSUxMX1JFQURfRlJFUVVFTlRMWV9GT1JfR1BVJyk7XG4gICAgICAgIGlmIChmcm9tUGl4ZWxzMkRDb250ZXh0ID09IG51bGwgfHxcbiAgICAgICAgICAgIG5ld1dpbGxSZWFkRnJlcXVlbnRseSAhPT0gd2lsbFJlYWRGcmVxdWVudGx5KSB7XG4gICAgICAgICAgd2lsbFJlYWRGcmVxdWVudGx5ID0gbmV3V2lsbFJlYWRGcmVxdWVudGx5O1xuICAgICAgICAgIGZyb21QaXhlbHMyRENvbnRleHQgPVxuICAgICAgICAgICAgICBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKS5nZXRDb250ZXh0KFxuICAgICAgICAgICAgICAgICAgJzJkJywge3dpbGxSZWFkRnJlcXVlbnRseX0pO1xuICAgICAgICB9XG4gICAgICAgIGZyb21QaXhlbHMyRENvbnRleHQuY2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgICAgIGZyb21QaXhlbHMyRENvbnRleHQuY2FudmFzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgZnJvbVBpeGVsczJEQ29udGV4dC5kcmF3SW1hZ2UoXG4gICAgICAgICAgICBwaXhlbHMgYXMgSFRNTFZpZGVvRWxlbWVudCB8IEhUTUxJbWFnZUVsZW1lbnQsIDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICBwaXhlbHMgPSBmcm9tUGl4ZWxzMkRDb250ZXh0LmNhbnZhcztcbiAgICAgIH1cblxuICAgICAgY29uc3QgdXNhZ2UgPSBHUFVUZXh0dXJlVXNhZ2UuQ09QWV9EU1QgfFxuICAgICAgICAgIEdQVVRleHR1cmVVc2FnZS5SRU5ERVJfQVRUQUNITUVOVCB8IEdQVVRleHR1cmVVc2FnZS5URVhUVVJFX0JJTkRJTkc7XG4gICAgICBjb25zdCBmb3JtYXQgPSAncmdiYTh1bm9ybScgYXMgR1BVVGV4dHVyZUZvcm1hdDtcbiAgICAgIGNvbnN0IHRleHR1cmUgPSBiYWNrZW5kLnRleHR1cmVNYW5hZ2VyLmFjcXVpcmVUZXh0dXJlKFxuICAgICAgICAgIG91dHB1dFNoYXBlWzFdLCBvdXRwdXRTaGFwZVswXSwgZm9ybWF0LCB1c2FnZSk7XG4gICAgICBiYWNrZW5kLnF1ZXVlLmNvcHlFeHRlcm5hbEltYWdlVG9UZXh0dXJlKFxuICAgICAgICAgIHtzb3VyY2U6IHBpeGVscyBhcyBIVE1MQ2FudmFzRWxlbWVudCB8IEltYWdlQml0bWFwfSwge3RleHR1cmV9LFxuICAgICAgICAgIFtvdXRwdXRTaGFwZVsxXSwgb3V0cHV0U2hhcGVbMF1dKTtcbiAgICAgIHRleHR1cmVJbmZvID0ge3dpZHRoLCBoZWlnaHQsIGZvcm1hdCwgdXNhZ2UsIHRleHR1cmV9O1xuICAgIH1cblxuICAgIGNvbnN0IHNpemUgPSB1dGlsLnNpemVGcm9tU2hhcGUob3V0cHV0U2hhcGUpO1xuICAgIGNvbnN0IHN0cmlkZXMgPSB1dGlsLmNvbXB1dGVTdHJpZGVzKG91dHB1dFNoYXBlKTtcbiAgICBjb25zdCBwcm9ncmFtID1cbiAgICAgICAgbmV3IEZyb21QaXhlbHNQcm9ncmFtKG91dHB1dFNoYXBlLCBudW1DaGFubmVscywgaW1wb3J0VmlkZW8pO1xuXG4gICAgY29uc3QgdW5pZm9ybURhdGEgPSBbXG4gICAgICB7dHlwZTogJ3VpbnQzMicsIGRhdGE6IFtzaXplXX0sIHt0eXBlOiAndWludDMyJywgZGF0YTogW251bUNoYW5uZWxzXX0sXG4gICAgICB7dHlwZTogJ3VpbnQzMicsIGRhdGE6IFsuLi5zdHJpZGVzXX1cbiAgICBdO1xuICAgIGNvbnN0IGlucHV0ID0gYmFja2VuZC5tYWtlVGVuc29ySW5mbyhbaGVpZ2h0LCB3aWR0aF0sICdpbnQzMicpO1xuICAgIGNvbnN0IGluZm8gPSBiYWNrZW5kLnRlbnNvck1hcC5nZXQoaW5wdXQuZGF0YUlkKTtcbiAgICBpbmZvLnJlc291cmNlSW5mbyA9IHRleHR1cmVJbmZvO1xuXG4gICAgY29uc3QgcmVzdWx0ID1cbiAgICAgICAgYmFja2VuZC5ydW5XZWJHUFVQcm9ncmFtKHByb2dyYW0sIFtpbnB1dF0sICdpbnQzMicsIHVuaWZvcm1EYXRhKTtcbiAgICBiYWNrZW5kLmRpc3Bvc2VEYXRhKGlucHV0LmRhdGFJZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIFRPRE86IEVuY29kaW5nIHNob3VsZCBoYXBwZW4gb24gR1BVIG9uY2Ugd2Ugbm8gbG9uZ2VyIGhhdmUgdG8gZG93bmxvYWRcbiAgLy8gaW1hZ2UgZGF0YSB0byB0aGUgQ1BVLlxuICBjb25zdCBpbWFnZURhdGEgPSAocGl4ZWxzIGFzIEltYWdlRGF0YSB8IGJhY2tlbmRfdXRpbC5QaXhlbERhdGEpLmRhdGE7XG4gIGxldCBwaXhlbEFycmF5ID0gaW1hZ2VEYXRhO1xuICBpZiAobnVtQ2hhbm5lbHMgIT0gbnVsbCAmJiBudW1DaGFubmVscyAhPT0gNCkge1xuICAgIHBpeGVsQXJyYXkgPSBuZXcgVWludDhBcnJheShwaXhlbHMud2lkdGggKiBwaXhlbHMuaGVpZ2h0ICogbnVtQ2hhbm5lbHMpO1xuXG4gICAgY29uc3QgZGF0YUxlbmd0aCA9IGltYWdlRGF0YS5sZW5ndGg7XG4gICAgbGV0IGogPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YUxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoaSAlIDQgPCBudW1DaGFubmVscykge1xuICAgICAgICBwaXhlbEFycmF5W2orK10gPSBpbWFnZURhdGFbaV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY29uc3Qgb3V0cHV0ID1cbiAgICAgIGJhY2tlbmQubWFrZVRlbnNvckluZm8ob3V0cHV0U2hhcGUsICdpbnQzMicsIG5ldyBJbnQzMkFycmF5KHBpeGVsQXJyYXkpKTtcbiAgYmFja2VuZC51cGxvYWRUb0dQVShvdXRwdXQuZGF0YUlkKTtcbiAgcmV0dXJuIG91dHB1dDtcbn1cbiJdfQ==