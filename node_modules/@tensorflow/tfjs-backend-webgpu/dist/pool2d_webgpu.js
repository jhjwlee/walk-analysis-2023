/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
import { getMainHeaderString as main } from './webgpu_program';
import { computeDispatch, flatDispatchLayout } from './webgpu_util';
export class Pool2DProgram {
    constructor(convInfo, poolType) {
        this.variableNames = ['x'];
        this.uniforms = `stride : vec2<i32>, pad : vec2<i32>, dilation : vec2<i32>, convDims : vec2<i32>, filterDims : vec2<i32>,`;
        // TODO(jiajia.qin@intel.com): Dynamically choose different workgroupSize for
        // different output shapes.
        this.workgroupSize = [128, 1, 1];
        this.size = true;
        this.outputShape = convInfo.outShape;
        this.dispatchLayout = flatDispatchLayout(this.outputShape);
        this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workgroupSize);
        this.shaderKey = `pool2D_${poolType}`;
        this.poolType = poolType;
    }
    getUserCode() {
        let updateSnippet = `resultValue = max(value, resultValue);`;
        if (this.poolType === 'avg') {
            updateSnippet = `resultValue = resultValue + value; count = count + 1.0;`;
        }
        let returnValue = `resultValue`;
        if (this.poolType === 'avg') {
            returnValue = `resultValue / max(count, 1.0)`;
        }
        const userCode = `
      ${main('index')} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
          let batch = coords[0];
          let xRCCorner = vec2<i32>(coords.yz) * uniforms.stride - uniforms.pad;
          let xRCorner = xRCCorner.x;
          let xCCorner = xRCCorner.y;

          var resultValue = ${this.poolType === 'avg' ? '0.0' : '-1.0 / pow(10.0, -20.0)'};
          var count = 0.0;

          for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + uniforms.dilation.x) {
            let xR = xRCorner + wR;

            if (xR < 0 || xR >= uniforms.convDims.x) {
              continue;
            }

            for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + uniforms.dilation.y) {
              let xC = xCCorner + wC;
              if (xC < 0 || xC >= uniforms.convDims.y) {
                continue;
              }

              let value = getX(batch, xR, xC, coords[3]);
              ${updateSnippet}
            }
          }

          setOutputAtIndex(index, ${returnValue});
        }
      }
    `;
        return userCode;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicG9vbDJkX3dlYmdwdS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3RmanMtYmFja2VuZC13ZWJncHUvc3JjL3Bvb2wyZF93ZWJncHUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7OztHQWVHO0FBR0gsT0FBTyxFQUFDLG1CQUFtQixJQUFJLElBQUksRUFBZ0IsTUFBTSxrQkFBa0IsQ0FBQztBQUM1RSxPQUFPLEVBQUMsZUFBZSxFQUFFLGtCQUFrQixFQUFDLE1BQU0sZUFBZSxDQUFDO0FBRWxFLE1BQU0sT0FBTyxhQUFhO0lBY3hCLFlBQVksUUFBaUMsRUFBRSxRQUFxQjtRQVRwRSxrQkFBYSxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDdEIsYUFBUSxHQUNKLDBHQUEwRyxDQUFDO1FBQy9HLDZFQUE2RTtRQUM3RSwyQkFBMkI7UUFDM0Isa0JBQWEsR0FBNkIsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBRXRELFNBQUksR0FBRyxJQUFJLENBQUM7UUFHVixJQUFJLENBQUMsV0FBVyxHQUFHLFFBQVEsQ0FBQyxRQUFRLENBQUM7UUFFckMsSUFBSSxDQUFDLGNBQWMsR0FBRyxrQkFBa0IsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUM7UUFFM0QsSUFBSSxDQUFDLFFBQVEsR0FBRyxlQUFlLENBQzNCLElBQUksQ0FBQyxjQUFjLEVBQUUsSUFBSSxDQUFDLFdBQVcsRUFBRSxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUM7UUFFL0QsSUFBSSxDQUFDLFNBQVMsR0FBRyxVQUFVLFFBQVEsRUFBRSxDQUFDO1FBQ3RDLElBQUksQ0FBQyxRQUFRLEdBQUcsUUFBUSxDQUFDO0lBQzNCLENBQUM7SUFFRCxXQUFXO1FBQ1QsSUFBSSxhQUFhLEdBQUcsd0NBQXdDLENBQUM7UUFDN0QsSUFBSSxJQUFJLENBQUMsUUFBUSxLQUFLLEtBQUssRUFBRTtZQUMzQixhQUFhLEdBQUcseURBQXlELENBQUM7U0FDM0U7UUFFRCxJQUFJLFdBQVcsR0FBRyxhQUFhLENBQUM7UUFDaEMsSUFBSSxJQUFJLENBQUMsUUFBUSxLQUFLLEtBQUssRUFBRTtZQUMzQixXQUFXLEdBQUcsK0JBQStCLENBQUM7U0FDL0M7UUFFRCxNQUFNLFFBQVEsR0FBRztRQUNiLElBQUksQ0FBQyxPQUFPLENBQUM7Ozs7Ozs7OzhCQVNiLElBQUksQ0FBQyxRQUFRLEtBQUssS0FBSyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLHlCQUF5Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Z0JBaUJuRCxhQUFhOzs7O29DQUlPLFdBQVc7OztLQUcxQyxDQUFDO1FBQ0YsT0FBTyxRQUFRLENBQUM7SUFDbEIsQ0FBQztDQUNGIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuXG5pbXBvcnQge2JhY2tlbmRfdXRpbH0gZnJvbSAnQHRlbnNvcmZsb3cvdGZqcy1jb3JlJztcbmltcG9ydCB7Z2V0TWFpbkhlYWRlclN0cmluZyBhcyBtYWluLCBXZWJHUFVQcm9ncmFtfSBmcm9tICcuL3dlYmdwdV9wcm9ncmFtJztcbmltcG9ydCB7Y29tcHV0ZURpc3BhdGNoLCBmbGF0RGlzcGF0Y2hMYXlvdXR9IGZyb20gJy4vd2ViZ3B1X3V0aWwnO1xuXG5leHBvcnQgY2xhc3MgUG9vbDJEUHJvZ3JhbSBpbXBsZW1lbnRzIFdlYkdQVVByb2dyYW0ge1xuICBvdXRwdXRTaGFwZTogbnVtYmVyW107XG4gIHNoYWRlcktleTogc3RyaW5nO1xuICBkaXNwYXRjaExheW91dDoge3g6IG51bWJlcltdfTtcbiAgZGlzcGF0Y2g6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXTtcbiAgdmFyaWFibGVOYW1lcyA9IFsneCddO1xuICB1bmlmb3JtcyA9XG4gICAgICBgc3RyaWRlIDogdmVjMjxpMzI+LCBwYWQgOiB2ZWMyPGkzMj4sIGRpbGF0aW9uIDogdmVjMjxpMzI+LCBjb252RGltcyA6IHZlYzI8aTMyPiwgZmlsdGVyRGltcyA6IHZlYzI8aTMyPixgO1xuICAvLyBUT0RPKGppYWppYS5xaW5AaW50ZWwuY29tKTogRHluYW1pY2FsbHkgY2hvb3NlIGRpZmZlcmVudCB3b3JrZ3JvdXBTaXplIGZvclxuICAvLyBkaWZmZXJlbnQgb3V0cHV0IHNoYXBlcy5cbiAgd29ya2dyb3VwU2l6ZTogW251bWJlciwgbnVtYmVyLCBudW1iZXJdID0gWzEyOCwgMSwgMV07XG4gIHBvb2xUeXBlOiAnbWF4J3wnYXZnJztcbiAgc2l6ZSA9IHRydWU7XG5cbiAgY29uc3RydWN0b3IoY29udkluZm86IGJhY2tlbmRfdXRpbC5Db252MkRJbmZvLCBwb29sVHlwZTogJ21heCd8J2F2ZycpIHtcbiAgICB0aGlzLm91dHB1dFNoYXBlID0gY29udkluZm8ub3V0U2hhcGU7XG5cbiAgICB0aGlzLmRpc3BhdGNoTGF5b3V0ID0gZmxhdERpc3BhdGNoTGF5b3V0KHRoaXMub3V0cHV0U2hhcGUpO1xuXG4gICAgdGhpcy5kaXNwYXRjaCA9IGNvbXB1dGVEaXNwYXRjaChcbiAgICAgICAgdGhpcy5kaXNwYXRjaExheW91dCwgdGhpcy5vdXRwdXRTaGFwZSwgdGhpcy53b3JrZ3JvdXBTaXplKTtcblxuICAgIHRoaXMuc2hhZGVyS2V5ID0gYHBvb2wyRF8ke3Bvb2xUeXBlfWA7XG4gICAgdGhpcy5wb29sVHlwZSA9IHBvb2xUeXBlO1xuICB9XG5cbiAgZ2V0VXNlckNvZGUoKTogc3RyaW5nIHtcbiAgICBsZXQgdXBkYXRlU25pcHBldCA9IGByZXN1bHRWYWx1ZSA9IG1heCh2YWx1ZSwgcmVzdWx0VmFsdWUpO2A7XG4gICAgaWYgKHRoaXMucG9vbFR5cGUgPT09ICdhdmcnKSB7XG4gICAgICB1cGRhdGVTbmlwcGV0ID0gYHJlc3VsdFZhbHVlID0gcmVzdWx0VmFsdWUgKyB2YWx1ZTsgY291bnQgPSBjb3VudCArIDEuMDtgO1xuICAgIH1cblxuICAgIGxldCByZXR1cm5WYWx1ZSA9IGByZXN1bHRWYWx1ZWA7XG4gICAgaWYgKHRoaXMucG9vbFR5cGUgPT09ICdhdmcnKSB7XG4gICAgICByZXR1cm5WYWx1ZSA9IGByZXN1bHRWYWx1ZSAvIG1heChjb3VudCwgMS4wKWA7XG4gICAgfVxuXG4gICAgY29uc3QgdXNlckNvZGUgPSBgXG4gICAgICAke21haW4oJ2luZGV4Jyl9IHtcbiAgICAgIGlmIChpbmRleCA8IHVuaWZvcm1zLnNpemUpIHtcbiAgICAgICAgbGV0IGNvb3JkcyA9IGdldENvb3Jkc0Zyb21JbmRleChpbmRleCk7XG4gICAgICAgICAgbGV0IGJhdGNoID0gY29vcmRzWzBdO1xuICAgICAgICAgIGxldCB4UkNDb3JuZXIgPSB2ZWMyPGkzMj4oY29vcmRzLnl6KSAqIHVuaWZvcm1zLnN0cmlkZSAtIHVuaWZvcm1zLnBhZDtcbiAgICAgICAgICBsZXQgeFJDb3JuZXIgPSB4UkNDb3JuZXIueDtcbiAgICAgICAgICBsZXQgeENDb3JuZXIgPSB4UkNDb3JuZXIueTtcblxuICAgICAgICAgIHZhciByZXN1bHRWYWx1ZSA9ICR7XG4gICAgICAgIHRoaXMucG9vbFR5cGUgPT09ICdhdmcnID8gJzAuMCcgOiAnLTEuMCAvIHBvdygxMC4wLCAtMjAuMCknfTtcbiAgICAgICAgICB2YXIgY291bnQgPSAwLjA7XG5cbiAgICAgICAgICBmb3IgKHZhciB3UiA9IDA7IHdSIDwgdW5pZm9ybXMuZmlsdGVyRGltcy54OyB3UiA9IHdSICsgdW5pZm9ybXMuZGlsYXRpb24ueCkge1xuICAgICAgICAgICAgbGV0IHhSID0geFJDb3JuZXIgKyB3UjtcblxuICAgICAgICAgICAgaWYgKHhSIDwgMCB8fCB4UiA+PSB1bmlmb3Jtcy5jb252RGltcy54KSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHZhciB3QyA9IDA7IHdDIDwgdW5pZm9ybXMuZmlsdGVyRGltcy55OyB3QyA9IHdDICsgdW5pZm9ybXMuZGlsYXRpb24ueSkge1xuICAgICAgICAgICAgICBsZXQgeEMgPSB4Q0Nvcm5lciArIHdDO1xuICAgICAgICAgICAgICBpZiAoeEMgPCAwIHx8IHhDID49IHVuaWZvcm1zLmNvbnZEaW1zLnkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGxldCB2YWx1ZSA9IGdldFgoYmF0Y2gsIHhSLCB4QywgY29vcmRzWzNdKTtcbiAgICAgICAgICAgICAgJHt1cGRhdGVTbmlwcGV0fVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHNldE91dHB1dEF0SW5kZXgoaW5kZXgsICR7cmV0dXJuVmFsdWV9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIGA7XG4gICAgcmV0dXJuIHVzZXJDb2RlO1xuICB9XG59XG4iXX0=