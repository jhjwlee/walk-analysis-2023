/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
export var BinaryOpType;
(function (BinaryOpType) {
    BinaryOpType[BinaryOpType["ADD"] = 0] = "ADD";
    BinaryOpType[BinaryOpType["ATAN2"] = 1] = "ATAN2";
    BinaryOpType[BinaryOpType["COMPLEX_MULTIPLY_IMAG"] = 2] = "COMPLEX_MULTIPLY_IMAG";
    BinaryOpType[BinaryOpType["COMPLEX_MULTIPLY_REAL"] = 3] = "COMPLEX_MULTIPLY_REAL";
    BinaryOpType[BinaryOpType["DIV"] = 4] = "DIV";
    BinaryOpType[BinaryOpType["EQUAL"] = 5] = "EQUAL";
    BinaryOpType[BinaryOpType["GREATER"] = 6] = "GREATER";
    BinaryOpType[BinaryOpType["GREATER_EQUAL"] = 7] = "GREATER_EQUAL";
    BinaryOpType[BinaryOpType["INT_DIV"] = 8] = "INT_DIV";
    BinaryOpType[BinaryOpType["LESS"] = 9] = "LESS";
    BinaryOpType[BinaryOpType["LESS_EQUAL"] = 10] = "LESS_EQUAL";
    BinaryOpType[BinaryOpType["LOGICAL_AND"] = 11] = "LOGICAL_AND";
    BinaryOpType[BinaryOpType["LOGICAL_OR"] = 12] = "LOGICAL_OR";
    BinaryOpType[BinaryOpType["MAX"] = 13] = "MAX";
    BinaryOpType[BinaryOpType["MIN"] = 14] = "MIN";
    BinaryOpType[BinaryOpType["MOD"] = 15] = "MOD";
    BinaryOpType[BinaryOpType["MUL"] = 16] = "MUL";
    BinaryOpType[BinaryOpType["NOT_EQUAL"] = 17] = "NOT_EQUAL";
    BinaryOpType[BinaryOpType["POW"] = 18] = "POW";
    BinaryOpType[BinaryOpType["PRELU"] = 19] = "PRELU";
    BinaryOpType[BinaryOpType["SQUARED_DIFFERENCE"] = 20] = "SQUARED_DIFFERENCE";
    BinaryOpType[BinaryOpType["SUB"] = 21] = "SUB";
})(BinaryOpType || (BinaryOpType = {}));
const CHECK_NAN_SNIPPET = `
  if (isnan(a)) { return a; }
  if (isnan(b)) { return b; }
  `;
const CHECK_NAN_SNIPPET_VEC4 = `
  resultTemp = select(
      resultTemp, vec4<f32>(valueForNaN),
      vec4<bool>(isNaN) | isnanVec4(a) | isnanVec4(b));
  `;
const ADD = 'return a + b;';
// (Ar + Ai)(Br + Bi) =
// ArBr + ArBi + AiBr + AiBi = ArBr - AB + ArBi + AiBr
// Yr = ArBr - AB
// Yi = ArBi + AiBr
const COMPLEX_MULTIPLY_REAL = 'return areal * breal - aimag * bimag;';
const COMPLEX_MULTIPLY_IMAG = 'return areal * bimag + aimag * breal;';
const DIV = 'return a / b;';
const EQUAL = 'return f32(a == b);';
const EQUAL_VEC4 = 'return vec4<f32>(a == b);';
const GREATER = 'return f32(a > b);';
const GREATER_VEC4 = 'return vec4<f32>(a > b);';
const GREATER_EQUAL = 'return f32(a >= b);';
const GREATER_EQUAL_VEC4 = 'return vec4<f32>(a >= b);';
const INT_DIV = `
  let s = sign(a) * sign(b);
  let ia = i32(round(a));
  let ib = i32(round(b));
  return f32(idiv(ia, ib, s));
`;
const INT_DIV_VEC4 = `
  let ia = vec4<i32>(round(a));
  let ib = vec4<i32>(round(b));
  let cond = ib != vec4<i32>(0);
  var resultTemp = vec4<i32>(0);
  let s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    resultTemp[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    resultTemp[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    resultTemp[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    resultTemp[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4<f32>(resultTemp);
`;
const LESS = 'return f32(a < b);';
const LESS_VEC4 = 'return vec4<f32>(a < b);';
const LESS_EQUAL = 'return f32(a <= b);';
const LESS_EQUAL_VEC4 = 'return vec4<f32>(a <= b);';
const LOGICAL_AND = 'return f32(a >= 1.0 && b >= 1.0);';
const LOGICAL_AND_VEC4 = `return (vec4<f32>(a >= vec4<f32>(1.0)) *
  vec4<f32>(b >= vec4<f32>(1.0)));`;
const LOGICAL_OR = 'return f32(a >= 1.0 || b >= 1.0);';
const LOGICAL_OR_VEC4 = `return min(vec4<f32>(a >= vec4<f32>(1.0)) +
  vec4<f32>(b >= vec4<f32>(1.0)), vec4<f32>(1.0));`;
const MOD = `
  ${CHECK_NAN_SNIPPET}
  if (b == 0.) {
    return uniforms.NAN;
  }
  var resultTemp = a % b;
  if ((a < 0. && b < 0.) || (a >= 0. && b > 0.)) {
    return resultTemp;
  } else {
    return (resultTemp + b) % b;
  }
`;
const MOD_VEC4 = `
  let isNaN = !vec4<bool>(b);
  let valueForNaN = uniforms.NAN;
  var resultTemp = vec4<f32>(a % b);
  ${CHECK_NAN_SNIPPET_VEC4}

  if (!((a[0] < 0. && b[0] < 0.) || (a[0] >= 0. && b[0] > 0.))) {
    resultTemp[0] = (resultTemp[0] + b[0]) % b[0];
  }
  if (!((a[1] < 0. && b[1] < 0.) || (a[1] >= 0. && b[1] > 0.))) {
    resultTemp[1] = (resultTemp[1] + b[1]) % b[1];
  }
  if (!((a[2] < 0. && b[2] < 0.) || (a[2] >= 0. && b[2] > 0.))) {
    resultTemp[2] = (resultTemp[2] + b[2]) % b[2];
  }
  if (!((a[3] < 0. && b[3] < 0.) || (a[3] >= 0. && b[3] > 0.))) {
    resultTemp[3] = (resultTemp[3] + b[3]) % b[3];
  }

  return resultTemp;
`;
const MUL = 'return a * b;';
const NOT_EQUAL = `
  if (isnan(a) || isnan(b)) {
    return 1.0;
  }
  return f32(a != b);
`;
const NOT_EQUAL_VEC4 = `
  var resultTemp = vec4<f32>(a != b);
  let valueForNaN = 1.0;
  ${CHECK_NAN_SNIPPET_VEC4}

  return resultTemp;
`;
const POW = `
  if(a < 0.0 && floor(b) < b) {
    return uniforms.NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  if (round(abs(b) % 2.0) != 1.0) {
    return pow(abs(a), b);
  }
  return sign(a) * pow(abs(a), b);
`;
const POW_VEC4 = `
  let isModRound1Bool = vec4<i32>(round(abs(b) % vec4<f32>(2.0))) == vec4<i32>(1);
  let isModRound1 = vec4<f32>(isModRound1Bool);
  let multiplier = sign(a) * isModRound1 + (vec4<f32>(1.0) - isModRound1);
  var resultTemp = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  let isExpZero = b == vec4<f32>(0.0);
  if (isExpZero.r) {
    resultTemp.r = 1.0;
  }
  if (isExpZero.g) {
    resultTemp.g = 1.0;
  }
  if (isExpZero.b) {
    resultTemp.b = 1.0;
  }
  if (isExpZero.a) {
    resultTemp.a = 1.0;
  }
  let isNaN = (a < vec4<f32>(0.0)) & (floor(b) < b);
  let valueForNaN = uniforms.NAN;
  ${CHECK_NAN_SNIPPET_VEC4}
  return resultTemp;
`;
const PRELU = `if (a < 0.0) { return b * a; }  return a;`;
const PRELU_VEC4 = `
  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));
  return (aLessThanZero * (b * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);
`;
const SQUARED_DIFFERENCE = 'return (a - b) * (a - b);';
const SUB = 'return a - b;';
function getBinaryWithNanString(op, useVec4, valueForNaN = 'uniforms.NAN') {
    const checkNanSnippet = useVec4 ? CHECK_NAN_SNIPPET_VEC4 : CHECK_NAN_SNIPPET;
    return useVec4 ? `
    let valueForNaN = ${valueForNaN};
    var resultTemp = vec4<f32>(${op}(a, b));
    ` + checkNanSnippet +
        `
    return resultTemp;
  ` :
        checkNanSnippet + `
    return ${op}(a, b);
  `;
}
export function getBinaryOpString(type, useVec4) {
    switch (type) {
        case BinaryOpType.ADD:
            return ADD;
        case BinaryOpType.ATAN2:
            return getBinaryWithNanString('atan2', useVec4);
        case BinaryOpType.COMPLEX_MULTIPLY_IMAG:
            return COMPLEX_MULTIPLY_IMAG;
        case BinaryOpType.COMPLEX_MULTIPLY_REAL:
            return COMPLEX_MULTIPLY_REAL;
        case BinaryOpType.DIV:
            return DIV;
        case BinaryOpType.EQUAL:
            return useVec4 ? EQUAL_VEC4 : EQUAL;
        case BinaryOpType.GREATER:
            return useVec4 ? GREATER_VEC4 : GREATER;
        case BinaryOpType.GREATER_EQUAL:
            return useVec4 ? GREATER_EQUAL_VEC4 : GREATER_EQUAL;
        case BinaryOpType.INT_DIV:
            return useVec4 ? INT_DIV_VEC4 : INT_DIV;
        case BinaryOpType.LESS:
            return useVec4 ? LESS_VEC4 : LESS;
        case BinaryOpType.LESS_EQUAL:
            return useVec4 ? LESS_EQUAL_VEC4 : LESS_EQUAL;
        case BinaryOpType.LOGICAL_AND:
            return useVec4 ? LOGICAL_AND_VEC4 : LOGICAL_AND;
        case BinaryOpType.LOGICAL_OR:
            return useVec4 ? LOGICAL_OR_VEC4 : LOGICAL_OR;
        case BinaryOpType.MAX:
            return getBinaryWithNanString('max', useVec4);
        case BinaryOpType.MIN:
            return getBinaryWithNanString('min', useVec4);
        case BinaryOpType.MOD:
            return useVec4 ? MOD_VEC4 : MOD;
        case BinaryOpType.MUL:
            return MUL;
        case BinaryOpType.NOT_EQUAL:
            return useVec4 ? NOT_EQUAL_VEC4 : NOT_EQUAL;
        case BinaryOpType.POW:
            return useVec4 ? POW_VEC4 : POW;
        case BinaryOpType.PRELU:
            return useVec4 ? PRELU_VEC4 : PRELU;
        case BinaryOpType.SQUARED_DIFFERENCE:
            return SQUARED_DIFFERENCE;
        case BinaryOpType.SUB:
            return SUB;
        default:
            throw new Error(`BinaryType ${type} is not implemented!`);
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmluYXJ5X29wX3V0aWwuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi90ZmpzLWJhY2tlbmQtd2ViZ3B1L3NyYy9iaW5hcnlfb3BfdXRpbC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7O0dBZUc7QUFFSCxNQUFNLENBQU4sSUFBWSxZQXVCWDtBQXZCRCxXQUFZLFlBQVk7SUFDdEIsNkNBQUcsQ0FBQTtJQUNILGlEQUFLLENBQUE7SUFDTCxpRkFBcUIsQ0FBQTtJQUNyQixpRkFBcUIsQ0FBQTtJQUNyQiw2Q0FBRyxDQUFBO0lBQ0gsaURBQUssQ0FBQTtJQUNMLHFEQUFPLENBQUE7SUFDUCxpRUFBYSxDQUFBO0lBQ2IscURBQU8sQ0FBQTtJQUNQLCtDQUFJLENBQUE7SUFDSiw0REFBVSxDQUFBO0lBQ1YsOERBQVcsQ0FBQTtJQUNYLDREQUFVLENBQUE7SUFDViw4Q0FBRyxDQUFBO0lBQ0gsOENBQUcsQ0FBQTtJQUNILDhDQUFHLENBQUE7SUFDSCw4Q0FBRyxDQUFBO0lBQ0gsMERBQVMsQ0FBQTtJQUNULDhDQUFHLENBQUE7SUFDSCxrREFBSyxDQUFBO0lBQ0wsNEVBQWtCLENBQUE7SUFDbEIsOENBQUcsQ0FBQTtBQUNMLENBQUMsRUF2QlcsWUFBWSxLQUFaLFlBQVksUUF1QnZCO0FBRUQsTUFBTSxpQkFBaUIsR0FBRzs7O0dBR3ZCLENBQUM7QUFFSixNQUFNLHNCQUFzQixHQUFHOzs7O0dBSTVCLENBQUM7QUFFSixNQUFNLEdBQUcsR0FBRyxlQUFlLENBQUM7QUFDNUIsdUJBQXVCO0FBQ3ZCLHNEQUFzRDtBQUN0RCxpQkFBaUI7QUFDakIsbUJBQW1CO0FBQ25CLE1BQU0scUJBQXFCLEdBQUcsdUNBQXVDLENBQUM7QUFDdEUsTUFBTSxxQkFBcUIsR0FBRyx1Q0FBdUMsQ0FBQztBQUN0RSxNQUFNLEdBQUcsR0FBRyxlQUFlLENBQUM7QUFDNUIsTUFBTSxLQUFLLEdBQUcscUJBQXFCLENBQUM7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QUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDO1FBQ2xDLEtBQUssWUFBWSxDQUFDLEtBQUs7WUFDckIsT0FBTyxPQUFPLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDO1FBQ3RDLEtBQUssWUFBWSxDQUFDLGtCQUFrQjtZQUNsQyxPQUFPLGtCQUFrQixDQUFDO1FBQzVCLEtBQUssWUFBWSxDQUFDLEdBQUc7WUFDbkIsT0FBTyxHQUFHLENBQUM7UUFDYjtZQUNFLE1BQU0sSUFBSSxLQUFLLENBQUMsY0FBYyxJQUFJLHNCQUFzQixDQUFDLENBQUM7S0FDN0Q7QUFDSCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuXG5leHBvcnQgZW51bSBCaW5hcnlPcFR5cGUge1xuICBBREQsXG4gIEFUQU4yLFxuICBDT01QTEVYX01VTFRJUExZX0lNQUcsXG4gIENPTVBMRVhfTVVMVElQTFlfUkVBTCxcbiAgRElWLFxuICBFUVVBTCxcbiAgR1JFQVRFUixcbiAgR1JFQVRFUl9FUVVBTCxcbiAgSU5UX0RJVixcbiAgTEVTUyxcbiAgTEVTU19FUVVBTCxcbiAgTE9HSUNBTF9BTkQsXG4gIExPR0lDQUxfT1IsXG4gIE1BWCxcbiAgTUlOLFxuICBNT0QsXG4gIE1VTCxcbiAgTk9UX0VRVUFMLFxuICBQT1csXG4gIFBSRUxVLFxuICBTUVVBUkVEX0RJRkZFUkVOQ0UsXG4gIFNVQlxufVxuXG5jb25zdCBDSEVDS19OQU5fU05JUFBFVCA9IGBcbiAgaWYgKGlzbmFuKGEpKSB7IHJldHVybiBhOyB9XG4gIGlmIChpc25hbihiKSkgeyByZXR1cm4gYjsgfVxuICBgO1xuXG5jb25zdCBDSEVDS19OQU5fU05JUFBFVF9WRUM0ID0gYFxuICByZXN1bHRUZW1wID0gc2VsZWN0KFxuICAgICAgcmVzdWx0VGVtcCwgdmVjNDxmMzI+KHZhbHVlRm9yTmFOKSxcbiAgICAgIHZlYzQ8Ym9vbD4oaXNOYU4pIHwgaXNuYW5WZWM0KGEpIHwgaXNuYW5WZWM0KGIpKTtcbiAgYDtcblxuY29uc3QgQUREID0gJ3JldHVybiBhICsgYjsnO1xuLy8gKEFyICsgQWkpKEJyICsgQmkpID1cbi8vIEFyQnIgKyBBckJpICsgQWlCciArIEFpQmkgPSBBckJyIC0gQUIgKyBBckJpICsgQWlCclxuLy8gWXIgPSBBckJyIC0gQUJcbi8vIFlpID0gQXJCaSArIEFpQnJcbmNvbnN0IENPTVBMRVhfTVVMVElQTFlfUkVBTCA9ICdyZXR1cm4gYXJlYWwgKiBicmVhbCAtIGFpbWFnICogYmltYWc7JztcbmNvbnN0IENPTVBMRVhfTVVMVElQTFlfSU1BRyA9ICdyZXR1cm4gYXJlYWwgKiBiaW1hZyArIGFpbWFnICogYnJlYWw7JztcbmNvbnN0IERJViA9ICdyZXR1cm4gYSAvIGI7JztcbmNvbnN0IEVRVUFMID0gJ3JldHVybiBmMzIoYSA9PSBiKTsnO1xuY29uc3QgRVFVQUxfVkVDNCA9ICdyZXR1cm4gdmVjNDxmMzI+KGEgPT0gYik7JztcbmNvbnN0IEdSRUFURVIgPSAncmV0dXJuIGYzMihhID4gYik7JztcbmNvbnN0IEdSRUFURVJfVkVDNCA9ICdyZXR1cm4gdmVjNDxmMzI+KGEgPiBiKTsnO1xuY29uc3QgR1JFQVRFUl9FUVVBTCA9ICdyZXR1cm4gZjMyKGEgPj0gYik7JztcbmNvbnN0IEdSRUFURVJfRVFVQUxfVkVDNCA9ICdyZXR1cm4gdmVjNDxmMzI+KGEgPj0gYik7JztcblxuY29uc3QgSU5UX0RJViA9IGBcbiAgbGV0IHMgPSBzaWduKGEpICogc2lnbihiKTtcbiAgbGV0IGlhID0gaTMyKHJvdW5kKGEpKTtcbiAgbGV0IGliID0gaTMyKHJvdW5kKGIpKTtcbiAgcmV0dXJuIGYzMihpZGl2KGlhLCBpYiwgcykpO1xuYDtcbmNvbnN0IElOVF9ESVZfVkVDNCA9IGBcbiAgbGV0IGlhID0gdmVjNDxpMzI+KHJvdW5kKGEpKTtcbiAgbGV0IGliID0gdmVjNDxpMzI+KHJvdW5kKGIpKTtcbiAgbGV0IGNvbmQgPSBpYiAhPSB2ZWM0PGkzMj4oMCk7XG4gIHZhciByZXN1bHRUZW1wID0gdmVjNDxpMzI+KDApO1xuICBsZXQgcyA9IHNpZ24oYSkgKiBzaWduKGIpO1xuXG4gIC8vIFdpbmRvd3MgKEQzRCkgd2FudHMgZ3VhcmFudGVlZCBub24temVybyBpbnQgZGl2aXNpb24gYXQgY29tcGlsZS10aW1lLlxuICBpZiAoY29uZFswXSkge1xuICAgIHJlc3VsdFRlbXBbMF0gPSBpZGl2KGlhWzBdLCBpYlswXSwgc1swXSk7XG4gIH1cbiAgaWYgKGNvbmRbMV0pIHtcbiAgICByZXN1bHRUZW1wWzFdID0gaWRpdihpYVsxXSwgaWJbMV0sIHNbMV0pO1xuICB9XG4gIGlmIChjb25kWzJdKSB7XG4gICAgcmVzdWx0VGVtcFsyXSA9IGlkaXYoaWFbMl0sIGliWzJdLCBzWzJdKTtcbiAgfVxuICBpZiAoY29uZFszXSkge1xuICAgIHJlc3VsdFRlbXBbM10gPSBpZGl2KGlhWzNdLCBpYlszXSwgc1szXSk7XG4gIH1cbiAgcmV0dXJuIHZlYzQ8ZjMyPihyZXN1bHRUZW1wKTtcbmA7XG5cbmNvbnN0IExFU1MgPSAncmV0dXJuIGYzMihhIDwgYik7JztcbmNvbnN0IExFU1NfVkVDNCA9ICdyZXR1cm4gdmVjNDxmMzI+KGEgPCBiKTsnO1xuY29uc3QgTEVTU19FUVVBTCA9ICdyZXR1cm4gZjMyKGEgPD0gYik7JztcbmNvbnN0IExFU1NfRVFVQUxfVkVDNCA9ICdyZXR1cm4gdmVjNDxmMzI+KGEgPD0gYik7JztcbmNvbnN0IExPR0lDQUxfQU5EID0gJ3JldHVybiBmMzIoYSA+PSAxLjAgJiYgYiA+PSAxLjApOyc7XG5jb25zdCBMT0dJQ0FMX0FORF9WRUM0ID0gYHJldHVybiAodmVjNDxmMzI+KGEgPj0gdmVjNDxmMzI+KDEuMCkpICpcbiAgdmVjNDxmMzI+KGIgPj0gdmVjNDxmMzI+KDEuMCkpKTtgO1xuY29uc3QgTE9HSUNBTF9PUiA9ICdyZXR1cm4gZjMyKGEgPj0gMS4wIHx8IGIgPj0gMS4wKTsnO1xuY29uc3QgTE9HSUNBTF9PUl9WRUM0ID0gYHJldHVybiBtaW4odmVjNDxmMzI+KGEgPj0gdmVjNDxmMzI+KDEuMCkpICtcbiAgdmVjNDxmMzI+KGIgPj0gdmVjNDxmMzI+KDEuMCkpLCB2ZWM0PGYzMj4oMS4wKSk7YDtcbmNvbnN0IE1PRCA9IGBcbiAgJHtDSEVDS19OQU5fU05JUFBFVH1cbiAgaWYgKGIgPT0gMC4pIHtcbiAgICByZXR1cm4gdW5pZm9ybXMuTkFOO1xuICB9XG4gIHZhciByZXN1bHRUZW1wID0gYSAlIGI7XG4gIGlmICgoYSA8IDAuICYmIGIgPCAwLikgfHwgKGEgPj0gMC4gJiYgYiA+IDAuKSkge1xuICAgIHJldHVybiByZXN1bHRUZW1wO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAocmVzdWx0VGVtcCArIGIpICUgYjtcbiAgfVxuYDtcbmNvbnN0IE1PRF9WRUM0ID0gYFxuICBsZXQgaXNOYU4gPSAhdmVjNDxib29sPihiKTtcbiAgbGV0IHZhbHVlRm9yTmFOID0gdW5pZm9ybXMuTkFOO1xuICB2YXIgcmVzdWx0VGVtcCA9IHZlYzQ8ZjMyPihhICUgYik7XG4gICR7Q0hFQ0tfTkFOX1NOSVBQRVRfVkVDNH1cblxuICBpZiAoISgoYVswXSA8IDAuICYmIGJbMF0gPCAwLikgfHwgKGFbMF0gPj0gMC4gJiYgYlswXSA+IDAuKSkpIHtcbiAgICByZXN1bHRUZW1wWzBdID0gKHJlc3VsdFRlbXBbMF0gKyBiWzBdKSAlIGJbMF07XG4gIH1cbiAgaWYgKCEoKGFbMV0gPCAwLiAmJiBiWzFdIDwgMC4pIHx8IChhWzFdID49IDAuICYmIGJbMV0gPiAwLikpKSB7XG4gICAgcmVzdWx0VGVtcFsxXSA9IChyZXN1bHRUZW1wWzFdICsgYlsxXSkgJSBiWzFdO1xuICB9XG4gIGlmICghKChhWzJdIDwgMC4gJiYgYlsyXSA8IDAuKSB8fCAoYVsyXSA+PSAwLiAmJiBiWzJdID4gMC4pKSkge1xuICAgIHJlc3VsdFRlbXBbMl0gPSAocmVzdWx0VGVtcFsyXSArIGJbMl0pICUgYlsyXTtcbiAgfVxuICBpZiAoISgoYVszXSA8IDAuICYmIGJbM10gPCAwLikgfHwgKGFbM10gPj0gMC4gJiYgYlszXSA+IDAuKSkpIHtcbiAgICByZXN1bHRUZW1wWzNdID0gKHJlc3VsdFRlbXBbM10gKyBiWzNdKSAlIGJbM107XG4gIH1cblxuICByZXR1cm4gcmVzdWx0VGVtcDtcbmA7XG5jb25zdCBNVUwgPSAncmV0dXJuIGEgKiBiOyc7XG5jb25zdCBOT1RfRVFVQUwgPSBgXG4gIGlmIChpc25hbihhKSB8fCBpc25hbihiKSkge1xuICAgIHJldHVybiAxLjA7XG4gIH1cbiAgcmV0dXJuIGYzMihhICE9IGIpO1xuYDtcbmNvbnN0IE5PVF9FUVVBTF9WRUM0ID0gYFxuICB2YXIgcmVzdWx0VGVtcCA9IHZlYzQ8ZjMyPihhICE9IGIpO1xuICBsZXQgdmFsdWVGb3JOYU4gPSAxLjA7XG4gICR7Q0hFQ0tfTkFOX1NOSVBQRVRfVkVDNH1cblxuICByZXR1cm4gcmVzdWx0VGVtcDtcbmA7XG5cbmNvbnN0IFBPVyA9IGBcbiAgaWYoYSA8IDAuMCAmJiBmbG9vcihiKSA8IGIpIHtcbiAgICByZXR1cm4gdW5pZm9ybXMuTkFOO1xuICB9XG4gIGlmIChiID09IDAuMCkge1xuICAgIHJldHVybiAxLjA7XG4gIH1cbiAgaWYgKHJvdW5kKGFicyhiKSAlIDIuMCkgIT0gMS4wKSB7XG4gICAgcmV0dXJuIHBvdyhhYnMoYSksIGIpO1xuICB9XG4gIHJldHVybiBzaWduKGEpICogcG93KGFicyhhKSwgYik7XG5gO1xuY29uc3QgUE9XX1ZFQzQgPSBgXG4gIGxldCBpc01vZFJvdW5kMUJvb2wgPSB2ZWM0PGkzMj4ocm91bmQoYWJzKGIpICUgdmVjNDxmMzI+KDIuMCkpKSA9PSB2ZWM0PGkzMj4oMSk7XG4gIGxldCBpc01vZFJvdW5kMSA9IHZlYzQ8ZjMyPihpc01vZFJvdW5kMUJvb2wpO1xuICBsZXQgbXVsdGlwbGllciA9IHNpZ24oYSkgKiBpc01vZFJvdW5kMSArICh2ZWM0PGYzMj4oMS4wKSAtIGlzTW9kUm91bmQxKTtcbiAgdmFyIHJlc3VsdFRlbXAgPSBtdWx0aXBsaWVyICogcG93KGFicyhhKSwgYik7XG5cbiAgLy8gRW5zdXJlIHRoYXQgYV4wID0gMSwgaW5jbHVkaW5nIDBeMCA9IDEgYXMgdGhpcyBjb3JyZXNwb25kIHRvIFRGIGFuZCBKU1xuICBsZXQgaXNFeHBaZXJvID0gYiA9PSB2ZWM0PGYzMj4oMC4wKTtcbiAgaWYgKGlzRXhwWmVyby5yKSB7XG4gICAgcmVzdWx0VGVtcC5yID0gMS4wO1xuICB9XG4gIGlmIChpc0V4cFplcm8uZykge1xuICAgIHJlc3VsdFRlbXAuZyA9IDEuMDtcbiAgfVxuICBpZiAoaXNFeHBaZXJvLmIpIHtcbiAgICByZXN1bHRUZW1wLmIgPSAxLjA7XG4gIH1cbiAgaWYgKGlzRXhwWmVyby5hKSB7XG4gICAgcmVzdWx0VGVtcC5hID0gMS4wO1xuICB9XG4gIGxldCBpc05hTiA9IChhIDwgdmVjNDxmMzI+KDAuMCkpICYgKGZsb29yKGIpIDwgYik7XG4gIGxldCB2YWx1ZUZvck5hTiA9IHVuaWZvcm1zLk5BTjtcbiAgJHtDSEVDS19OQU5fU05JUFBFVF9WRUM0fVxuICByZXR1cm4gcmVzdWx0VGVtcDtcbmA7XG5cbmNvbnN0IFBSRUxVID0gYGlmIChhIDwgMC4wKSB7IHJldHVybiBiICogYTsgfSAgcmV0dXJuIGE7YDtcbmNvbnN0IFBSRUxVX1ZFQzQgPSBgXG4gIGxldCBhTGVzc1RoYW5aZXJvID0gdmVjNDxmMzI+KGEgPCB2ZWM0PGYzMj4oMC4wKSk7XG4gIHJldHVybiAoYUxlc3NUaGFuWmVybyAqIChiICogYSkpICsgKCh2ZWM0PGYzMj4oMS4wKSAtIGFMZXNzVGhhblplcm8pICogYSk7XG5gO1xuY29uc3QgU1FVQVJFRF9ESUZGRVJFTkNFID0gJ3JldHVybiAoYSAtIGIpICogKGEgLSBiKTsnO1xuY29uc3QgU1VCID0gJ3JldHVybiBhIC0gYjsnO1xuXG5mdW5jdGlvbiBnZXRCaW5hcnlXaXRoTmFuU3RyaW5nKFxuICAgIG9wOiBzdHJpbmcsIHVzZVZlYzQ6IGJvb2xlYW4sIHZhbHVlRm9yTmFOID0gJ3VuaWZvcm1zLk5BTicpIHtcbiAgY29uc3QgY2hlY2tOYW5TbmlwcGV0ID0gdXNlVmVjNCA/IENIRUNLX05BTl9TTklQUEVUX1ZFQzQgOiBDSEVDS19OQU5fU05JUFBFVDtcbiAgcmV0dXJuIHVzZVZlYzQgPyBgXG4gICAgbGV0IHZhbHVlRm9yTmFOID0gJHt2YWx1ZUZvck5hTn07XG4gICAgdmFyIHJlc3VsdFRlbXAgPSB2ZWM0PGYzMj4oJHtvcH0oYSwgYikpO1xuICAgIGAgKyBjaGVja05hblNuaXBwZXQgK1xuICAgICAgICAgIGBcbiAgICByZXR1cm4gcmVzdWx0VGVtcDtcbiAgYCA6XG4gICAgICAgICAgICAgICAgICAgY2hlY2tOYW5TbmlwcGV0ICsgYFxuICAgIHJldHVybiAke29wfShhLCBiKTtcbiAgYDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEJpbmFyeU9wU3RyaW5nKFxuICAgIHR5cGU6IEJpbmFyeU9wVHlwZSwgdXNlVmVjND86IGJvb2xlYW4pOiBzdHJpbmcge1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIEJpbmFyeU9wVHlwZS5BREQ6XG4gICAgICByZXR1cm4gQUREO1xuICAgIGNhc2UgQmluYXJ5T3BUeXBlLkFUQU4yOlxuICAgICAgcmV0dXJuIGdldEJpbmFyeVdpdGhOYW5TdHJpbmcoJ2F0YW4yJywgdXNlVmVjNCk7XG4gICAgY2FzZSBCaW5hcnlPcFR5cGUuQ09NUExFWF9NVUxUSVBMWV9JTUFHOlxuICAgICAgcmV0dXJuIENPTVBMRVhfTVVMVElQTFlfSU1BRztcbiAgICBjYXNlIEJpbmFyeU9wVHlwZS5DT01QTEVYX01VTFRJUExZX1JFQUw6XG4gICAgICByZXR1cm4gQ09NUExFWF9NVUxUSVBMWV9SRUFMO1xuICAgIGNhc2UgQmluYXJ5T3BUeXBlLkRJVjpcbiAgICAgIHJldHVybiBESVY7XG4gICAgY2FzZSBCaW5hcnlPcFR5cGUuRVFVQUw6XG4gICAgICByZXR1cm4gdXNlVmVjNCA/IEVRVUFMX1ZFQzQgOiBFUVVBTDtcbiAgICBjYXNlIEJpbmFyeU9wVHlwZS5HUkVBVEVSOlxuICAgICAgcmV0dXJuIHVzZVZlYzQgPyBHUkVBVEVSX1ZFQzQgOiBHUkVBVEVSO1xuICAgIGNhc2UgQmluYXJ5T3BUeXBlLkdSRUFURVJfRVFVQUw6XG4gICAgICByZXR1cm4gdXNlVmVjNCA/IEdSRUFURVJfRVFVQUxfVkVDNCA6IEdSRUFURVJfRVFVQUw7XG4gICAgY2FzZSBCaW5hcnlPcFR5cGUuSU5UX0RJVjpcbiAgICAgIHJldHVybiB1c2VWZWM0ID8gSU5UX0RJVl9WRUM0IDogSU5UX0RJVjtcbiAgICBjYXNlIEJpbmFyeU9wVHlwZS5MRVNTOlxuICAgICAgcmV0dXJuIHVzZVZlYzQgPyBMRVNTX1ZFQzQgOiBMRVNTO1xuICAgIGNhc2UgQmluYXJ5T3BUeXBlLkxFU1NfRVFVQUw6XG4gICAgICByZXR1cm4gdXNlVmVjNCA/IExFU1NfRVFVQUxfVkVDNCA6IExFU1NfRVFVQUw7XG4gICAgY2FzZSBCaW5hcnlPcFR5cGUuTE9HSUNBTF9BTkQ6XG4gICAgICByZXR1cm4gdXNlVmVjNCA/IExPR0lDQUxfQU5EX1ZFQzQgOiBMT0dJQ0FMX0FORDtcbiAgICBjYXNlIEJpbmFyeU9wVHlwZS5MT0dJQ0FMX09SOlxuICAgICAgcmV0dXJuIHVzZVZlYzQgPyBMT0dJQ0FMX09SX1ZFQzQgOiBMT0dJQ0FMX09SO1xuICAgIGNhc2UgQmluYXJ5T3BUeXBlLk1BWDpcbiAgICAgIHJldHVybiBnZXRCaW5hcnlXaXRoTmFuU3RyaW5nKCdtYXgnLCB1c2VWZWM0KTtcbiAgICBjYXNlIEJpbmFyeU9wVHlwZS5NSU46XG4gICAgICByZXR1cm4gZ2V0QmluYXJ5V2l0aE5hblN0cmluZygnbWluJywgdXNlVmVjNCk7XG4gICAgY2FzZSBCaW5hcnlPcFR5cGUuTU9EOlxuICAgICAgcmV0dXJuIHVzZVZlYzQgPyBNT0RfVkVDNCA6IE1PRDtcbiAgICBjYXNlIEJpbmFyeU9wVHlwZS5NVUw6XG4gICAgICByZXR1cm4gTVVMO1xuICAgIGNhc2UgQmluYXJ5T3BUeXBlLk5PVF9FUVVBTDpcbiAgICAgIHJldHVybiB1c2VWZWM0ID8gTk9UX0VRVUFMX1ZFQzQgOiBOT1RfRVFVQUw7XG4gICAgY2FzZSBCaW5hcnlPcFR5cGUuUE9XOlxuICAgICAgcmV0dXJuIHVzZVZlYzQgPyBQT1dfVkVDNCA6IFBPVztcbiAgICBjYXNlIEJpbmFyeU9wVHlwZS5QUkVMVTpcbiAgICAgIHJldHVybiB1c2VWZWM0ID8gUFJFTFVfVkVDNCA6IFBSRUxVO1xuICAgIGNhc2UgQmluYXJ5T3BUeXBlLlNRVUFSRURfRElGRkVSRU5DRTpcbiAgICAgIHJldHVybiBTUVVBUkVEX0RJRkZFUkVOQ0U7XG4gICAgY2FzZSBCaW5hcnlPcFR5cGUuU1VCOlxuICAgICAgcmV0dXJuIFNVQjtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBCaW5hcnlUeXBlICR7dHlwZX0gaXMgbm90IGltcGxlbWVudGVkIWApO1xuICB9XG59XG4iXX0=